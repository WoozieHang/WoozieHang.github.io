<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【知识总结】 第一章-计算机系统概述</title>
    <url>/2021/10/23/ComputerOrganization-1/</url>
    <content><![CDATA[<h2 id="基本概念">基本概念</h2>
<ul>
<li>机器语言：计算机能直接识别执行的语言，机器语言的程序由0、1代码序列组成</li>
<li>汇编语言：把机器指令表示为助记符，与机器语言指令一一对应</li>
<li>高级语言：接近自然语言，按约定符号和规则写程序</li>
<li>编译程序：把高级语言程序翻译成机器语言目标代码的系统软件</li>
<li>汇编程序：把汇编语言程序翻译成机器语言目标代码的系统软件</li>
<li>字长：运算器能并行参与运算的数据位数，取决于CPU内部寄存器的数据宽度</li>
<li>系列机：一个厂家生产的，具有相同的系统结构，但具有不同组成和实现的一系列不同型号机器</li>
<li>软件兼容：现有的软件在升级换代后的新机器上可以使用</li>
<li>虚拟机器：从使用者角度，计算机系统是硬件上的虚拟机器；虚拟机依靠软件存在，软件扩充了系统功能</li>
<li>二进制位：是数字计算机中信息最小的位</li>
<li>字节：8个二进制数是1个字节。计算机系统存储器按字节编址。</li>
<li>内存地址：给存储器每个位置编号，方便访问指定位置，该编号是内存地址</li>
</ul>
<h2 id="计算机系统层次结构">计算机系统层次结构</h2>
<h3 id="计算机系统的组成">计算机系统的组成</h3>
<ul>
<li>硬件系统：有形的物理设备，计算机系统中实际物理装置的总称</li>
<li>软件系统：在硬件上运行的程序、相关数据、文档</li>
</ul>
<h3 id="计算机硬件的基本组成">计算机硬件的基本组成</h3>
<h4 id="早期冯诺依曼机">早期冯诺依曼机</h4>
<p>冯诺依曼提出了“存储程序”概念（指令以代码形式事先输入主存储器，按程序首地址开始按顺序执行直至程序结束）和二进制原理，以此概念原理为基础的各种计算机通称为冯诺依曼机，特点如下：</p>
<ul>
<li>计算机硬件系统由运算器、存储器、控制器、输入设备、输出设备5个部分组成</li>
<li>指令和数据以同等地位存到存储器中，按址访问</li>
<li>指令和数据以二进制代码表示</li>
<li>指令由操作码和地址码组成，操作码是操作的类型，地址码指出操作的地址</li>
<li>指令在存储器内按顺序存放。通常是顺序执行，特定条件下可以改变执行顺序</li>
</ul>
<h4 id="现代计算机组织结构">现代计算机组织结构</h4>
<ul>
<li><strong>早期的冯诺依曼机以运算器为中心</strong>，输出输出设备通过运算器与存储器传送数据</li>
<li><strong>现代计算机以存储器为中心</strong>，输入输出尽量绕过CPU，提高效率。</li>
<li>现代计算机仍然遵循存储程序的设计思想</li>
</ul>
<h4 id="硬件组成和功能">硬件组成和功能</h4>
<p>现代计算机虽然结构和冯诺依曼机有区别，但硬件组成和功能相同，具体如下</p>
<ul>
<li>输入设备：用于输入原始数据和程序，如键盘、鼠标</li>
<li>输出设备：用于输出计算机处理结果，如显示器、打印机</li>
<li>运算器：核心是一个算术逻辑运算部件ALU，完成信息或数据的处理运算，包括加、减、乘、除、比较、移位、逻辑运算，是计算机的执行部件</li>
<li>控制器：是整个计算机的指挥中心，在指令执行过程中产生指挥各个部件协同工作的控制信号</li>
<li>存储器：用于存放原始数据、程序、中间运算结果、最终处理结果。分为主（内）存储器和辅（外）存储器。CPU（即中央处理器，是运算器和控制器集成的芯片）能直接访问的程序和数据在主存储器中。此外，CPU和主存构成主机，外存和IO设备是外部设备。</li>
</ul>
<h3 id="计算机系统软件分类">计算机系统软件分类</h3>
<ul>
<li>系统软件
<ul>
<li>一组保证计算机系统高效正确运行的基础软件，作为系统资源供用户使用。</li>
<li>主要包括操作系统（OS）、数据库管理系统（DBMS）、语言处理程序、分布式软件系统、网络软件系统、标准库程序、服务性程序</li>
</ul></li>
<li>应用软件
<ul>
<li>用户为了解决某个应用领域的问题编写的程序</li>
<li>例如科学计算程序、工程设计程序、数据统计处理程序</li>
</ul></li>
</ul>
<h3 id="计算机软件和硬件的关系">计算机软件和硬件的关系</h3>
<ul>
<li>是完整计算机系统中相互依存的两大部分
<ul>
<li>硬件是软件工作的物质基础，支持软件发挥性能</li>
<li>软件是硬件发挥作用的途径，完善的软件系统能充分发挥硬件各种功能</li>
</ul></li>
<li>软件和硬件有逻辑等价性
<ul>
<li>软件能完成的工作硬件也能完成</li>
<li>硬件能完成的工作软件大多也能完成</li>
<li>软件实现更灵活、可复制</li>
<li>硬件实现更高效</li>
</ul></li>
</ul>
<h3 id="计算机工作原理">计算机工作原理</h3>
<h4 id="存储程序工作方式">存储程序工作方式</h4>
<p>计算机的工作过程是</p>
<ul>
<li>把数据和程序装入主存储器</li>
<li>将源程序转换成可执行文件，并保存到磁盘上</li>
<li>存储程序工作方式：把可执行文件保存到主存储器中，并从首地址开始逐条执行指令</li>
</ul>
<h4 id="高级语言程序与机器语言程序转换">高级语言程序与机器语言程序转换</h4>
<ul>
<li>解释方式
<ul>
<li>用专门的解释器将源程序逐行翻译为机器代码并立刻执行，不形成目标程序</li>
<li>每次执行都需要翻译一次，运行效率低，且不能脱离解释器独立运行</li>
<li>优点是只要提供特定平台的解释器，就可以方便实现源程序级别的跨平台移植</li>
</ul></li>
<li>编译方式
<ul>
<li>专用的编译器，一次将高级语言源程序翻译成机器语言程序，编译后生成，可执行目标程序可以脱离开发环境独立运行，效率高</li>
<li>如果需要移植到其他平台，则需要采用特定平台编译器重新编译</li>
<li>大部分编译程序直接产生机器语言目标文件，也有的先产生汇编语言代码文件，再用汇编程序处理产生可执行机器语言目标文件</li>
<li>举一个GCC编译器的例子
<ul>
<li>预处理阶段：输入源文件hello.c，经过预处理器cpp对源文件的“#”开头命令进行处理，去掉注释，输出hello.i</li>
<li>编译阶段：编译器ccl对预处理后的源程序进行编译，生成汇编语言源程序hello.s</li>
<li>汇编阶段：汇编器as把hello.s翻译成机器语言指令，并打包成可重定位目标文件hello.o，这是二进制文件，文本编辑器打开是乱码</li>
<li>链接阶段：链接器ld把多个可重定位目标文件和标准库函数合并为一个可执行目标文件hello，最终保存到磁盘上。</li>
</ul></li>
</ul></li>
</ul>
<h4 id="程序与指令的执行过程">程序与指令的执行过程</h4>
<p>程序的第一条地址存在PC中，完成一条指令，会计算下一条指令的地址，程序和指令的执行过程分为三个阶段：</p>
<ul>
<li>取指令</li>
<li>分析指令</li>
<li>执行指令</li>
</ul>
<h3 id="计算机系统层次结构-1">计算机系统层次结构</h3>
<ul>
<li>层次划分为
<ul>
<li>第0级机器：硬联逻辑级。由门电路、触发器等逻辑电路构成</li>
<li>第1级机器：微程序级。根据各指令操作的控制时序，用微指令写微程序，控制信息在部件之间传送</li>
<li>第2级机器：传统机器语言机器。机器语言程序员用此级指令系统写程序，并由第1级解释或第0级直接实现</li>
<li>第3级机器：操作系统机器（又叫混合层）。提供有人机交互功能的用户界面和底层系统调用服务例程。除了提供传统机器指令，还提供操作系统级别的指令（如打开文件，读写文件，关闭文件等）。</li>
<li>第4级机器：汇编语言机器。用汇编语言编写的程序，先由汇编程序翻译成第3级或第2级语言，再由相应机器解释。</li>
<li>第5级机器：高级语言机器。用高级语言写的程序由编译程序翻译成第4级或第3级机器上的语言，个别高级语言也用解释方式实现</li>
<li>第6级机器：应用语言机器。非计算机专业人员可以直接使用计算机，在用户终端用键盘或其他方式发出服务请求即可进入该级的信息处理系统</li>
</ul></li>
<li>在特定计算机系统中，有些级可能不存在</li>
<li>划分层次的意义
<ul>
<li>便于分开研究层内和层间的关系，优化系统结构</li>
<li>便于理解计算机系统软件硬件逻辑等价性</li>
</ul></li>
<li>虚拟机的概念：在硬件上由于软件的发展，扩充了计算机系统功能，不同语言用户面对的是不同层次的虚拟机</li>
<li>0-2层是没有软件配置的裸机，3-6层是虚拟机</li>
</ul>
<h2 id="计算机性能指标">计算机性能指标</h2>
<p>主要衡量性能的指标有存储容量和速度，常见的具体指标如下</p>
<ul>
<li>机器字长：计算机进行一次整数运算所能处理的二进制数据的位数，和CPU寄存器位数、加法器有关，通常是字节的整数倍</li>
<li>数据通路带宽：外部总线一次能传送的信息位数</li>
<li>主存储量：主存储器所能存储信息的最大容量，用字节衡量，或字数乘字长衡量</li>
<li>吞吐量：系统单位时间内处理请求的数量，主要取决于主存存取周期</li>
<li>响应时间：从用户发送请求，到计算机系统做出响应并获得结果需要的等待时间。包括CPU时间和等待时间（磁盘访问、存储器访问、IO、操作系统开销等）</li>
<li>CPU时钟周期：CPU最小时间单位</li>
<li>主频：CPU时钟周期的倒数，机器内部时钟的频率，单位HZ</li>
<li>CPI：平均每条指令执行需要的时钟周期数</li>
<li>IPC：每个时钟周期执行的指令条数</li>
<li>CPU执行时间：等于时钟周期数<span class="math inline">\(\times\)</span>时钟周期，等于(指令数<span class="math inline">\(\times\)</span> CPI)<span class="math inline">\(\times\)</span>时钟周期。这里的指令数、CPI、主频是相互制约的。</li>
<li>MIPS：每秒执行多少百万条的指令数（同时考虑了主频和CPI），等于指令条数/（<span class="math inline">\(10^6\times\)</span> 执行时间）= 1/（<span class="math inline">\(10^6\times\)</span> 每条指令执行时间）=
主频/（<span class="math inline">\(10^6\times\)</span>
CPI）。这种指标有缺陷，因为不同机器的指令集不同。</li>
<li>MFLOPS：每秒执行多少百万次浮点运算，等于浮点操作次数/(执行时间<span class="math inline">\(\times 10^6\)</span>)</li>
<li>GFLOPS：每秒执行多少十亿次浮点运算，等于浮点操作次数/(执行时间<span class="math inline">\(\times 10^9\)</span>)</li>
<li>TFLOPS：每秒执行多少万亿次浮点运算，等于浮点操作次数/(执行时间<span class="math inline">\(\times 10^{12}\)</span>)</li>
<li>PFLOPS：等于浮点操作次数/(执行时间<span class="math inline">\(\times
10^{15}\)</span>)</li>
<li>EFLOPS：等于浮点操作次数/(执行时间<span class="math inline">\(\times
10^{18}\)</span>)</li>
<li>ZFLOPS：等于浮点操作次数/(执行时间<span class="math inline">\(\times
10^{21}\)</span>)</li>
</ul>
<h2 id="补充">补充</h2>
<h3 id="关于常用前缀">关于常用前缀</h3>
<ul>
<li>描述存储容量、文件大小时，K、M、G、T是2的幂次，如1Kb=1024b</li>
<li>描述速度、频率时，k、M、G、T，是10的幂次，如1kb/s=1000b/s</li>
<li>前者用大写的K，后者用小写的k，其他的都用大写</li>
</ul>
<h3 id="关于透明性">关于透明性</h3>
<ul>
<li>计算机领域的透明性，指的是<strong>不可见</strong>的事物</li>
<li>比如
<ul>
<li>高级语言程序员，不可见乘法指令、浮点数格式</li>
<li>机器语言或汇编程序员不可见IR、MAR、MDR</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第六章-总线</title>
    <url>/2021/11/05/ComputerOrganization-6/</url>
    <content><![CDATA[<h2 id="总线概述">总线概述</h2>
<h3 id="基本概念">基本概念</h3>
<h4 id="总线定义">总线定义</h4>
<ul>
<li>定义：一组能为多个部件<strong>分时</strong>和<strong>共享</strong>公共信息的传送线路</li>
<li>这里的分时和共享是总线的两个特点（时间方面和空间方面）</li>
<li>分时：同一时刻只允许一个部件使用总线，多个部件需要分时</li>
<li>共享：总线可以挂接多个部件</li>
</ul>
<h4 id="总线设备分类">总线设备分类</h4>
<ul>
<li>主设备：有主线控制权的设备</li>
<li>从设备：被主设备访问的设备，只能响应来自主设备的总线命令</li>
</ul>
<h4 id="总线特性">总线特性</h4>
<ul>
<li>机械特性：尺寸、形状等</li>
<li>电气特性：传输方向、有效电平范围</li>
<li>功能特性：每根传输线的功能</li>
<li>时间特性：信号和时序的关系</li>
</ul>
<h4 id="总线猝发传输方式">总线猝发传输方式</h4>
<ul>
<li>指的是可以连续传送地址连续的多个数据字（而不用每次都传地址）</li>
<li>由主存总线（详见后面多总线结构）支持</li>
</ul>
<h3 id="总线分类">总线分类</h3>
<p><em>按功能分类</em></p>
<ul>
<li>片内总线：CPU芯片内部的总线
<ul>
<li>CPU内寄存器之间</li>
<li>CPU内寄存器和ALU之间</li>
</ul></li>
<li>系统总线
<ul>
<li>数据总线
<ul>
<li>计算机系统各部件传送数据信息</li>
<li>双向传输</li>
<li>位数和机器字长、存储字长有关</li>
</ul></li>
<li>地址总线
<ul>
<li>指出数据总线上的数据所在主存单元</li>
<li>单向传输</li>
<li>位数和主存地址空间大小有关</li>
</ul></li>
<li>控制总线
<ul>
<li>传输CPU控制命令或主存或外设返回CPU的反馈信号</li>
<li>可以是单向或双向传输</li>
</ul></li>
<li>电源线和地线：为总线、设备、部件提供电源</li>
</ul></li>
<li>通信总线
<ul>
<li>计算机系统之间传送信息的总线</li>
<li>又叫外部总线 <em>按时序控制方式分类</em></li>
</ul></li>
<li>同步总线</li>
<li>异步总线</li>
</ul>
<p><em>按数据传输格式分类</em></p>
<ul>
<li>并行总线</li>
<li>串行总线</li>
</ul>
<h3 id="总线结构">总线结构</h3>
<ul>
<li>单总线结构
<ul>
<li>把CPU、内存、IO设备接口（IO设备有磁盘、打印机、显示器、键盘）挂到<strong>一组</strong>总线上</li>
<li>这里的单指的是单组，包括地址总线、数据总线、控制总线多根线</li>
<li>结构简单、成本低；带宽低、负载重、不能并发传送</li>
</ul></li>
<li>双总线结构
<ul>
<li>把CPU、内存、通道挂到主存总线（包括地址总线、数据总线、控制总线）上</li>
<li>把外部设备接口和通道（通道认为是简化版的CPU，复杂对IO进行管理）挂到IO总线上</li>
<li>实现了存储器总线和低速的IO总线分离；需要增加通道硬件设备</li>
</ul></li>
<li>三总线结构
<ul>
<li>CPU和主存挂到主存总线（包括地址总线、数据总线、控制总线多根线）</li>
<li>主存和<strong>高速</strong>IO设备接口（如磁盘是高速IO设备）挂到DMA总线（直接访存总线）</li>
<li>CPU和IO设备接口挂到IO总线</li>
<li>提高IO设备的性能和系统吞吐量；系统工作效率变低（同一时刻只有一套总线工作）</li>
</ul></li>
</ul>
<h3 id="性能指标">性能指标</h3>
<ul>
<li>总线传输周期
<ul>
<li>即总线周期，指一次总线操作需要的时间</li>
<li>包括申请分配阶段、寻址阶段、传输阶段、结束阶段（详见总线事务）</li>
<li>由若干时钟周期组成</li>
</ul></li>
<li>总线时钟周期：计算机的时钟周期，总线也受到时钟控制</li>
<li>总线的工作频率：总线周期的倒数，即每秒传输几次数据</li>
<li>总线的时钟频率：时钟周期的倒数</li>
<li>总线宽度：即总线的位数，也可以说是根数，比如32根即32位的总线</li>
<li><strong>总线带宽</strong>
<ul>
<li>总线的数据传输率，即单位时间传送的数据字节数</li>
<li>等于<span class="math inline">\(\frac{1}{8}\times\)</span>总线工作频率<span class="math inline">\(\times\)</span>总线宽度</li>
</ul></li>
<li>总线复用：同一种信号线在不同时间传输不同的信息，节约空间成本</li>
<li>信号线数：地址总线、数据总线、控制总线的线数总和</li>
</ul>
<h2 id="总线事务">总线事务</h2>
<p><em>指的是从请求总线到完成总线使用的一个总线周期内的一系列获得</em></p>
<ul>
<li>申请分配阶段
<ul>
<li>请求操作：主设备（CPU或DMA）申请获得总线控制权</li>
<li>仲裁阶段：总线仲裁机构决定把下一周期总线使用权授予某<strong>一个</strong>申请者</li>
</ul></li>
<li>寻址阶段：主设备通过总线给出从设备地址、有关命令，启动从模块</li>
<li>传输阶段：主模块和从模块数据交换（单向或双向）</li>
<li>释放阶段：主模块撤出在系统总线上的有关信息，让出总线控制权</li>
</ul>
<h2 id="总线定时">总线定时</h2>
<h3 id="同步定时方式">同步定时方式</h3>
<ul>
<li>定义：系统采用统一时钟信号协调发送方接收方的传送定时关系</li>
<li>优点：传送速度快、控制逻辑简单</li>
<li>缺点：主从设备强制同步；适合总线短、所连部件存取时间接近（因为时钟周期以较慢部件为准，存取时间差距大会导致高速部件效率低）；不能校验数据有效性</li>
</ul>
<h3 id="异步定时方式">异步定时方式</h3>
<ul>
<li>定义：主从设备间，没有统一的时钟，双方依靠握手信号实现定时控制</li>
<li>优点：总线周期长度可变；对于工作速度差别大的部件也可以可靠高效的交换信息</li>
<li>缺点：速度慢，控制复杂</li>
<li>分类
<ul>
<li>不互锁方式
<ul>
<li>主设备发送请求，一段时间后撤销请求</li>
<li>从设备发送回答，一段时间后撤销回答</li>
</ul></li>
<li>半互锁方式
<ul>
<li>主设备发送请求，接收到回答后再撤销请求</li>
<li>从设备发送回答，一段时间后撤销回答</li>
</ul></li>
<li>全互锁方式
<ul>
<li>主设备发送请求，接收到回答后再撤销请求</li>
<li>从设备发送回答，获知主设备请求撤销后撤销回答</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 密码学基础</title>
    <url>/2022/03/04/Cryptography-1/</url>
    <content><![CDATA[<h2 id="安全目标">安全目标</h2>
<ul>
<li>机密性
<ul>
<li>防止信息非授权泄露</li>
</ul></li>
<li>完整性
<ul>
<li>防止信息非授权修改</li>
</ul></li>
<li>可用性
<ul>
<li>信息及时可靠的访问使用</li>
</ul></li>
</ul>
<h2 id="攻击">攻击</h2>
<h3 id="攻击类型">攻击类型</h3>
<ul>
<li>危害机密性
<ul>
<li>侦听：非授权实体访问或拦截信息</li>
<li>流量分析：通过监控在线流量来获取其他信息</li>
</ul></li>
<li>危害完整性
<ul>
<li>篡改：拦截到信息之后攻击者对信息进行修改</li>
<li>伪装：假装成别的实体</li>
<li>重放：获得的消息再次发送</li>
<li>否认：发送者否认曾经发送过信息或接收者否认曾经接收过信息</li>
</ul></li>
<li>危害可用性
<ul>
<li>拒绝服务攻击：减慢或中断系统的服务</li>
</ul></li>
</ul>
<h3 id="主动攻击和被动攻击">主动攻击和被动攻击</h3>
<ul>
<li>危害机密性为被动攻击
<ul>
<li>获取信息而不修改信息的攻击</li>
<li>容易预防但难以检测</li>
</ul></li>
<li>危害完整性和可用性
<ul>
<li>修改或伪造信息的攻击</li>
<li>难以预防但易于检测</li>
</ul></li>
</ul>
<h3 id="密码学术语">密码学术语</h3>
<ul>
<li>明文
<ul>
<li>原始消息</li>
</ul></li>
<li>密文
<ul>
<li>加密</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第七章-输入输出系统</title>
    <url>/2021/11/06/ComputerOrganization-7/</url>
    <content><![CDATA[<h2 id="基本概念">基本概念</h2>
<ul>
<li>输入：信息从外部送到主机</li>
<li>输出：信息从主机送到外部</li>
<li>接口：外设和主机传输数据进行协调（比如速度匹配、电平和格式转换）的逻辑部件</li>
<li>外部设备：输入输出设备或通过输入输出接口才能访问的外存储设备
<ul>
<li>输入设备：键盘、鼠标</li>
<li>输出设备：打印机、显示器</li>
<li>外存设备：硬磁盘、光盘、U盘</li>
</ul></li>
<li>IO系统构成
<ul>
<li>IO软件
<ul>
<li>包括：驱动程序、用户程序、管理程序、升级补丁</li>
<li>通过IO指令和通道指令（详见后面IO控制方式的通道方式）实现CPU和IO设备信息交换</li>
</ul></li>
<li>IO硬件：
<ul>
<li>包括：外部设备、设备控制器和接口、IO总线</li>
<li>设备控制器控制IO设备</li>
<li>IO接口（或设备控制器、适配器）和总线相连</li>
<li>IO端口是接口电路的一些寄存器，可被CPU访问；IO接口是主机和外部的交接面（详见IO接口小节）</li>
</ul></li>
</ul></li>
<li>IO控制方式
<ul>
<li>程序查询方式：CPU通过程序查询IO设备是否可用</li>
<li>程序中断方式：IO设备可用时向CPU发出中断请求</li>
<li>DMA方式：用于主存和IO设备的数据交换，无需调用中断服务程序</li>
<li>通道方式
<ul>
<li>系统设置通道控制部件，每个通道挂接若干外设</li>
<li>通道程序保存在主存，由通道执行通道指令</li>
<li>通道指令实现数据传送，即执行IO操作（包括读、写、磁盘走带、寻道等）</li>
<li>IO指令实现启停IO设备、查询通道和IO设备状态、对通道进行控制等</li>
</ul></li>
</ul></li>
</ul>
<h2 id="外部设备">外部设备</h2>
<h3 id="输入设备">输入设备</h3>
<ul>
<li>键盘
<ul>
<li>矩阵形式排列按键</li>
<li>按下键电信号连通；松开键电信号断开</li>
<li>键盘输入信息步骤：查出按哪个键、翻译为ASCII码、编码传给主机</li>
</ul></li>
<li>鼠标
<ul>
<li>控制光标位置的定位输入设备</li>
<li>分为机械式和光电式</li>
<li>鼠标底部有传感器，可能检测运动的方向和距离</li>
</ul></li>
</ul>
<h3 id="输出设备">输出设备</h3>
<ul>
<li>显示器
<ul>
<li>按器件分类
<ul>
<li>阴极射线管（CRT）显示器</li>
<li>液晶显示器（LCD）</li>
<li>发光二极管（LED）显示器</li>
</ul></li>
<li>按信息内容分类
<ul>
<li>字符显示器</li>
<li>图形显示器</li>
<li>图像显示器</li>
</ul></li>
<li>按扫描方式分类（CRT显示器）
<ul>
<li>光栅扫描显示器：只能按固定顺序扫描，比如一行一行扫描</li>
<li>随机扫描显示器：可以按随意方向扫描</li>
</ul></li>
<li>显示器按点阵方式运行，主要参数有
<ul>
<li>屏幕大小：对角线长度，单位英寸</li>
<li>分辨率：长宽的像素乘积</li>
<li>灰度级：同一个像素的灰度个数，比如8位有256个灰度，是256级</li>
<li>刷新：在光点消失前重新扫描显示，一次刷新需要扫描整个屏幕（通常是按行扫描）</li>
<li>刷新频率：单位时间刷新的次数，通常是60-120HZ（大于30HZ人类视觉就感受不到闪烁）</li>
<li>显示存储器（VRAM）：即刷新存储器</li>
<li>VRAM容量：分辨率<span class="math inline">\(\times\)</span>灰度级位数，单位比特</li>
<li>VRAM带宽：VRAM容量<span class="math inline">\(\times\)</span>帧频（帧频是单位时间的画面数量，可以认为等于刷新频率）</li>
</ul></li>
</ul></li>
<li>打印机
<ul>
<li>按工作原理分类
<ul>
<li>击打式：比如针式打印机</li>
<li>非击打式：用物理化学方法印刷，比如喷墨式、激光打印机</li>
</ul></li>
<li>按工作方式分类（都是点阵打印机）
<ul>
<li>针式打印机：多层复写，适合票据打印。原理简单、价格便宜；分辨率低、打印速度慢</li>
<li>喷墨式打印机：噪声小、高质量彩印、打印快；防水差</li>
<li>激光打印机：激光技术和电子显像技术结合，核心部件是感光鼓。打印质量高、速度快、噪声小；价格贵、不能复写打印</li>
</ul></li>
</ul></li>
</ul>
<h3 id="存储设备">存储设备</h3>
<h4 id="基本介绍">基本介绍</h4>
<ul>
<li>目前主要使用磁表面存储器，如磁盘、磁带、磁鼓</li>
<li>容量大、可重复记录、可脱机存储、非破坏读出；存取慢、结构复杂</li>
</ul>
<h4 id="磁盘存储器">磁盘存储器</h4>
<p><em>本节在第三章的外存储器中也有介绍，可以对应参考</em></p>
<ul>
<li>组成
<ul>
<li>磁盘
<ul>
<li>磁头数：即盘面数，一个磁头对应一个盘面</li>
<li>柱面数：即一个盘面的磁道数</li>
<li>扇区数：即一个磁道的扇区个数。扇区又叫块，磁盘读写基本单位，磁盘按块存取。</li>
</ul></li>
<li>磁盘驱动器：驱动磁盘转动并在盘面上通过磁头进行读写的装置，每个驱动器对应一个磁盘</li>
<li>磁盘控制器：属于磁盘面向计算机的接口设备，接受计算机命令，向磁盘驱动器发出控制信号</li>
</ul></li>
<li>原理
<ul>
<li>磁头和磁性介质相对运动完成读写操作</li>
<li>用存储介质的磁层磁化翻转状态表示二进制信息</li>
</ul></li>
<li>性能指标
<ul>
<li>容量
<ul>
<li>非格式化容量：可利用的磁化单元总数</li>
<li>格式化容量：按某种格式能记录的信息总量</li>
</ul></li>
<li>记录密度
<ul>
<li>道密度：半径方向单位长度磁道数</li>
<li>位密度：磁道单位长度的二进制代码位数</li>
<li>面密度：位密度乘以道密度，即单位面积二进制信息量</li>
</ul></li>
<li>平均存取时间
<ul>
<li>寻道时间：半径方向定位，移动磁头到目标磁道的平均时间</li>
<li>旋转时间：角度定位，取盘面旋转半圈的时间</li>
<li>传输时间：定位后的传输时间</li>
</ul></li>
<li>数据传输率：单位时间传输到主机的字节数，等于每秒转圈数<span class="math inline">\(\times\)</span>一个磁道的容量</li>
</ul></li>
<li>磁盘地址
<ul>
<li>驱动器号</li>
<li>磁道号（柱面号）</li>
<li>盘面号</li>
<li>扇区号</li>
</ul></li>
<li>磁盘工作过程
<ul>
<li>操作为：寻址、读盘、写盘</li>
<li>每个操作对应一个控制字，具体操作是取控制字、执行控制字</li>
<li>硬盘的所有读写操作都是串行，不能同时进行</li>
</ul></li>
</ul>
<h4 id="磁盘阵列">磁盘阵列</h4>
<ul>
<li>RAID（廉价冗余磁盘阵列）：把多个物理磁盘组成一个独立逻辑磁盘，数据交叉存储，并行访问</li>
<li>RAID按可靠性等级从低到高分为
<ul>
<li>RAID0：无冗余、无校验</li>
<li>RAID1：采用磁盘镜像</li>
<li>RAID2：采用纠错海明码</li>
<li>RAID3：采用位交叉奇偶校验</li>
<li>RAID4：采用块交叉奇偶校验</li>
<li>RAID5：采用无独立校验的奇偶校验</li>
</ul></li>
<li>RAID0容量大、并行存取、速度快；没有容错能力</li>
<li>RAID1用两个磁盘同时读写，相互备份；容量减半</li>
<li>特点总结：使用多个磁盘并行存取，速度快；通过<strong>镜像</strong>和<strong>校验</strong>提高可靠性和容错能力</li>
</ul>
<h4 id="光盘存储器">光盘存储器</h4>
<ul>
<li>利用光学原理，非接触方式记录信息</li>
<li>组成：驱动器、控制器、光盘片、驱动软件</li>
<li>特点：存储密度高、轻便、便宜、容量大、存储期限久、易保存</li>
<li>分类
<ul>
<li>CD-ROM：只读型光盘</li>
<li>CD-R：只可写入一次信息</li>
<li>CD-RW：可重复读写的光盘</li>
<li>DVD-ROM（DVD是通用数字化多功能光盘）：高容量CD-ROM</li>
</ul></li>
</ul>
<h4 id="固态硬盘">固态硬盘</h4>
<ul>
<li>详见第三章ROM存储器小节的固态硬盘内容</li>
</ul>
<h2 id="io接口">IO接口</h2>
<p><em>IO接口是主机和外设的交接面，解决主机和外设信息形式和工作速度的差异问题</em></p>
<h3 id="功能">功能</h3>
<ul>
<li>控制主机和外设的通信，协调工作速度不同的问题</li>
<li>对CPU送来的地址码进行译码并选择设备</li>
<li>实现数据缓冲，也是为了解决速度不匹配问题</li>
<li>信号格式转换，解决信息形式不一致问题。比如电平转换、并-串或串-并转换、模-数或数-模转换</li>
<li>传送CPU控制命令、反馈外设的状态信息</li>
</ul>
<h3 id="结构">结构</h3>
<ul>
<li>IO接口的外部，主机侧通过IO总线连接内存、CPU等主机的设备，外设侧连接着各个外部设备</li>
<li>IO接口内部包括
<ul>
<li>数据缓冲寄存器
<ul>
<li>双向的保存缓冲数据</li>
<li>连接数据总线</li>
</ul></li>
<li>状态寄存器
<ul>
<li>从外设到主机传送状态信息</li>
<li>连接数据总线和IO控制逻辑部件</li>
</ul></li>
<li>控制寄存器
<ul>
<li>从主机到外设传送控制信息</li>
<li>连接数据总线和IO控制逻辑部件</li>
</ul></li>
<li>IO控制逻辑部件
<ul>
<li>地址译码、传送控制信号到外设控制逻辑、传送状态到状态寄存器、发送或接收缓冲寄存器数据</li>
<li>连接地址总线、控制总线、控制寄存器、状态寄存器、数据缓冲寄存器</li>
</ul></li>
<li>外设界面控制逻辑
<ul>
<li>接收或发送数据到外设，接受外设的状态发给IO控制逻辑，把IO控制逻辑发来的控制发送给外设</li>
<li>连接外设、连接IO控制逻辑部件</li>
</ul></li>
</ul></li>
<li>对IO接口里的寄存器的访问通过<strong>操作系统的IO特权指令</strong></li>
<li>IO接口的这些可读写寄存器叫做IO端口</li>
</ul>
<h3 id="类型">类型</h3>
<ul>
<li>按IO接口外设侧的传送数据方式分类
<ul>
<li>并行接口：多个位同时传</li>
<li>串行接口：一位一位的传</li>
</ul></li>
<li>按主机的IO控制方式分类
<ul>
<li>程序查询接口</li>
<li>中断接口</li>
<li>DMA接口</li>
</ul></li>
<li>按功能的灵活性分类
<ul>
<li>可编程接口</li>
<li>不可编程接口</li>
</ul></li>
</ul>
<h3 id="io端口">IO端口</h3>
<ul>
<li>指的是接口电路被CPU可直接访问的寄存器</li>
<li>分为数据端口（CPU可读写）、状态端口（CPU可读）、控制端口（可写）</li>
<li>IO端口加上一些控制逻辑组成IO接口</li>
<li>IO端口被CPU访问需要进行编址，编址方式有
<ul>
<li>统一编址
<ul>
<li>又叫存储器映射方式，把IO当作存储器的单元进行地址分配</li>
<li>优点是不需要专门的IO指令，方便；缺点是内存容量变小，执行速度慢</li>
</ul></li>
<li>独立编址
<ul>
<li>又叫IO映射方式，IO端口的地址空间和主存地址空间是两个独立的空间</li>
<li>地址码形式相同，需要设置专门的IO指令来访问IO端口</li>
<li>优点是编程清晰、容易理解；缺点是需要CPU提高存储器读写、IO设备读写两组控制信号，复杂</li>
</ul></li>
</ul></li>
</ul>
<h2 id="io方式">IO方式</h2>
<h3 id="程序查询">程序查询</h3>
<ul>
<li>由主机程序实现信息交换</li>
<li>工作流程如下
<ul>
<li>CPU初始化程序，设置传送参数</li>
<li>向IO接口发出命令，启动IO设备</li>
<li>取外设状态，不断查询外设状态，直至就绪</li>
<li>传送一次数据</li>
<li>修改地址，计数器（记录还需要传送几次数据）减1</li>
<li>当计数器大于0则返回第三步，否则程序结束</li>
</ul></li>
<li>优点是设计简单、设备量少；缺点是CPU查询等待耗费时间（CPU踏步等待现象），且一段时间只能和一台设备交换信息</li>
</ul>
<h3 id="程序中断">程序中断</h3>
<ul>
<li>详见计组笔记第五章的异常和中断机制</li>
<li>补充一个IO接口角度的中断驱动方式工作流程
<ul>
<li>接收CPU读命令</li>
<li>从外部设备读数据到数据寄存器</li>
<li>提供控制线给CPU发送中断信号</li>
<li>接收CPU取数据请求</li>
<li>把数据放到数据总线，传到CPU的寄存器中</li>
</ul></li>
</ul>
<h3 id="dma方式">DMA方式</h3>
<h4 id="dma方式特点">DMA方式特点</h4>
<ul>
<li>外设和内存有直接数据通路，全称是直接存储器存取方式</li>
<li>数据不经过CPU，IO和CPU并行工作，不需要保存恢复CPU现场等操作，传送速度快</li>
<li>数据块传送时，主存地址、传送数据计数由硬件电路实现</li>
<li>主存开辟专门的缓冲区，接收和供给外设数据</li>
<li>开始前：通过程序进行预处理</li>
<li>结束后：通过中断方式进行后处理</li>
</ul>
<h4 id="dma控制器">DMA控制器</h4>
<ul>
<li>又叫DMA接口</li>
<li>组成为
<ul>
<li>主存地址计数器：存放数据主存地址</li>
<li>传送长度计数器：存放数据长度，计数溢出时即传送完毕（减到长度为0时）</li>
<li>数据缓冲寄存器：缓存传送的数据</li>
<li>DMA请求触发器：接收IO设备的就绪控制信号</li>
<li>控制/状态逻辑：协调同步DMA请求信号和CPU响应信号、指定传送方向、修改传送参数</li>
<li>中断机构：传送完毕后向CPU提出中断请求</li>
</ul></li>
<li>以单总线结构为例（即主存、CPU和IO接口都挂在一组总线上），DMA控制器功能如下（可结合后面的传送过程部分进行理解）
<ul>
<li>接受外设的DMA请求DRQ，向CPU发出总线请求HRQ</li>
<li>CPU发出总线响应信号HLDA，让出系统总线控制权（地址总线、数据总线、控制总线）给DMA控制器，进入DMA周期</li>
<li>确定传送数据的主存地址和长度，自动修改主存地址计数器和传送长度计数器</li>
<li>规定传送方向，发出读写控制信号，执行数据传送</li>
<li>向CPU报告DMA操作完成</li>
</ul></li>
</ul>
<h4 id="传送方式">传送方式</h4>
<p><em>CPU和IO设备同时访问主存时会发生冲突，本节介绍解决冲突的方式</em></p>
<ul>
<li>块传送方式（停止CPU访存）
<ul>
<li>由DMA控制器向CPU发送停止信号，总线控制权交给DMA控制器</li>
<li>工作完成后向CPU发出操作完成信号，总线控制器归还给CPU</li>
<li>适合高速IO</li>
</ul></li>
<li>单字传送方式（周期挪用、周期窃取）
<ul>
<li>当CPU不在访存：此时无冲突</li>
<li>当CPU正在访存：待存取周期结束再让出总线控制器给DMA控制器</li>
<li>当CPU正在申请访存：IO访存的优先级更高，因为IO不立刻访存会丢失数据</li>
<li>适合低速IO</li>
</ul></li>
<li>DMA和CPU交替访存
<ul>
<li>要求主存存取周期不到CPU工作周期的一半</li>
<li>CPU工作周期分成两个部分，分别供CPU访存和DMA访存</li>
<li>不需要总线使用权的申请、建立、归还，而是通过分时控制</li>
</ul></li>
</ul>
<h4 id="传送过程">传送过程</h4>
<p><em>可结合前面的DMA控制器功能的部分进行理解</em></p>
<ul>
<li>预处理阶段
<ul>
<li>CPU执行IO指令
<ul>
<li>测试IO设备状态</li>
<li>设置DMA控制器的传送长度计数器和主存地址计数器的初值</li>
<li>设置传送方向</li>
<li>启动IO设备</li>
</ul></li>
<li>IO设备准备好后向DMA控制器发送DMA请求</li>
<li>DMA控制器向CPU发送总线请求（上一条的DMA请求和总线请求可以统称为DMA请求）</li>
</ul></li>
<li>数据传送阶段
<ul>
<li>基本传送单位：单字节、单字或数据块</li>
<li>本阶段完全由DMA硬件控制。比如基本传送单位为数据块的情况（比如硬盘），循环由DMA控制器实现而不是CPU</li>
<li>本阶段流程细化为（按单总线结构）
<ul>
<li>判断是否允许传送</li>
<li>是则把主存地址送总线，数据根据传送方向送IO设备或主存，修改主存地址计数器和传送长度计数器</li>
<li>判断是否结束传送。不结束则返回第一步，结束则进入后处理阶段</li>
</ul></li>
</ul></li>
<li>后处理阶段
<ul>
<li>DMA控制器向CPU发送中断请求</li>
<li>CPU执行中断服务程序做DMA结束处理
<ul>
<li>校验数据传输是否正确</li>
<li>错误需要转入诊断程序</li>
<li>决定是否继续用DMA传送数据块</li>
</ul></li>
</ul></li>
</ul>
<h4 id="和中断方式的区别">和中断方式的区别</h4>
<ul>
<li>中断方式是程序的切换，需要保存、恢复现场；DMA方式数据传送阶段不占用CPU任何资源</li>
<li>中断响应在指令执行周期后；DMA响应可以在各个机器周期后（取指、间址、执行周期后），CPU不需占用总线时，便可以进行响应</li>
<li>中断传送需要CPU干预；DMA传送不需要CPU干预，适合高速外设成组数据传送</li>
<li>DMA请求优先级高于中断请求，因为DMA传送几乎不占用CPU资源</li>
<li>中断方式还可以处理异常；DMA方式仅用于数据IO传送</li>
<li>中断方式靠程序传送；DMA方式靠硬件传送</li>
</ul>
<h3 id="通道控制方式">通道控制方式</h3>
<h4 id="流程">流程</h4>
<ul>
<li>CPU向IO通道发送IO指令</li>
<li>IO指令给出了通道程序首地址、要访问的IO设备</li>
<li>通道接收IO指令，执行通道程序</li>
<li>执行完成后通道向CPU发送中断请求</li>
</ul>
<h4 id="特点">特点</h4>
<ul>
<li>通道程序保存在内存，即和CPU共享内存</li>
<li>通道自己控制数据块大小、传输的内存位置
<ul>
<li>DMA方式在预处理阶段由CPU设置这些信息</li>
</ul></li>
<li>一个通道可以控制多台设备和内存的数据交换
<ul>
<li>DMA方式只能是一台设备</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 加密模式</title>
    <url>/2022/05/19/Cryptography-2/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第一章-绪论</title>
    <url>/2021/10/17/DataStructure-1/</url>
    <content><![CDATA[<h2 id="数据结构基本概念">数据结构基本概念</h2>
<h3 id="基本概念和术语">基本概念和术语</h3>
<ul>
<li>数据：信息的载体，描述客观事物属性，如数字、字符、所有能输入计算机中识别处理的符号集合</li>
<li>数据元素：数据基本单位（数据表中的一行），由数据项组成</li>
<li>数据项：数据元素不可分割的最小单位（理解成属性）</li>
<li>数据对象：数据元素的集合，数据的子集</li>
<li>数据类型：值的集合和定义在此集合上的一组操作的总称
<ul>
<li>原子类型：值不可再分</li>
<li>结构类型：值可以再分</li>
<li>抽象数据类型：抽象数据组织和操作（即结构和运算）</li>
</ul></li>
<li>数据结构：存在<strong>关系</strong>的数据元素的集合
<ul>
<li>数据指数据元素</li>
<li>结构指数据元素之间的关系</li>
<li>定义数据结构需要数据对象、结构关系、操作运算</li>
</ul></li>
</ul>
<h3 id="数据结构的三要素">数据结构的三要素</h3>
<ul>
<li>逻辑结构：独立于计算机（物理存储），从逻辑上描述数据的关系，分为线性结构和非线性结构
<ul>
<li>线性结构（一对一的关系）
<ul>
<li>一般线性表</li>
<li>受限线性表：栈、队列、串</li>
<li>线性表推广：数组</li>
</ul></li>
<li>非线性结构
<ul>
<li>集合（属于同集合的关系）</li>
<li>树形结构（一对多的关系）：一般树、二叉树</li>
<li>图状结构（多对多的关系）：有向图、无向图</li>
</ul></li>
</ul></li>
<li>存储结构：计算机中对数据和关系的表示
<ul>
<li>顺序存储：逻辑相邻的元素在物理上也相邻存储
<ul>
<li>优点：可随机存取、节约空间</li>
<li>缺点：只能使用相邻的整块存储单元，容易产生碎片</li>
</ul></li>
<li>链式存储：逻辑相邻的元素在物理上可不相邻
<ul>
<li>优点：不会出现碎片，充分利用所有存储单元</li>
<li>缺点：引入额外指针空间开销、只能顺序存取</li>
</ul></li>
<li>索引存储：存储信息的同时，维护一个索引表（表的每个索引项包含关键字和地址）
<ul>
<li>优点：搜索速度快</li>
<li>缺点：索引表占用额外的存储空间，增删元素时维护索引表需要额外的开销</li>
</ul></li>
<li>散列存储：根据关键字直接算出存储地址，又叫哈希(Hash)存储
<ul>
<li>优点：检索增删操作快</li>
<li>缺点：如果散列函数不好，可能出现大量的冲突，从而增加时间空间开销</li>
</ul></li>
</ul></li>
<li>数据元素：包括运算定义和运算实现
<ul>
<li>定义：针对<strong>逻辑结构</strong>，指出运算的<strong>功能效果</strong></li>
<li>实现：针对<strong>存储结构</strong>，指出运算的<strong>操作步骤</strong></li>
</ul></li>
</ul>
<h2 id="算法和算法评价">算法和算法评价</h2>
<h3 id="算法基本概念">算法基本概念</h3>
<ul>
<li>定义：问题求解步骤的描述，指令的有限序列，指令由若干操作组成</li>
<li>特性：
<ul>
<li>有穷性：算法在有穷步结束，每一步在有穷时间完成</li>
<li>确定性：相同输入得到相同输入</li>
<li>可行性：算法的操作可以通过已有的基本运算执行有穷次实现</li>
<li>输入：零个或多个</li>
<li>输出：一个或多个</li>
</ul></li>
<li>目标：
<ul>
<li>正确性</li>
<li>可读性</li>
<li>鲁棒性</li>
<li>效率和低空间开销</li>
</ul></li>
</ul>
<h3 id="算法效率的度量">算法效率的度量</h3>
<ul>
<li>时间复杂度：假设<span class="math inline">\(n\)</span>为问题规模，<span class="math inline">\(f(n)\)</span>为频度，则时间复杂度定义为<span class="math inline">\(T(n)=O(f(n))\)</span>
<ul>
<li>最坏时间复杂度：最坏输入情况下的时间复杂度</li>
<li>平均时间复杂度：给定每种输入的概率后算出的时间复杂度期望</li>
<li>最好时间复杂度：最好输入情况下的时间复杂度</li>
<li>期望时间复杂度：针对随机算法，最坏输入情况下的期望随机复杂度。</li>
</ul></li>
<li>空间复杂度：定义为算法所耗费的存储空间
<ul>
<li>一般认为输入的空间取决于问题，与算法无关</li>
<li>只考虑额外空间即可</li>
<li>原地工作算法指额外空间开销为<span class="math inline">\(O(1)\)</span></li>
</ul></li>
</ul>
<h3 id="程序时间复杂度分析技巧">程序时间复杂度分析技巧</h3>
<ul>
<li>循环体变量参与循环条件判断：考虑该变量和循环次数的关系，用循环次数参与循环条件判断</li>
<li>循环体变量不参与循环条件判断：数学归纳法或者直接累计</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第二章-线性表</title>
    <url>/2021/10/17/DataStructure-2/</url>
    <content><![CDATA[<h2 id="线性表的定义">线性表的定义</h2>
<ul>
<li>线性表是具有相同数据类型的n个(<span class="math inline">\(n\geq
0\)</span>)数据元素的有限序列</li>
<li><span class="math inline">\(n\)</span>为表长</li>
<li>用<span class="math inline">\(L\)</span>命名，则表示为<span class="math inline">\(L=(a_1,a_2,\cdots,a_i,a_{i+1},\cdots,a_n)\)</span>，注意从1开始</li>
<li>特点
<ul>
<li>元素有限</li>
<li>逻辑上有顺序性（<strong>注：这里指先后次序而不是物理的顺序存储</strong>）</li>
<li>表中元素为数据元素，类型相同，存储空间大小相同</li>
<li>不考虑存储结构，属于逻辑结构</li>
</ul></li>
</ul>
<h2 id="线性表的顺序表示">线性表的顺序表示</h2>
<h3 id="定义">定义</h3>
<ul>
<li>线性表的顺序存储称作顺序表</li>
<li>线性表位序从1开始，数组下标从0开始</li>
<li>特点：逻辑结构和物理结构相同（插入删除要移动大量元素），可随机存取、存储密度高</li>
</ul>
<h2 id="线性表的链式表示">线性表的链式表示</h2>
<h3 id="定义-1">定义</h3>
<ul>
<li>线性表的链式存储称作单链表</li>
<li>优点：不需要大量连续存储单元、插入删除不需要移动大量元素</li>
<li>缺点：不能随机存取，引入额外指针空间开销</li>
</ul>
<h3 id="头结点和头指针">头结点和头指针</h3>
<ul>
<li>不管是否有头结点，<strong>头指针</strong>都指向链表第一个结点</li>
<li><strong>头结点</strong>是带头结点链表的第一个结点，但不存储信息</li>
<li>引入头结点的好处
<ul>
<li>统一链表第一个数据结点和其他位置结点的操作</li>
<li>对空表和非空表的处理进行了统一</li>
</ul></li>
<li>头结点指针为NULL，则链表为空</li>
</ul>
<h3 id="头插法和尾插法">头插法和尾插法</h3>
<ul>
<li>头插法，操作简单，但数据顺序和输入顺序相反</li>
<li>尾插法，额外增加一个尾指针</li>
<li>复杂度都是<span class="math inline">\(O(n)\)</span></li>
</ul>
<h3 id="其他链表">其他链表</h3>
<ul>
<li>双链表：每个结点中有前驱指针和后继指针（带头空表判断：头结点指针为NULL）</li>
<li>循环单链表：在单链表的基础上，表尾结点指针指向头结点（带头空表判断：头结点后继为头结点）</li>
<li>循环双链表：在双链表的基础上，表尾结点后继指向头结点，头结点前驱指向表尾结点（带头空表判断：头结点前驱和后继指针都指向头结点）</li>
<li>静态链表：借助数组描述线性表的链式存储结构
<ul>
<li>数据域：存储数据</li>
<li>指针域：存储结点的相对地址（数组下标，游标），从0开始</li>
<li>指针的NULL用-1表示</li>
<li>增删操作不需要移动元素，只需要修改指针。</li>
</ul></li>
</ul>
<h3 id="顺序表和链表的比较">顺序表和链表的比较</h3>
<ul>
<li>存取方式
<ul>
<li>顺序表可以随机存储</li>
<li>链表只能顺序存储</li>
</ul></li>
<li>逻辑结构和物理结构
<ul>
<li>顺序表逻辑相邻的元素在物理存储上相邻</li>
<li>链表通过指针表示元素的逻辑关系</li>
</ul></li>
<li>按值查找
<ul>
<li>顺序表有序时可以折半查找</li>
<li>链表不能折半查找</li>
</ul></li>
<li>按序号查找
<ul>
<li>顺序表<span class="math inline">\(O(1)\)</span></li>
<li>链表<span class="math inline">\(O(n)\)</span></li>
</ul></li>
<li>插入和删除
<ul>
<li>顺序表平均要移动半个表长的元素</li>
<li>链表只需要对应指针域</li>
</ul></li>
<li>存储密度
<ul>
<li>顺序表较大</li>
<li>链表需要额外的指针域</li>
</ul></li>
<li>空间分配
<ul>
<li>顺序表静态分配容易内存溢出或空间大量闲置；动态分配需要移动大量元素，且要求内存有大量连续空间</li>
<li>链表在需要时申请分配空间，操作灵活，空间利用高效。</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第四章-串</title>
    <url>/2021/10/17/DataStructure-4/</url>
    <content><![CDATA[<h2 id="串定义">串定义</h2>
<ul>
<li>字符串简称串</li>
<li>由零个或多个字符组成的有限序列，记为<span class="math inline">\(S=&#39;a_1a_2\cdots a_n&#39;\)</span>，<span class="math inline">\(n\geq 0\)</span></li>
<li>空串用空集<span class="math inline">\(\emptyset\)</span>表示</li>
<li>串中任意多个连续字符子序列称作子串，包含子串的叫主串</li>
<li>子串的位置指子串第一个字符在主串中的位置</li>
<li>两个串相等，指长度相等且对应位置字符相等</li>
<li>串的逻辑结构和线性表类似，但串的数据对象仅为字符，且串的操作对象一般是子串。</li>
</ul>
<h2 id="串的存储结构">串的存储结构</h2>
<ul>
<li>定长顺序存储：一般利用定长数组实现</li>
<li>堆分配动态存储：利用malloc和free函数</li>
<li>块链存储：每个结点可以放一个字符，也可以放多个。例如结点大小可以是4，最后一个结点如果不满4个字符用#补齐。</li>
</ul>
<h2 id="串的模式匹配">串的模式匹配</h2>
<p>子串的定位称作串的模式匹配，即求子串（模式串）在主串中的位置</p>
<h3 id="朴素模式匹配算法">朴素模式匹配算法</h3>
<p>即暴力搜索，假设主串大小<span class="math inline">\(m\)</span>，子串<span class="math inline">\(n\)</span>，则复杂度为<span class="math inline">\(O(mn)\)</span></p>
<h3 id="kmp算法">KMP算法</h3>
<h4 id="核心步骤">核心步骤</h4>
<ul>
<li>设主串为<span class="math inline">\(s_1\cdots
s_n\)</span>，模式串为<span class="math inline">\(p_1 \cdots
p_m\)</span></li>
<li>当主串的第i个字符和模式串的第j个字符失配，跳到子串的第<span class="math inline">\(next[j]\)</span>字符位置，与主串第i个位置进行继续比较（<strong>这里i和j都是从1开始</strong>）</li>
</ul>
<h4 id="next数组人工算法">next数组人工算法</h4>
<ul>
<li><span class="math inline">\(next[j]=0\)</span>，当<span class="math inline">\(j=1\)</span>。直观意思是<span class="math inline">\(s_i\)</span>与<span class="math inline">\(p_0\)</span>比较，本质就是<span class="math inline">\(s_{i+1}\)</span>与<span class="math inline">\(p_1\)</span>比较</li>
<li><span class="math inline">\(next[j]=max K\)</span>，当<span class="math inline">\(K\)</span>集合非空。这里的<span class="math inline">\(K\)</span>中元素<span class="math inline">\(k\)</span>满足<span class="math inline">\(1&lt;k&lt;j\)</span>，且<span class="math inline">\(p_1\cdots p_{j-1}\)</span>的前<span class="math inline">\(k-1\)</span>个字符和后<span class="math inline">\(k-1\)</span>个字符自匹配</li>
<li><span class="math inline">\(next[j]=1\)</span>，其他情况</li>
</ul>
<h4 id="next数组机器算法">next数组机器算法</h4>
<p>使用类似于数学归纳法的思想递推</p>
<ul>
<li><span class="math inline">\(next[1]=0\)</span></li>
<li>假设已知<span class="math inline">\(next[j]=k\)</span>，则<span class="math inline">\(next[j+1]=\)</span>？
<ul>
<li>由<span class="math inline">\(next[j]=k\)</span>，显然<span class="math inline">\(p_1\cdots
p_{j-1}\)</span>的前k-1子串和后k-1子串匹配</li>
<li>比较<span class="math inline">\(p_k\)</span>和<span class="math inline">\(p_j\)</span>
<ul>
<li>如果相等，说明<span class="math inline">\(p_1\cdots
p_j\)</span>的前k子串和后k子串匹配，则<span class="math inline">\(next[j+1]=k+1\)</span></li>
<li>如果不相等，令<span class="math inline">\(k=next[k]\)</span>，如果<span class="math inline">\(k&gt;0\)</span>则继续比较<span class="math inline">\(p_k\)</span>和<span class="math inline">\(p_j\)</span>，以此类推；如果<span class="math inline">\(k=0\)</span>则<span class="math inline">\(next[j+1]=k+1=1\)</span>（理解成<span class="math inline">\(p_1\cdots
p_j\)</span>的前0子串和后0子串匹配）</li>
<li>不相等的情况是KMP算法生涩的地方，可以直接记住，也可以根据例子来进行理解</li>
</ul></li>
</ul></li>
</ul>
<h4 id="kmp算法原理">KMP算法原理</h4>
<p>举例帮助理解：主串cabcabcac，子串abcac</p>
<ul>
<li>c和a不匹配，即子串第<span class="math inline">\(1\)</span>个位置不匹配，<span class="math inline">\(next[1]=0\)</span>，即主串的第<span class="math inline">\(1\)</span>个和子串的第<span class="math inline">\(0\)</span>个比较，也就是主串的第<span class="math inline">\(2\)</span>个和子串第<span class="math inline">\(1\)</span>个比较</li>
<li>主串的abca和子串abca匹配，但主串第<span class="math inline">\(6\)</span>的b和子串第<span class="math inline">\(5\)</span>的c不匹配</li>
<li><span class="math inline">\(next[5]=1+1=2\)</span>，则主串的第<span class="math inline">\(6\)</span>个b和子串第<span class="math inline">\(2\)</span>的b进行比较</li>
<li>完成匹配</li>
</ul>
<h4 id="kmp算法进一步优化">KMP算法进一步优化</h4>
<p>注意到前面核心步骤处：</p>
<ul>
<li>设主串为<span class="math inline">\(s_1\cdots
s_n\)</span>，模式串为<span class="math inline">\(p_1 \cdots
p_m\)</span></li>
<li>当主串的第i个字符和模式串的第j个字符失配，跳到子串的第<span class="math inline">\(next[j]\)</span>字符位置，与主串第i个位置进行继续比较（<strong>这里i和j都是从1开始</strong>）</li>
</ul>
<p>那么</p>
<ul>
<li>若<span class="math inline">\(p_{next[j]}=p_j\)</span>，必有<span class="math inline">\(p_{next[j]}=p_j\neq s_i\)</span>，失配是必然</li>
<li>因此为了避免<span class="math inline">\(p_j=p_{next[j]}\)</span>，将<span class="math inline">\(next[j]\)</span>反复修正为<span class="math inline">\(next[next[j]]\)</span>，直至<span class="math inline">\(p_j\neq p_{next[j]}\)</span></li>
<li>修正后的next记作nextval，可以从j=1开始修正，这样每次只需要修正一次<span class="math inline">\(nextval[j]=nextval[nextval[j]]\)</span>即可</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第三章-栈、队列和数组</title>
    <url>/2021/10/17/DataStructure-3/</url>
    <content><![CDATA[<h2 id="栈">栈</h2>
<h3 id="定义">定义</h3>
<ul>
<li>只能在栈顶进行插入和删除的线性表</li>
<li>后进先出结构</li>
<li>重要的数学结论：n个不同的元素，进栈顺序已知，则出栈顺序不同的排列有<span class="math inline">\(\frac{C_{2n}^{n}}{n+1}\)</span></li>
</ul>
<h3 id="顺序存储">顺序存储</h3>
<ul>
<li>利用连续存储单元存放元素，同时附设一个栈顶指针top</li>
<li>top可以表示栈顶元素的下标（非空情况从0开始），也可以表示栈顶元素的位序(数值上等于栈大小，非空情况从1开始)</li>
<li>前者空栈时，top为-1；后者空栈时top为0</li>
<li>前者进栈为<span class="math inline">\(S.data[++S.top]\)</span>，后者进栈为<span class="math inline">\(S.data[S.top++]\)</span></li>
<li>前者出栈为<span class="math inline">\(S.data[S.top--]\)</span>，后者出栈为<span class="math inline">\(S.data[--S.top]\)</span></li>
<li>共享栈
<ul>
<li>将两个栈的栈底设置在一维数组的两端，栈顶向内延申共享空间。</li>
<li>以top表示栈顶元素下标为例
<ul>
<li><span class="math inline">\(top1=-1\)</span>时1栈为空</li>
<li><span class="math inline">\(top2=Maxsize\)</span>时2栈为空</li>
<li><span class="math inline">\(top1=top2-1\)</span>时栈满</li>
</ul></li>
</ul></li>
</ul>
<h3 id="链式存储">链式存储</h3>
<ul>
<li>采用链式存储的栈，优点是便于多个栈共享存储空间，提高效率，不存在栈满上溢的情况。</li>
<li>通常用单链表实现，所有操作在表头进行</li>
<li>对于带头结点和不带头结点的链栈，具体的实现会有不同</li>
</ul>
<h2 id="队列">队列</h2>
<h3 id="定义-1">定义</h3>
<ul>
<li>只能在队头删除，在队尾插入的受限线性表</li>
<li>先进先出</li>
</ul>
<h3 id="顺序存储-1">顺序存储</h3>
<ul>
<li>使用连续的存储单元存放队列中的元素，附设指针front和rear。（不同教材指针定义不唯一，本笔记规定front表示队头位置，rear表示队尾元素的下一个位置）</li>
<li>使用顺序队列存在假溢出问题，即下标到了Maxsize，但是数组中还有空位置</li>
<li>可以改进为循环队列
<ul>
<li>初始：<span class="math inline">\(front=rear=0\)</span></li>
<li>入队：<span class="math inline">\(rear=(rear+1) mod
Maxsize\)</span></li>
<li>出队：<span class="math inline">\(front=(front+1) mod
Maxsize\)</span></li>
<li>队长：<span class="math inline">\((rear+Maxsize-front) mod
Maxsize\)</span></li>
<li>这里可以发现，最大容量实际上到不了<span class="math inline">\(Maxsize\)</span>，原因队空和队满的判断都是<span class="math inline">\(rear=front\)</span>，处理方法有三种
<ul>
<li>牺牲一个单元，默认情况，即队满判断是<span class="math inline">\((rear+1) mod Maxsize=front\)</span></li>
<li>增加一个size记录元素个数，以此区分队满和队空</li>
<li>增设tag标记，删除元素后tag为0，插入元素后tag为1。初始tag为0。以此记录最近一次操作是插入还是删除来判断队满和队空</li>
</ul></li>
</ul></li>
</ul>
<h3 id="链式存储-1">链式存储</h3>
<ul>
<li>队列的链式称为链队列</li>
<li>本质上是同时带有队头指针和队尾指针的单链表</li>
<li>不带头结点情况
<ul>
<li>当front和rear都是NULL时，队列为空</li>
<li>出队先判断是否空，空则无法出队；不空则front指向其后继。若没有后继，则front和rear都置NULL</li>
<li>入队先判断是否空，不空则将新结点插入到rear的后面并更新rear；空则设置front和rear都指向新结点</li>
</ul></li>
<li>带头结点情况（统一了操作，更方便，front此时就是头结点）
<ul>
<li>当front=rear时，队列为空</li>
<li>入队插入到rear后并更新rear</li>
<li>出队判断是否空，空则无法出队；不空则删除front的后继。若front后继为rear，则rear=front</li>
</ul></li>
<li>双端队列
<ul>
<li>普通情况：在两端都可以入队或出队</li>
<li>输出受限：只能在一端出队，可在两端入队</li>
<li>输入受限：只能在一端入队，可在两端出队</li>
</ul></li>
</ul>
<h2 id="栈和队列的应用">栈和队列的应用</h2>
<h3 id="括号匹配">括号匹配</h3>
<ul>
<li>问题：假设输入表达式包含圆括号方括号，任意嵌套，要求判断表达式合法性</li>
<li>算法：利用栈，遇到左括号压栈，遇到右括号则和栈中左括号进行匹配消解，不匹配则不合法。</li>
</ul>
<h3 id="表达式求值">表达式求值</h3>
<ul>
<li>后缀表达式的值计算：遇到操作数压栈，遇到操作符则弹出操作数进行计算，结果压栈</li>
<li>中缀表达式转后缀表达式：
<ul>
<li>人脑方法：利用二叉树的中序遍历和后序遍历得到结果</li>
<li>计算机算法
<ul>
<li>遇到数字直接输出到后缀表达式</li>
<li>遇到'('入栈</li>
<li>遇到')'依次弹出栈，加到后缀表达式，直到弹出了'('，不用加到后缀表达式</li>
<li>遇到其他运算符根据优先级规定，可能入栈，可能连续弹出，因为不好记，所以直接对照人脑方法得出的答案即可（仅限笔试）。</li>
</ul></li>
</ul></li>
</ul>
<h3 id="递归">递归</h3>
<ul>
<li>任何递归算法都可以用栈改成非递归算法</li>
<li>当然除了用栈，也可以根据状态转移方程用dp来做</li>
</ul>
<h3 id="广度优先遍历">广度优先遍历</h3>
<p>又叫做层次遍历，队列的应用</p>
<h3 id="计算机系统">计算机系统</h3>
<p>队列在操作系统的资源管理中也有应用：</p>
<ul>
<li>打印机数据缓冲区就是一个数据队列</li>
<li>cpu资源竞争也是进程的队列。</li>
</ul>
<h2 id="数组和特殊矩阵">数组和特殊矩阵</h2>
<h3 id="定义-2">定义</h3>
<ul>
<li>数组是由<span class="math inline">\(n\)</span>个(<span class="math inline">\(n\geq
1\)</span>)同类型数据元素构成的有限序列，每个数据元素称为一个数组元素</li>
<li>数组下标取值范围叫做维界</li>
<li>数组是线性表的推广
<ul>
<li>一维数组可以看作是线性表</li>
<li>二维数组可以看作是数据元素是定长线性表的线性表</li>
<li>数组一旦被定义，维数和维界都不变</li>
<li>除了初始化和销毁，数组只能存取元素、修改元素（不能叫插入和删除，这个应该是和线性表的区别）</li>
</ul></li>
</ul>
<h3 id="存储结构">存储结构</h3>
<ul>
<li>数组本身是逻辑结构，但是大部分计算机语言都提供数组数据类型</li>
<li>逻辑意义上的数组可以用计算机语言中的数组数据类型进行存储</li>
<li><span class="math inline">\(LOC(a_i)=LOC(a_0)+i\times L(0\leq
i&lt;n)\)</span>，<span class="math inline">\(L\)</span>是每个元素所占的存储单元个数</li>
<li>多维数组映射方法(假设m行n列)
<ul>
<li>行优先：<span class="math inline">\(LOC(a_{i,j})=LOC(a_{0,0})+[n\times(i)+j]\times
L\)</span></li>
<li>列优先：<span class="math inline">\(LOC(a_{i,j})=LOC(a_{0,0})+[m\times(j)+i]\times
L\)</span></li>
</ul></li>
</ul>
<h3 id="矩阵的压缩存储">矩阵的压缩存储</h3>
<ul>
<li>压缩存储：相同值元素只分配一个存储空间，零元素不分配空间，能节约存储</li>
<li>特殊矩阵
<ul>
<li>矩阵有很多相同的元素，或很多零元素，并且这些元素分布有一定规律。</li>
<li>常见的特殊矩阵：对称矩阵、上三角矩阵、下三角矩阵、对角矩阵、三对角矩阵</li>
</ul></li>
</ul>
<h3 id="对称矩阵">对称矩阵</h3>
<ul>
<li>只存放下三角部分，包括对角元素，把<span class="math inline">\(A[n][n]\)</span>用<span class="math inline">\(B[\frac{n^2+n}{2}]\)</span>压缩表示</li>
<li>对于<span class="math inline">\(A[i][j]\)</span>，<span class="math inline">\(i\geq j\)</span>，其前面有元素个数<span class="math inline">\(x=1+2+\cdots+i-1+j\)</span>（二维矩阵按行优先展开为一维数组，后同），故其对应于<span class="math inline">\(B[x]\)</span>。数组下标都是从0开始的。</li>
</ul>
<h3 id="三角矩阵">三角矩阵</h3>
<ul>
<li>下三角矩阵上三角区域元素为常数</li>
<li>上三角矩阵下三角区域元素为常数</li>
<li>注意在数学里，这个常数大都是0，但这里认为是某常数C</li>
<li>存储和对称矩阵类似，但要多一个位置存储该常数即可</li>
</ul>
<h3 id="三对角矩阵">三对角矩阵</h3>
<ul>
<li>又叫做带状矩阵，所有非零元素都集中在以主对角线为中心的3条对角线区域</li>
<li>同样可以按行优先方式展开到一维数组中</li>
</ul>
<h3 id="稀疏矩阵">稀疏矩阵</h3>
<ul>
<li>对于非零元素个数远少于矩阵元素个数的情况，矩阵为稀疏矩阵</li>
<li>采用三元组(行标，列标，值)的方式进行压缩</li>
<li>稀疏矩阵压缩后无法随机存取</li>
<li>稀疏矩阵的三元组可以用数组存储也可以用十字链表存储</li>
</ul>
<h4 id="十字链表">十字链表</h4>
<ul>
<li>每一行都有行头结点</li>
<li>每一列都有列头结点</li>
<li>数据结点除了三元组，还包括列后继指针，行后继指针</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第六章-图</title>
    <url>/2021/10/19/DataStructure-6/</url>
    <content><![CDATA[<h2 id="图的基本概念">图的基本概念</h2>
<h3 id="图的定义">图的定义</h3>
<ul>
<li>图G由顶点集V和边集E构成，记为G=(V,E)</li>
<li>V(G)表示G中的顶点的有限<strong>非空</strong>集，|V|为点数</li>
<li>E(G)表示G中的边的有限集，|E|为边数</li>
<li>图不可以没有顶点，不能是空图，但可以没有边</li>
</ul>
<h3 id="基本概念">基本概念</h3>
<ul>
<li>有向图：如果E是有向边（弧）的有限集合，则G是有向图，从v到w的弧是顶点的有序对&lt;v,w&gt;，v是弧尾，w是弧头（也称作v邻接到w）</li>
<li>无向图：如果E是无向边的有限集合，则G是无向图，边是顶点的无序对（v，w），w和v互为邻接点，边（v，w）依附于v和w两个点</li>
<li>简单图：没有重复边，没有顶点到自身的边，数据结构中只讨论简单图</li>
<li>完全图：任意两点之间都有一条边，一般是指无向图</li>
<li>有向完全图：任意两点之间都有一对方向相反的弧</li>
<li>子图：两个图G(V,E)和G'(V',E')，如果V'是V子集，E'是E子集，则G'是G子图</li>
<li>生成子图：V'=V的子图</li>
<li>点的连通：无向图两个顶点之间有路径则两个点是连通的</li>
<li>连通图：任意两点是连通的</li>
<li>连通分量：无向图（可以是<strong>非连通图</strong>）的极大连通子图（一个图的连通分量显然不一定唯一）</li>
<li>强连通：有向图两个顶点之间相互可达</li>
<li>强连通图：有向图任意两点之间强连通</li>
<li>强连通分量：有向图的极大强连通子图</li>
<li>生成树：<strong>连通图</strong>的生成树是包含图中全部顶点的极小连通子图</li>
<li>顶点的度、入度、出度：无向图顶点上依附的边数为度（记为TD）；有向图根据出边和入边进一步区分度为入度和出度（记为ID和OD）</li>
<li>无向图的顶点度之和是边数两倍</li>
<li>有向图顶点入度和 = 出度和 = 图边数 = 度数和的一半</li>
<li>带权图（网）：给图的边标上权值的图</li>
<li>稠密图、稀疏图：边数少的图为稀疏图，反之为稠密图。一般认为|E|&lt;|V|log|V|时为稀疏图</li>
<li>路径：顶点<span class="math inline">\(v_p\)</span>到<span class="math inline">\(v_q\)</span>的路径指的是顶点序列<span class="math inline">\(v_p、v_{i1}、\cdots、v_q\)</span>，路径上边个数是路径长度，首位顶点相同的路径叫做回路或者环。n个顶点的图，如果边数大于n-1，则一定有环</li>
<li>简单路径：顶点不重复的路径</li>
<li>简单回路：除了首位顶点外，其他顶点不重复的回路</li>
<li>距离：两个顶点的最短路径长度，如果不存在路径则距离为无穷</li>
<li>有向树：一个顶点的入度为0，其余顶点的入度为1的有向图</li>
</ul>
<h2 id="图的存储">图的存储</h2>
<h3 id="邻接矩阵">邻接矩阵</h3>
<ul>
<li>定义：用一维数组存储顶点，二维矩阵存储两点之间是否有边（或者存边的权值）</li>
<li>简单应用时可以直接用二维数组作为图的邻接矩阵，忽略顶点信息</li>
<li>如果不需要考虑边的权值，矩阵的元素就是1或0</li>
<li>无向图的邻接矩阵是对称矩阵，可以压缩存储</li>
<li>邻接矩阵的空间开销是<span class="math inline">\(O(|V|^2)\)</span></li>
<li>特点
<ul>
<li>无向图的邻接矩阵是对称的，适合压缩存储，只保存例如下三角矩阵</li>
<li>无向图第i行或第i列非零元素个数，刚好是顶点的度<span class="math inline">\(TD(v_i)\)</span></li>
<li>有向图第i行非零元素的个数，刚好是顶点的出度<span class="math inline">\(OD(v_i)\)</span>；第i列非零元素的个数，刚好是顶点的入度<span class="math inline">\(ID(v_i)\)</span></li>
<li>任意确定两点之间是否有边，但得到总边数开销大</li>
<li>稠密图适合用邻接矩阵</li>
<li>假设G的邻接矩阵是<span class="math inline">\(A\)</span>，<span class="math inline">\(B=A^n\)</span>，则<span class="math inline">\(B[i][j]\)</span>表示从<span class="math inline">\(i\)</span>顶点到<span class="math inline">\(j\)</span>顶点，长度为<span class="math inline">\(n\)</span>的路径个数</li>
</ul></li>
</ul>
<h3 id="邻接表">邻接表</h3>
<ul>
<li>对于稀疏图，邻接表更适合</li>
<li>图G中每个顶点建立一个单链表，第i个单链表中的结点表示依附于<span class="math inline">\(v_i\)</span>的边（对于有向图则是以<span class="math inline">\(v_i\)</span>为尾的弧），该单链表是顶点<span class="math inline">\(v_i\)</span>的边表（对于有向图则是出边表）。顶点信息和顶点边表头指针采用顺序存储，称为顶点表。</li>
<li>简单来说，邻接表中存在两种结点：顶点表结点（顶点信息、边表头指针）、边表结点（邻接点信息、指针域）</li>
<li>特点：
<ul>
<li>无向图空间开销O(|V|+2|E|)，有向图空间开销O(|V|+|E|)</li>
<li>适合稀疏图，比邻接矩阵节约了很多空间</li>
<li>邻接表找到顶点的所有边更快，但是确定两个点之间是否有边效率不如邻接矩阵</li>
<li>有向图的邻接表中，求顶点出度只需要计算该顶点的出边表中结点个数；但是求该顶点的入度需要遍历整个邻接表的所有出边表</li>
<li>邻接表的表示不唯一，和数据输入次序有关</li>
</ul></li>
</ul>
<h3 id="十字链表">十字链表</h3>
<ul>
<li>有向图的一种链式存储结构</li>
<li>每条弧一个弧结点，包含尾顶点域、头顶点域、相同弧头的下一弧（对应矩阵表示的同列的下方第一个非零弧）、相同弧尾的下一弧（对应矩阵表示的同行的右方第一个非零弧）、弧信息域</li>
<li>每个顶点一个顶点结点，包含顶点数据信息、以该顶点为弧头的第一个弧结点（该顶点所在列第一个非零弧）、以该顶点为弧尾的第一个弧结点（该顶点所在行第一个非零弧）</li>
<li>十字链表很容易得到以结点为头或尾的弧，所以容易求出度入度</li>
<li>表示不唯一，和信息输入顺序有关，但图是唯一的</li>
</ul>
<h3 id="邻接多重表">邻接多重表</h3>
<ul>
<li>无向图的一种链式存储结构</li>
<li>无向图邻接表，一条边有两个边结点</li>
<li>无向图邻接多重表，一条边只有一个边结点</li>
<li>邻接多重表中存在两种结点：顶点表结点（顶点信息、边表头指针）、边表结点（标志边是否被搜过的标志域，顶点i域，依附顶点i的下一条边，顶点j域，依附于顶点j的下一条边，边信息域）</li>
</ul>
<h2 id="图的遍历">图的遍历</h2>
<h3 id="bfs">BFS</h3>
<ul>
<li>借助队列，空间开销<span class="math inline">\(O(|V|)\)</span></li>
<li>邻接表存储方式，复杂度<span class="math inline">\(O(|E|+|V|)\)</span></li>
<li>邻接矩阵存储方式，复杂度<span class="math inline">\(O(V^2)\)</span></li>
<li>BFS算法可以解决单源非带权图最短路径问题</li>
<li>广度优先生成树：即广度优先遍历后得到的生成树</li>
<li>基于邻接表的遍历序列不唯一，基于邻接矩阵的遍历序列唯一</li>
</ul>
<h3 id="dfs">DFS</h3>
<ul>
<li>简洁的递归实现</li>
<li>递归本质上用到了栈，空间开销<span class="math inline">\(O(|V|)\)</span></li>
<li>邻接表存储方式，复杂度<span class="math inline">\(O(|E|+|V|)\)</span></li>
<li>邻接矩阵存储方式，复杂度<span class="math inline">\(O(V^2)\)</span></li>
<li>深度优先生成树：即深度优先遍历后得到的生成树，如果对非连通图调用则会生成森林</li>
<li>基于邻接表的遍历序列不唯一，基于邻接矩阵的遍历序列唯一</li>
</ul>
<h3 id="图的连通性判断">图的连通性判断</h3>
<ul>
<li>无向图是连通的，则从任一结点出发，遍历一遍可以访问到所有结点</li>
<li>无向图是非连通的，从任一结点出发，遍历一遍可以访问到该结点所在的连通分支上所有结点</li>
<li>使用for循环选取初始点进行遍历，防止一次无法遍历完所有点</li>
<li>无向图for循环次数即连通分支数</li>
</ul>
<h2 id="图的应用">图的应用</h2>
<h3 id="最小生成树">最小生成树</h3>
<ul>
<li>最小生成树不一定唯一</li>
<li>最小生成树权值和唯一</li>
<li>最小生成树边数为顶点数减1</li>
<li>最小生成树任意去掉一边后变不连通，任意增加一边形成回路</li>
</ul>
<h4 id="prim算法">Prim算法</h4>
<ul>
<li>任选一个点加入T</li>
<li>每次选择距离T最近的一个结点加入T</li>
<li>直到所有顶点都加入T</li>
<li>复杂度<span class="math inline">\(O(|V|^2)\)</span>，适合稠密图（事实上优先队列如果是基于数组，则是<span class="math inline">\(O(|V|^2+|E|)\)</span>，如果优先队列是基于堆，则是<span class="math inline">\(O((|V|+|E|)log\ |V|)\)</span>）</li>
</ul>
<h4 id="kruskal算法">Kruskal算法</h4>
<ul>
<li>初始化时T中所有顶点各自为一个连通分量</li>
<li>不断选择未访问过的边中权值最小的边（边用堆存储，以方便找最小边），如果该边两端不在同一个连通分量中（用到并查集），则此边加入T，否则舍弃该边。</li>
<li>直到所有顶点都在同一个连通分量中</li>
<li>复杂度<span class="math inline">\(O(|E|log
|E|)\)</span>，适合稀疏图</li>
</ul>
<h3 id="最短路径">最短路径</h3>
<p>这里的最短路径指的是带权长度最短路径 #### Dijkstra算法 +
解决单源最短路径问题 + 要求权值非负 + 根据源点到各个点边权初始化dist[] +
S表示已经确定最短路径的点集，起始只有源点 +
每次选dist中最小的dist[j]加入S，并更新<span class="math inline">\(dist[i]=min\{dist[i],dist[j]+e(i,j)\}\)</span> +
path[k]可以记录到第k个结点最短路径上k的前驱结点 + 最终所有点都加入S +
复杂度<span class="math inline">\(O(|V|^2)\)</span></p>
<h4 id="floyd算法">Floyd算法</h4>
<ul>
<li>解决所有顶点之间最短路径问题</li>
<li>权值可以为负，但不能有负边组成环</li>
<li>假设点为<span class="math inline">\(v_1,\cdots,v_n\)</span></li>
<li><span class="math inline">\(A^0[i][j]\)</span>表示<span class="math inline">\(v_i\)</span>结点到<span class="math inline">\(v_j\)</span>结点的边权，<span class="math inline">\(i,j=1,2,\cdots,n\)</span></li>
<li><span class="math inline">\(A^k[i][j]=\min\{A^{k-1}[i][j],A^{k-1}[i][k]+A^{k-1}[k][j]\}\)</span>，表示中间结点为<span class="math inline">\(v_1,\cdots,v_k\)</span>范围的最短路径</li>
<li>复杂度<span class="math inline">\(O(|V|^3)\)</span></li>
</ul>
<h3 id="有向无环图">有向无环图</h3>
<ul>
<li>不存在环的有向图，简称DAG</li>
<li>表达式可以用树结构表示</li>
<li>表达式总有公共子式的情况，用树表达会有重复的空间</li>
<li>使用有向无环图可以存储表达式，节约空间</li>
</ul>
<h3 id="拓扑排序">拓扑排序</h3>
<ul>
<li>AOV网：DAG图表示一个工程，<strong>顶点表示活动</strong>的网络，边表示活动进行的先后顺序限制</li>
<li>拓扑排序：DAG图顶点组成的序列，每个顶点恰出现一次，存在A到B的路径，则B排在A后面</li>
<li>删源点法
<ul>
<li>找没入度点删除</li>
<li>如果所有点都有入度且没删完，则无法拓扑排序，不是DAG图</li>
<li>否则删除的顺序就是拓扑排序顺序</li>
</ul></li>
<li>DFS法
<ul>
<li>从转置图的未访问过的结点开始，进行DFS，（可能进行多次，直到所有结点都访问过）</li>
<li>遍历完成结点和该结点的所有邻点后，将该点输出拓扑序列</li>
<li>如果DFS出现环，则说明不是DAG图，不能拓扑排序</li>
<li>如果不是转置图，则求出的是逆拓扑排序</li>
</ul></li>
</ul>
<h3 id="关键路径">关键路径</h3>
<ul>
<li>AOE网：DAG图表示一个工程，<strong>顶点表示事件，边表示活动</strong>，边权值表示活动需要的时间</li>
<li>AOE网性质：
<ul>
<li>顶点的所有入边活动都结束，则该顶点事件才能发生</li>
<li>顶点事件发生，该顶点出边活动才能开始</li>
<li>AOE网仅有一个源点，表示整个工程的开始事件</li>
<li>AOE网仅有一个汇点，表示整个工程的结束事件</li>
</ul></li>
<li>关键路径：从源点到汇点的最大路径长度，影响工程最短完成时间的因素</li>
<li>参量定义
<ul>
<li>事件<span class="math inline">\(v_k\)</span>最早发生时间<span class="math inline">\(ve(k)\)</span>
<ul>
<li>从前往后算</li>
<li><span class="math inline">\(ve(0)=0\)</span></li>
<li><span class="math inline">\(ve(k)=\max\{we(j)+e(j,k)\}\)</span>，k是j的后继</li>
</ul></li>
<li>事件<span class="math inline">\(v_k\)</span>最迟发生（使得工程完成不推迟）时间<span class="math inline">\(le(k)\)</span>
<ul>
<li>从后往前算</li>
<li><span class="math inline">\(le(\)</span>汇点<span class="math inline">\()=ve(\)</span>汇点<span class="math inline">\()\)</span></li>
<li><span class="math inline">\(le(k)=\min\{le(j)+weight(j,k)\}\)</span>，k是j的前驱</li>
</ul></li>
<li>活动<span class="math inline">\(a_i\)</span>最早开始时间<span class="math inline">\(e(i)\)</span>：弧尾事件最早发生时间</li>
<li>活动<span class="math inline">\(a_i\)</span>最晚开始事件<span class="math inline">\(l(i)\)</span>：弧头事件最晚发生时间-该活动时间</li>
<li>差额（活动可拖延时间）<span class="math inline">\(d\)</span>：活动的最迟开始时间-活动最早开始时间</li>
<li>不可拖延的活动（<span class="math inline">\(d=0\)</span>）是关键活动</li>
</ul></li>
<li>关键路径算法
<ul>
<li>从源点出发求ve</li>
<li>从汇点出发求vl</li>
<li>求e</li>
<li>求l</li>
<li>求可拖延时间d</li>
<li>所有d=0的活动构成关键路径</li>
</ul></li>
<li>注意点
<ul>
<li>关键路径所有活动都是关键活动，缩短关键活动可以缩减工期</li>
<li>缩短关键活动太多可能会使其变为非关键活动</li>
<li>关键路径不一定唯一</li>
<li>有多个关键路径的工程想缩短工期需要缩短在所有关键路径上的关键活动（比如桥）</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第八章-排序</title>
    <url>/2021/10/20/DataStructure-8/</url>
    <content><![CDATA[<h2 id="排序基本概念">排序基本概念</h2>
<ul>
<li>输入n个记录，根据记录的关键字大小，输出该序列的重排，使得关键字有序</li>
<li>稳定算法：关键字大小相等的两条记录，在输入和输出中的先后顺序不变</li>
<li>内部排序：排序期间元素全部存放在内存，大部分内部排序是基于比较来移动记录顺序</li>
<li>外部排序：排序期间元素无法全部同时存放在内存，需要不断地在内外存之间移动的排序</li>
</ul>
<h2 id="插入排序">插入排序</h2>
<h3 id="直接插入排序">直接插入排序</h3>
<p>算法步骤</p>
<ul>
<li>假设排序表<span class="math inline">\(L[1\cdots
n]\)</span>在排序过程中处于以下状态：有序序列<span class="math inline">\(L[1\cdots i-1],L[i],\)</span>无序序列<span class="math inline">\(L[i+1\cdots n]\)</span></li>
<li>备份<span class="math inline">\(L[i]\)</span></li>
<li>找到元素<span class="math inline">\(L[i]\)</span>在<span class="math inline">\(L[1\cdots i-1]\)</span>中的插入位置<span class="math inline">\(k\)</span></li>
<li>将<span class="math inline">\(L[k\cdots
i-1]\)</span>整体依次后移1位，本步骤和上一步可以同时进行，即边移边找</li>
<li>将备份的<span class="math inline">\(L[i]\)</span>放入<span class="math inline">\(L[k]\)</span></li>
</ul>
<p>算法性能</p>
<ul>
<li>常数个辅助单元，空间开销<span class="math inline">\(O(1)\)</span></li>
<li>时间开销，最好情况<span class="math inline">\(O(n)\)</span>，平均和最坏情况<span class="math inline">\(O(n^2)\)</span></li>
<li>稳定排序算法</li>
<li>适用于顺序存储或链式存储的线性表</li>
</ul>
<h3 id="折半插入排序">折半插入排序</h3>
<ul>
<li>对直接插入排序的优化：将比较和移动操作分离，先折半查找插入点，再统一进行移动</li>
<li>减少了比较元素的开销至<span class="math inline">\(O(log\
n)\)</span>，但最坏时间复杂度还是<span class="math inline">\(O(n^2)\)</span></li>
<li>稳定排序算法</li>
<li>适用于顺序存储的线性表</li>
</ul>
<h3 id="希尔排序">希尔排序</h3>
<p>算法步骤</p>
<ul>
<li>取小于<span class="math inline">\(n\)</span>的步长<span class="math inline">\(d_1\)</span>，距离间隔<span class="math inline">\(d_1\)</span>的记录看作在同一组，组内直接插入排序</li>
<li>继续选更小的步长，重复该过程</li>
<li>直到步长选为1</li>
<li>注：目前对于步长序列怎么选择最好还没有定论</li>
</ul>
<p>算法性能</p>
<ul>
<li>空间开销O(1)</li>
<li>时间开销分析比较困难，最坏情况是<span class="math inline">\(O(n^2)\)</span>；当n在特定范围，时间复杂度<span class="math inline">\(O(n^{1.3})\)</span>,</li>
<li>不是稳定排序算法</li>
<li>适合顺序存储线性表</li>
</ul>
<h2 id="交换排序">交换排序</h2>
<h3 id="冒泡排序">冒泡排序</h3>
<p>算法步骤</p>
<ul>
<li>从前往后或从后往前扫描，比较相邻元素，逆序则交换</li>
<li>第k轮扫描，可以把第k大的元素放到倒数第k个位置，或把第k小的元素放到第k个位置</li>
<li>最坏进行n-1轮扫描即可完成排序</li>
<li>注：可以进一步优化，即记录每轮最后一次发生交换的位置，该位置后面的都已经排好；如果没有发生交换则可以提前结束排序</li>
</ul>
<p>算法性能</p>
<ul>
<li>空间开销<span class="math inline">\(O(1)\)</span></li>
<li>最坏情况和平均情况时间开销都是<span class="math inline">\(O(n^2)\)</span>，最好情况可以优化到<span class="math inline">\(O(n)\)</span></li>
<li>稳定排序算法</li>
<li>不同于插入排序，冒泡排序的有序子序列一定是全局有序（小于或大于所有无序序列的元素）</li>
</ul>
<h3 id="快速排序">快速排序</h3>
<p>算法步骤</p>
<ul>
<li>选择一个基准pivot，例如第一个元素</li>
<li>将排序表划分为小于基准和大于等于基准两个部分，此时基准的位置是最终的位置</li>
<li>递归的对左右部分进行快排</li>
<li>若某部分只有一个元素，则该部分已经排序好</li>
</ul>
<p>划分函数</p>
<ul>
<li>双向法
<ul>
<li>例如基准为第一个元素，设置i和j两个指针，i指向基准，j指向最后的元素</li>
<li>先令j从后往前遍历，遇到比基准小的元素，则交换i和j元素</li>
<li>交换后令i从前往后遍历，遇到比基准大的元素，交换i和j元素</li>
<li>直到i和j相遇</li>
<li>事实上基准元素可以先进行备份，等确定最终位置再一次性放好</li>
</ul></li>
<li>单向法
<ul>
<li>例如基准为第一个元素，设置i指针指向基准，j指针指向i下一个元素</li>
<li>令j从i+1位置向后遍历，遇到比基准小的元素，则交换i+1位置和j位置元素，再交换i和i+1位置元素</li>
<li>直到j扫描完整个表</li>
</ul></li>
</ul>
<p>性能分析</p>
<ul>
<li>需要栈进行递归，平均空间开销<span class="math inline">\(O(log\
n)\)</span>，最坏情况<span class="math inline">\(O(n)\)</span></li>
<li>平均时间复杂度<span class="math inline">\(O(nlog\
n)\)</span>，最坏时间复杂度<span class="math inline">\(O(n^2)\)</span>，可以尽量随机的选基准元素，使得最坏情况基本不发生</li>
<li>不是稳定算法，无论是划分函数是双向法还是单向法，因为交换元素时可能会导致不稳定</li>
</ul>
<h2 id="选择排序">选择排序</h2>
<h3 id="简单选择排序">简单选择排序</h3>
<p>算法步骤</p>
<ul>
<li>n-1次循环</li>
<li>第i次循环从<span class="math inline">\(L[i\cdots
n]\)</span>中选出最小值和<span class="math inline">\(L[i]\)</span>交换</li>
<li>第i次循环也可以从<span class="math inline">\(L[1\cdots
n+1-i]\)</span>中选出最大值和<span class="math inline">\(L[n+1-i]\)</span>交换</li>
</ul>
<p>性能分析</p>
<ul>
<li>空间开销<span class="math inline">\(O(1)\)</span></li>
<li>最好、平均、最坏时间开销都是<span class="math inline">\(O(n^2)\)</span>，主要是比较的开销，移动的开销较小</li>
<li>默认数组实现不是稳定算法，比如<span class="math inline">\(5,6,5,2\)</span>，用<span class="math inline">\(2\)</span>替换左侧的<span class="math inline">\(5\)</span>，破坏了两个<span class="math inline">\(5\)</span>的顺序
<ul>
<li>用链表实现则是稳定的</li>
</ul></li>
</ul>
<h3 id="堆排序">堆排序</h3>
<p>堆结构</p>
<ul>
<li>将一维数组看作完全二叉树，任意结点的值是对应子树的最大值或最小值</li>
<li>前者叫最大堆，后者叫最小堆</li>
</ul>
<p>堆修复</p>
<ul>
<li>假设堆顶缺失，对于结构上的修复，可以用数组末尾的结尾补到堆顶</li>
<li>对于性质上的修复，以最大堆为例，从堆顶开始，跟左右子结点比较
<ul>
<li>如果比左右子结点大，则完成修复</li>
<li>反之，将堆顶和左右子结点较大者交换，并继续修复子结点对应的子堆</li>
</ul></li>
<li>修复的复杂度是<span class="math inline">\(O(log\ n)\)</span></li>
</ul>
<p>堆构建</p>
<ul>
<li>非递归法
<ul>
<li>从最后一个有孩子的结点开始进行堆修复</li>
<li>复杂度O(n)，可以直接求和计算</li>
</ul></li>
<li>递归法
<ul>
<li>先递归的将左右子树部分构建为堆</li>
<li>再对堆顶进行修复</li>
<li>复杂度O(n)，根据主定理算</li>
</ul></li>
</ul>
<p>堆排序步骤</p>
<ul>
<li>以最大堆<span class="math inline">\(H[1\cdots
n]\)</span>为例，堆顶<span class="math inline">\(H[1]\)</span>和堆末尾元素<span class="math inline">\(H[n]\)</span>交换</li>
<li>修复堆<span class="math inline">\(H[1\cdots n-1]\)</span></li>
<li>重复拿出堆顶，修复堆即可</li>
</ul>
<p>堆插入</p>
<ul>
<li>虽然堆排序用不到，这里补充一下堆结构的插入</li>
<li>思想是把插入元素放到末尾，再从底向上进行调整</li>
<li>开销是<span class="math inline">\(O(log\ n)\)</span></li>
</ul>
<p>堆排序性能</p>
<ul>
<li>空间开销<span class="math inline">\(O(1)\)</span></li>
<li>时间开销<span class="math inline">\(O(nlog\ n)\)</span></li>
<li>不是稳定排序算法</li>
</ul>
<h2 id="归并排序">归并排序</h2>
<ul>
<li>归并排序是基于Merge操作的</li>
<li>Merge操作把两个有序表合并，开销<span class="math inline">\(O(n)\)</span></li>
<li>归并排序先分治的排序两部分，再把两部分合并</li>
<li>空间复杂度<span class="math inline">\(O(n)\)</span></li>
<li>时间复杂度<span class="math inline">\(O(nlog\ n)\)</span></li>
<li>稳定排序算法</li>
<li>如果是k路归并，由主定理，容易知道时间开销还是<span class="math inline">\(O(nlog\ n)\)</span></li>
</ul>
<h2 id="基数排序">基数排序</h2>
<ul>
<li>一种特殊的不基于比较的排序方法，而是基于关键字各个位的大小</li>
<li>可以按最高位优先MSD，也可以最低位优先LSD，但后者更常用和方便</li>
<li>假设关键字是d位，r进制数，以LSD为例
<ul>
<li>需要<span class="math inline">\(q[0]\)</span>到<span class="math inline">\(q[r-1]\)</span>，<span class="math inline">\(r\)</span>个链队列进行分配</li>
<li>重复进行分配和收集</li>
<li>第i次分配，根据关键字的低位起第i位的值，将关键字分配给对应的链队列</li>
<li>第i次收集，把各个链队列从<span class="math inline">\(q[0]\)</span>到<span class="math inline">\(q[r-1]\)</span>串起来</li>
<li>第i次分配和收集完成后，关键字的低i位是有序的</li>
<li>进行d次分配和收集后，排序完成</li>
<li>空间复杂度<span class="math inline">\(O(r)\)</span>，即队头指针、队尾指针</li>
<li>每次的分配复杂度<span class="math inline">\(O(n)\)</span>,收集复杂度<span class="math inline">\(O(r)\)</span>,总的时间复杂度<span class="math inline">\(O(d(n+r))\)</span>，与序列初始输入状态无关</li>
<li>稳定的排序算法</li>
</ul></li>
</ul>
<h2 id="排序算法应用">排序算法应用</h2>
<ul>
<li>若n较小，可以采用直接插入排序或简单选择排序</li>
<li>若初始序列基本有序，适合采用直接插入排序或冒泡排序</li>
<li>n较大时可以采用<span class="math inline">\(O(nlog\
n)\)</span>的时间复杂度算法，如快速排序、堆排序、归并排序
<ul>
<li>快速排序是基于比较的内部排序中最好的方法，平均情况时间最短，但不是稳定排序</li>
<li>堆排序辅助空间少于快排，且最坏情况也是<span class="math inline">\(O(nlog\ n)\)</span>，但不是稳定排序</li>
<li>归并排序是稳定排序，但空间开销较大。此外，可以考虑在序列较小时先直接插入排序，再高层归并，这样改进后还是稳定的。</li>
</ul></li>
<li>基于比较的排序算法最坏时间复杂度下界是<span class="math inline">\(O(nlog\ n)\)</span>，可以用判定树证明</li>
<li>如果n很大，且关键字位数少、可以分解的情况适合用基数排序</li>
<li>如果记录信息量大不适合频繁移动，可以选择链表作为存储结构</li>
</ul>
<h2 id="外部排序">外部排序</h2>
<h3 id="基本概念">基本概念</h3>
<p>当对大文件进行排序时，因为文件太多，无法一次将整个文件放入内存，需要将待排序记录存储在外存，排序时再把数据一部分一部分调入内存排序，在排序过程中需要多次进行内存外存的交换，这种排序方法叫外部排序。</p>
<h3 id="外部排序的方法">外部排序的方法</h3>
<ul>
<li>主要考虑访问磁盘的次数，即IO次数</li>
<li>首先根据内存情况，将文件分成若干子文件，依次读入内存进行内部排序</li>
<li>排序好后的子文件写回外存，这些子文件称为归并串或者顺串</li>
<li>对这些归并串归并直到整个文件有序</li>
<li>内存分成三个缓冲区，两个输入缓冲区和一个输出缓冲区，输入缓冲区空则继续从磁盘的对应归并串读，输出缓冲区满则写到磁盘中保存</li>
</ul>
<p>举例说明</p>
<ul>
<li>2000个记录，假设在8次内排序后得到8个初始归并串，每个归并串250个记录，每个磁盘块125个记录</li>
<li>8个归并串，两两归并，需要3轮归并</li>
<li>每轮归并需要16次读和16次写</li>
<li>三轮归并以及最开始内部排序需要的磁盘读写，一共4个32次，即128次读写</li>
<li>若增加归并路数，比如变成4路归并，则只需要两轮归并，一共3个32次，即96次读写</li>
<li>可以看出，增加归并路数、减小初始归并串数都可以减少归并轮数，从而减少IO次数</li>
<li>记忆：单轮归并中，每个记录都是进内存一次，出内存一次</li>
</ul>
<h3 id="多路平衡归并和败者树">多路平衡归并和败者树</h3>
<ul>
<li>增加归并路数可以减少读写磁盘的次数，但是增加了内部归并时的开销</li>
<li>具体来说，r个初始段，归并轮数<span class="math inline">\(\lceil
log_k\ r\rceil\)</span>，每轮归并<span class="math inline">\(n\)</span>个元素，比较次数<span class="math inline">\((n-1)(k-1)\)</span>，总比较次数和<span class="math inline">\(\frac{k-1}{log\
k}\)</span>有关，随着k增大而增大</li>
<li>解决方法是败者树
<ul>
<li>一种完全二叉树</li>
<li>k个叶结点存放k个归并段当前参加比较的记录，内部结点用来保存失败者（较大者失败），胜利者继续向上比较，最终得到的胜利者就是当前选出的最小值</li>
<li>胜利者结点删除后，进来新的结点，只需要把新的结点到根的路径上的比较重进行一次即可更新败者树，因此可以认为每轮比较次数由<span class="math inline">\((n-1)(k-1)\)</span>优化到了<span class="math inline">\((n-1)\lceil log_2
k\rceil\)</span>，从而总的比较次数和<span class="math inline">\(k\)</span>无关</li>
<li>个人认为，用最小堆也可以起到差不多的效果</li>
</ul></li>
<li>多路平衡归并的k也不是越大越好，因为路数k增加，需要增加输入缓冲区的个数，这对内存空间有要求，如果内存不够了，只能减小缓冲区大小，这样同样会使得读写外存次数增加</li>
</ul>
<h3 id="置换-选择排序">置换-选择排序</h3>
<ul>
<li>减少初始归并串数可以减少读写磁盘次数</li>
<li>采用内部排序法得到的初始归并串，依赖于可用内存工作区的大小</li>
<li>置换选择算法初始归并串的步骤如下（FI为输入文件，W为可容纳w个记录的内存工作区，FO为输出文件）
<ul>
<li>从FI中读w个记录到W</li>
<li>选W中关键字最小的记录，记为X，并加入到FO</li>
<li>若FI不空，则取1个记录到W</li>
<li>选W中比X大的最小记录，记为X，并加入FO</li>
<li>重复前2步</li>
<li>如果W中选不出比X大的最小记录，且W不空，则FO中输出一个初始归并串的结束标记</li>
<li>从第2步开始继续，直至W为空</li>
</ul></li>
<li>置换选择算法中的取最小，可以使用败者树，也可以用最小堆</li>
</ul>
<h3 id="最佳归并树">最佳归并树</h3>
<ul>
<li>采用置换-选择排序得到的初始归并串，长度不一定相同，因此，平衡归并不一定是最佳的归并顺序，有IO次数更少的归并顺序</li>
<li>利用哈夫曼树，叶结点表示初始归并段，权重为归并串长度（记录数），则WPL带权路径长度就是总读记录数，总读写记录数为2WPL
<ul>
<li>前面平衡树的轮数就是层数，WPL就是记录数乘以轮数，就是总读记录数</li>
</ul></li>
<li>原理上就是希望记录少的初始归并串先归并，记录多的初始归并串后归并</li>
<li>哈夫曼树是严格的k叉树，如果初始归并段不足，则可以认为存在长度为0的虚初始段，参与归并</li>
<li>计算的方法是利用<span class="math inline">\(n_0+n_k=k\times
n_k+1\)</span>，则<span class="math inline">\(n_0=(k-1)\times
n_k+1\)</span>，由此只需要补充叶结点数为k-1的整数倍加1即可</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第七章-查找</title>
    <url>/2021/10/20/DataStructure-7/</url>
    <content><![CDATA[<h2 id="基本概念">基本概念</h2>
<ul>
<li>查找：在数据结构中寻找满足条件的元素的过程。查找可能成功或失败</li>
<li>查找表：用于查找的数据结构，支持插入，删除，查询元素，不支持插入删除的是静态查找表，否则是动态查找表</li>
<li>关键字：标识元素的数据项的值</li>
<li>平均查找长度ASL:给定每个元素的查找概率，计算出所有查找过程的平均关键字比较次数</li>
</ul>
<h2 id="顺序查找和折半查找">顺序查找和折半查找</h2>
<h3 id="顺序查找">顺序查找</h3>
<ul>
<li>一般线性表顺序查找：从一端开始，逐个搜索关键字是否满足条件</li>
<li>有序表顺序查找：因为有序，有些失败的情况不一定要扫完整个表</li>
<li>可以用顺序存储或链式存储</li>
<li>可以用二叉树表示查找过程，叶子结点表示失败的情况，方便计算ASL</li>
</ul>
<h3 id="折半查找">折半查找</h3>
<ul>
<li>适合有序的顺序存储表</li>
<li>每次和中间位置元素比较，若相等则查找成功，否则缩短一半的搜索范围</li>
<li>可以用二叉树表示查找过程，叶子结点表示失败的情况，方便计算ASL</li>
</ul>
<h3 id="分块查找">分块查找</h3>
<ul>
<li>又叫索引顺序查找</li>
<li>结合了顺序查找和分块查找的优点</li>
<li>查找表分成若干子块，块内无序，块间有序</li>
<li>需要索引表，记录每个块最大关键字和第一个元素地址</li>
<li>查找先顺序查找或折半查找，确定元素所在块，再在块内顺序查找。</li>
<li>平均查找长度 = 分块查找的平均查找长度 + 块内查找的平均查找长度</li>
</ul>
<h2 id="红黑树">红黑树</h2>
<h3 id="定义">定义</h3>
<ul>
<li>结点是红色或黑色二叉查找树</li>
<li>根结点和叶结点（是空结点可忽略）都是黑色的</li>
<li>红色结点不能连续</li>
<li>根到所有叶结点路径上黑色结点个数相同</li>
</ul>
<h3 id="平衡性">平衡性</h3>
<ul>
<li>叶子的普通深度不会超过2倍的其黑色深度</li>
<li>由黑色高度至少是<span class="math inline">\(\frac{h}{2}\)</span>，则<span class="math inline">\(n\geq 2^{\frac{h}{2}}-1\)</span></li>
<li>所有叶结点的深度值不会超过两倍的差距</li>
</ul>
<h3 id="插入">插入</h3>
<ul>
<li>插入结点z设置为红色</li>
<li>如果z是根结点，则z变成黑色，树黑高加1</li>
<li>如果z的父亲是黑色，则此时已经满足红黑树</li>
<li>如果z的父亲是红色（显然z必然有爷爷，从而必然有叔叔）
<ul>
<li>如果z的叔叔是黑色，根据z、z父亲、z爷爷的路径形状进行LL、LR、RR、RL旋转，同时调整z、z父亲、z爷爷的颜色，使得平衡后的子树树根为黑</li>
<li>如果z的叔叔是红色，则令z爷爷是红，z的父亲和叔叔变黑，此后把爷爷看作z，回到最开始步骤，继续向上层调整</li>
</ul></li>
</ul>
<h3 id="删除">删除</h3>
<ul>
<li>如果是非终端结点，则把后继值放入该结点，然后删除后继，注意此时只移动值，不改变颜色</li>
<li>如果是红色终端结点，或根结点，则直接删除</li>
<li>如果是黑色终端，且不是根结点（必然有父亲p，兄弟y，记m和n为y的孩子，且m靠近x的一侧），用NULL的双黑色（黑色计算两次）的叶结点x代替该删除结点，下面目标就是把双黑x变成单黑x
<ul>
<li>情况1：如果y为红色，此时p为黑，旋转y和p，并交换y和p的颜色，转情况2/3/4</li>
<li>情况2：如果y为黑色，m红，n黑，旋转m和y，并交换y和m的颜色，转情况3</li>
<li>情况3：如果y为黑色，n红，旋转y和p，交换y和p的颜色，x变单黑，n变黑，完成调整</li>
<li>情况4：如果y为黑色，m黑，n黑，则x变单黑，y变红
<ul>
<li>p如果是根（必然是黑），不用变色，调整完成，调整前后总的黑色深度减1</li>
<li>p如果是红色，则变为黑，调整完成。</li>
<li>p如果是黑色，且不是根结点，则把p看作x，继续向根方向循环处理，运行情况1-4。</li>
</ul></li>
</ul></li>
<li>记忆
<ul>
<li>插入：叔叔黑色自身LR；叔叔红色往下拉
<ul>
<li>自身LR指的是，自身、自身的父亲、自身的爷爷三个人LR旋转</li>
<li>LR后的子树根是黑色</li>
</ul></li>
<li>删除：兄弟红色远侄LR、近侄红色近侄孙LR、远侄红色则远侄LR、都不红色则上拉
<ul>
<li>结束只能是第三个或第四个情况</li>
<li>第三个情况的子树根颜色不变</li>
</ul></li>
</ul></li>
</ul>
<h2 id="b树和b树">B树和B+树</h2>
<h3 id="b树">B树</h3>
<h4 id="定义-1">定义</h4>
<ul>
<li>又叫做多路平衡查找树</li>
<li>B树结点孩子最大值是阶<span class="math inline">\(m\)</span></li>
<li>B树结点关键字个数是子树范围数减1</li>
<li>根若不是终端结点，根结点的子树数范围<span class="math inline">\([2,m]\)</span></li>
<li>除了根结点，其他结点的子树数范围<span class="math inline">\([\lceil\frac{m}{2}\rceil,m]\)</span></li>
<li>非叶结点包含：<span class="math inline">\(n,P_0,K_1,P_1,\cdots,K_n,P_n\)</span>
<ul>
<li><span class="math inline">\(n\)</span>是关键字个数</li>
<li><span class="math inline">\(K_i\)</span>是关键字，从左到右递增</li>
<li><span class="math inline">\(P_i\)</span>是关键字均小于<span class="math inline">\(K_{i+1}\)</span>，均大于<span class="math inline">\(K_{i}\)</span>的子树</li>
</ul></li>
<li>叶结点在最后一层，一般用空指针表示，代表查找失败的位置，<strong>叶结点数比树中总关键字数多1</strong></li>
</ul>
<h4 id="高度磁盘存取次数">高度（磁盘存取次数）</h4>
<ul>
<li>这里规定高度不包含叶结点，即根节点在第1层，叶结点在第h+1层</li>
<li>利用<strong>叶结点数是树中总关键字数加1</strong>，n+1最小是<span class="math inline">\(2{\lceil\frac{m}{2}\rceil}^{h-1}\)</span>，最大是<span class="math inline">\(m^h\)</span>，很容易求出给定关键字数情况下的B树高度的范围</li>
</ul>
<h4 id="查找">查找</h4>
<ul>
<li>在B树中找结点，需要从磁盘中读</li>
<li>结点内顺序或折半查找关键字</li>
<li>起始结点是根结点</li>
<li>结点内查找失败则继续根据指针信息读子树，直到查找到叶结点（空指针），则查找失败</li>
</ul>
<h4 id="插入-1">插入</h4>
<ul>
<li>定位：查找失败时定位到最底层的非叶结点的插入位置</li>
<li>插入
<ul>
<li>若插入后结点关键字个数小于等于m-1，可以直接插入</li>
<li>否则以结点中间关键字为分割位置，把结点分裂成两个结点，并把中间关键字放入父结点；若父节点关键字个数大于等于m，继续向上层分裂，直至传到根使得树高增1</li>
</ul></li>
</ul>
<h4 id="删除-1">删除</h4>
<ul>
<li>若删除的关键字不在最底层非叶结点（终端结点），则用该关键字前驱或后继代替，再删除前驱或后继</li>
<li>只需要考虑被删关键字在终端结点的情况
<ul>
<li>若结点关键字个数删除前大于等于<span class="math inline">\(\lceil\frac{m}{2}\rceil\)</span>，则直接删除</li>
<li>兄弟够借
<ul>
<li>即结点关键字个数删除前等于<span class="math inline">\(\lceil\frac{m}{2}\rceil-1\)</span>，邻近的兄弟结点关键字个数大于等于<span class="math inline">\(\lceil\frac{m}{2}\rceil\)</span></li>
<li>则可以把兄弟结点关键字给父结点，父结点关键字给删除结点</li>
</ul></li>
<li>兄弟不够借，即结点关键字个数删除前等于<span class="math inline">\(\lceil\frac{m}{2}\rceil-1\)</span>，左右兄弟结点关键字个数等于<span class="math inline">\(\lceil\frac{m}{2}\rceil-1\)</span>
<ul>
<li>则结点删除关键字后，把该结点、左或右兄弟、该兄弟和删除结点在父结点中对应的关键字，合并到一个结点中</li>
<li>显然新结点关键字数为<span class="math inline">\(2\lceil\frac{m}{2}\rceil-2\leq
m-1\)</span>，满足B树定义。</li>
<li>如果父结点关键字的减少使得父结点不满足定义，则继续向上处理。</li>
<li>如果处理到了父结点是根结点，则根结点删除，合并结点称为新的根结点</li>
</ul></li>
</ul></li>
<li>记忆
<ul>
<li>插入：分裂，中间给父，迭代</li>
<li>删除：兄弟够借，兄弟给父，父给我；兄弟不够借，兄弟和我和中间合并，父亲继续迭代</li>
</ul></li>
</ul>
<h3 id="b树-1">B+树</h3>
<ul>
<li>应数据库所需出现的B树的变形</li>
<li>定义：
<ul>
<li>m阶B+树的一个结点最多有m个孩子</li>
<li>非叶根结点子树数至少<span class="math inline">\(2\)</span></li>
<li>非叶其他结点子树数至少<span class="math inline">\(\lceil\frac{m}{2}\rceil\)</span></li>
<li>结点关键字数等于子树数</li>
<li>叶结点包含所有关键字和相应的记录指针，叶子结点之间按大小顺序链接排列</li>
<li>分支结点的关键字指对应子树中最大关键字，分支结点包含指向该子树的指针</li>
</ul></li>
<li>对比B树
<ul>
<li>B+树结点关键字个数和子树相同，B树结点关键字比子树少1</li>
<li>m阶B+树结点子树个数和m阶B树结点子树个数范围相同</li>
<li>B+树的叶结点包含信息，非叶结点仅索引作用，无存储信息。B树的叶结点为空，对应查找失败。</li>
<li>B+树的叶结点会重复出现分支结点的关键字，B树关键字不会重复</li>
<li>B+树的多路查找一定是查找到叶结点为止，每次查找都是从根到叶的路径。B树的叶结点为空，且查找不一定到最底层非叶结点（终端结点）</li>
</ul></li>
<li>B+树有两个头指针
<ul>
<li>一个指向根结点，以多路查找</li>
<li>一个指向关键字最小的叶结点，以顺序查找</li>
</ul></li>
</ul>
<h2 id="散列表">散列表</h2>
<h3 id="基本概念-1">基本概念</h3>
<ul>
<li>散列函数：把关键字映射为地址的函数 Hash(key)=address</li>
<li>冲突：把不同的关键字映射到同一个地址，这些关键字叫同义词。冲突不可避免，但好的散列函数能减少冲突</li>
<li>散列表：根据关键字直接访问的数据结构</li>
<li>理想情况散列表查找时间开销是O(1)</li>
</ul>
<h3 id="散列函数构造方法">散列函数构造方法</h3>
<ul>
<li>定义域包含所有关键字，值域依赖于散列表大小和地址范围</li>
<li>散列函数算出的地址最好能等概率均匀的分布在整个地址空间中，减少冲突</li>
<li>散列函数尽量简单，能快速算出</li>
</ul>
<h4 id="直接定址法">直接定址法</h4>
<ul>
<li><span class="math inline">\(H(key)=a\times key+b\)</span>，<span class="math inline">\(a,b\)</span>是常数</li>
<li>即直接取关键字的某线性函数</li>
<li>没有冲突，计算简单</li>
<li>适合关键字分布基本连续，否则空位较多造成存储浪费</li>
</ul>
<h4 id="除留余数法">除留余数法</h4>
<ul>
<li><span class="math inline">\(H(key)=key\ mod\ p\)</span>，<span class="math inline">\(p\)</span>是不大于散列表长且最接近或等于的质数</li>
<li>简单常用的方法，关键是选好<span class="math inline">\(p\)</span>，使得关键字均匀映射到散列空间，减小冲突</li>
</ul>
<h4 id="数字分析法">数字分析法</h4>
<ul>
<li>设关键字是r进制数</li>
<li>关键字在各个位不一定分布都均匀</li>
<li>选取分布均匀的若干位作为散列地址</li>
<li>适合已知关键字集合，如果更换了关键字，则需要重新构造新散列函数</li>
</ul>
<h4 id="平方取中法">平方取中法</h4>
<ul>
<li>取关键字平方的中间几位作为散列地址</li>
<li>散列地址和关键字每个位都有关系，分布比较均匀，适合关键字每位取值都不均匀或者均小于散列地址所需位数的情况</li>
</ul>
<h3 id="处理冲突">处理冲突</h3>
<h4 id="开放地址法">开放地址法</h4>
<ul>
<li>即开地址法，Open-Hash</li>
<li><span class="math inline">\(H_i=(H(key)+d_i)\ mod\
m,i=0,1,\cdots,k(k\leq m-1)\)</span></li>
<li><span class="math inline">\(d_i\)</span>为增量序列，一般<span class="math inline">\(d_0=0\)</span></li>
<li>线性探查法
<ul>
<li><span class="math inline">\(d_i=0,1,2,\cdots,k\)</span>，且<span class="math inline">\(k\leq m-1\)</span></li>
<li>容易造成堆积</li>
</ul></li>
<li>平方探查法
<ul>
<li><span class="math inline">\(d_i=0^2,1^2,-1^2,2^2,-2^2,\cdots,k^2,-k^2\)</span>，<span class="math inline">\(k\leq \frac{m}{2}\)</span></li>
<li><span class="math inline">\(m\)</span>必须是<span class="math inline">\(4k+3\)</span>形式的素数</li>
<li>又叫二次探查法，可以避免堆积</li>
<li>缺点是不能探测到散列表所有单元，但至少能探测一半单元</li>
</ul></li>
<li>再散列法
<ul>
<li><span class="math inline">\(d_i=i\times Hash_2(key)\)</span></li>
<li>需要用到第二个哈希函数来解决冲突，又叫双重哈希法</li>
<li>最多m-1次再探测，都失败后回到<span class="math inline">\(H_0\)</span>位置</li>
</ul></li>
<li>伪随机序列法：<span class="math inline">\(d_i\)</span>为伪随机数序列</li>
<li>注：开放地址法不能随便删除元素，可以增加标记位进行逻辑删除，定期维护散列表进行物理删除</li>
</ul>
<h4 id="拉链法">拉链法</h4>
<ul>
<li>即闭地址法，Closed-Hash</li>
<li>把同义词存储在一个线性链表里</li>
<li>线性链表由散列地址唯一标识</li>
</ul>
<h3 id="散列查找和性能分析">散列查找和性能分析</h3>
<ul>
<li>散列查找和散列表构造的步骤相同</li>
<li>平均查找长度ASL衡量查找效率</li>
<li>同一组关键词和散列函数，冲突处理方法不同，开哈希闭哈希选择不同，ASL一般不一样</li>
<li>散列表的查找效率取决于
<ul>
<li>散列函数</li>
<li>冲突处理方法</li>
<li>装填因子
<ul>
<li>又叫负载因子</li>
<li>描述表满的程度，表越满，冲突发生的可能性越大</li>
<li><span class="math inline">\(\alpha=\frac{n}{m}\)</span>，<span class="math inline">\(n\)</span>为表中记录数，<span class="math inline">\(m\)</span>为散列表长度</li>
</ul></li>
</ul></li>
</ul>
<h2 id="补充说明">补充说明</h2>
<ul>
<li>查找成功的平均查找长度为<span class="math inline">\(\sum
p_ic_i\)</span></li>
<li>查找失败的平均查找长度为<span class="math inline">\(\sum
q_jc_j\)</span></li>
<li>这里一般是认为<span class="math inline">\(\sum p_i=1\)</span>，<span class="math inline">\(\sum q_j=1\)</span></li>
<li>如果综合考虑，即认为<span class="math inline">\(\sum p_i+\sum
q_j=1\)</span>也是一种理解，具体要根据题意分析</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【阅读笔记】 Detecting Out-of-Distribution Inputs in Deep Neural Networks Using an Early-Layer Output</title>
    <url>/2021/02/04/Detecting-OoD-Using-Early-layers/</url>
    <content><![CDATA[<h2 id="abstract">Abstract</h2>
<p>作者在本文提出了一种新的OoD检测方法，不需要OoD的训练样本。检测器是一个单分类器，用原始网络的前几层的输出结果训练的。测试时使用的高维和低维的测试集，和其他先进的(state
of art)方法比较，有出色的结果。</p>
<h2 id="introduction">Introduction</h2>
<p>DNN在现代软工中是不可或缺的部分，如自动驾驶、物联网、医疗等领域。深度神经网络在<strong>分类</strong>这件人类经常接触的问题上性能远超于人。</p>
<p>DNN在I.I.D假设下工作良好，但遇到OoD样本时往往过分自信（给出偏高的分类置信度），这阻碍了在安全要求很高的系统中DNN的可采用性。例如，训练集中没有自行车，但汽车的分类器会错分类骑自行车的人。因此分类器需要加强分辨ID和OoD的机制。以往的论文中也提到了类似地检测不同域的样本的方法，例如outlier
and novelty detection。</p>
<p>作者接着介绍了常见的一些OoD检测方法。首先是Hendrycks和Gimpel提出的基于max-softmax的baseline。这个方法引入了阈值去辨别OoD(max-softmax低于阈值就认为是OoD)。这个方法对深度模型没有任何假设且没有使用OoD的数据进行训练。它可直接对训练好的模型使用，但是它的性能不是特别令人满意。其他的方法性能比max-softmax好，但它们有的限制了深度模型的结构；有的给定了深度特征的分布假设；有的不能应用于已经训练好的模型；有的需要OoD的训练样本去提高性能...在以上背景下，作者认为，没有上述的种种限制并且比max-softmax的性能更好依然是一个挑战。在本篇文章中，作者致力于提出一种检测手段，不需要重新训练网络，也不限制网络的结构。</p>
<p>现有的一些方法本质上都依赖于深度神经网络的倒数第二层。这一层的特征对于ID自身的分类非常重要,但是用于OoD检测还是比较困难,作者用图片可视化的方法证明了区分的困难性。随后作者提出了本文的方法：不基于softmax层，性能不亚于现有的先进方法，且不需要OoD数据来训练模型也不需要重训练网络。作者主要的观点是：<strong>假设存在一个潜在的空间可以将ID和OoD区分开，并且变换到这个空间的函数可以由网络的某一层良好估计。</strong>这个观点使得基于此空间特征的检测器是可以学习的。在此指导下，作者训练了第二个模型作为检测器，应用于低纬度和高维度的数据集并将其和baseline、先进的方法比较，结果在多个指标上有显著改进。</p>
<p>文章接下来几个部分，分别介绍了相关工作、作者的方法（如何检测OoD以及如何找到合适的潜在空间）、实验结果、实验结论和未来工作的建议方向。</p>
<h2 id="related-work">Related work</h2>
<p>首先是max-softmax的这个baseline，简单易用但是性能不理想。</p>
<p>然后是在此基础上改进的ODIN的方法。加入了两个额外的组成：temperature
scaling和input preprocessing。temperature是用来校准softmax的值，input
preprocessing用来提高ID的maximum的值。这个方法需要OoD的样本。但是实际操作时无法获得全面的OoD样本，并且Input
preprocessing也会引入额外的训练时间开销（两次正向和一次反向传播）。</p>
<p>在ODIN的基础上进行改进，比如Lee的方法。使得深度网络分类器输出对于OoD是接近均匀分布的。这个主要的思想是训练一个分类器和一个生成器，生成器在数据流行的边界产生OoD样本，分类器则用一个特殊设计的损失函数训练：对于生成器生成的OoD更容易得到均匀分布的结果。这个方法需要昂贵的重训练开销，并且需要假设OoD的数据遍布整个数据流行的边界，但这对于高维数据是很难的。</p>
<p>接着作者介绍了其他人的方法。比如，DeVries and
Taylor的方法：利用不确定性来检测OoD，即训练一个分类器输出uncertainty这个指标。Shalev,
Adi, and
Keshet&amp;Vyas的方法：使用集成计算置信度估计。这些方法和Lee的方法一样不能直接用在训练好的原网络模型。</p>
<p>MC-dropout的方法也可以度量模型的不确定性，依靠多重推理计算不确定性可能并不实用。而且只能被用于有dropout层的网络模型中。此后，Geifman
and
EL-Yaniv使用这个方法刻画风险-覆盖曲线来对已经训练好的模型检测OoD,并且指出性能和max-softmax相似。基于不确定性的方法非常适合检测模型训练的类的边界上的混乱输入。对于非常远离ID的数据，uncertainty-based的方法的性能不好。</p>
<p>使用生成式的模型也是另一个检测OoD输入的重要方法。这些方法要么依赖于重建误差(reconstruction
error)，要么依赖于潜在表征的密度估计，或者是依赖于两者的结合。这些方法有一些不足，比如对于某些OoD数据会给出较高的ID可能性。并且，生成式模型很难在高维度的数据上进行拓展应用。</p>
<p>Lee等人此后提出了一种方法，基于高斯判别分析得到每个类的条件高斯分布。这产生了一个基于马氏距离的置信度来检测OoD输入。他们提出了两种方法:a):logits层前一层特征的马氏距离;b):各层马氏距离的集成模型。前者和他们之前的ODIN的方法性能差不多，后者用OoD数据对每个OoD数据集训练了一个回归模型。事实上，几个OoD的数据集就需要训练几个回归模型，这是他们第二个方法的主要的局限性。Lee还使用了对抗样本来训练回归模型，这导致检测性能的降低。此外，a和b方法中，每个类的特征的分布必须假设满足多元高斯分布，但这个假设是没有理论保证的。</p>
<p>接下来，作者准备介绍本文的方法，和Lee的方法有些类似：都用到了深度模型学习到的特征，但有几个重要的地方是不同的：
+ 没有用到logits层的特征，因为此前已经说明这一层不适合用来区分OoD和ID；
+ 不需要OoD的样本和对抗样本，但测试对所有的OoD数据集都适用; +
本方法找到合适的特征空间来区分OoD和ID,因此不需要依赖集成。 +
不需要假设特征满足多元高斯分布</p>
<h2 id="proposed-solution">Proposed solution</h2>
<p>这个部分，作者介绍了他们方法的基本元素，包括对于一个具体的潜在空间检测的性能如何，如何发现这样的潜在空间、如何用输入预处理的方式加强结果等。</p>
<h3 id="ood-detection">OoD detection</h3>
<p>先给定如下假设： + <span class="math inline">\(Q:R^n \to
[0,1]^c\)</span> : 深度网络 + <span class="math inline">\(x \in
R^n\)</span> : 输入 + <span class="math inline">\(c\)</span> :
类别的数量 + <span class="math inline">\(Q_i\)</span> :
网络对第i个类的概率输出 + <span class="math inline">\(X =
\{x_1,...,x_m\}\)</span> : 训练集 + <span class="math inline">\(L\)</span> : 网络层数 + <span class="math inline">\(q^l\)</span> : 第<span class="math inline">\(l\)</span>层的输出(<span class="math inline">\(q^0
= x\)</span>)，即前<span class="math inline">\(l\)</span>层非线性变换到隐空间的结果。每一层都提取了关于输入的特征，例如最后一层的特征对区分ID内部的分类很重要。
+ 存在一个适合区分ID和OoD的隐空间，由某层特征输出表示的 :<em>optimal OoD
discernment layer（OODL）</em> + <span class="math inline">\(l_o\)</span> : OODL层 + <span class="math inline">\(Q^{l_o}\)</span> : 第<span class="math inline">\(l_o\)</span>层的概率输出 + <span class="math inline">\(S^{l_o}\)</span> : 基于特征<span class="math inline">\(Q^{l_o}\)</span>训练的区分ID和OoD的分类器。</p>
<p>为了不用OoD数据进行训练，分类设定为单分类问题(One Class
Classification)。现有的许多单分类方法都可以使用，本文中作者使用的是One-class
SVM。OoD检测机制是 <span class="math display">\[\begin{equation}
O_{l_o}(x;\delta)=
\begin{cases}
0&amp; \delta \geq S^{l_o}(q^{l_o}(x)) \\
1&amp; \text{otherwise}
\end{cases}
\end{equation}\]</span> 其中<span class="math inline">\(O_{l_o}\)</span>是检测函数，基于OODL <span class="math inline">\(l_o\)</span>的特征和阈值<span class="math inline">\(\delta\)</span>。作者提到，如果<span class="math inline">\(l_o\)</span>是卷积层，那么<span class="math inline">\(q^{l_o}\)</span>会非常高维，不利用OSVM的效果，因此计算每个频道的均值用于降维。即假设<span class="math inline">\(f^{l_o} \in R^{w\times h\times
d}\)</span>是卷积层<span class="math inline">\(l_o\)</span>的特征，<span class="math inline">\(w\)</span>, <span class="math inline">\(h\)</span>, <span class="math inline">\(d\)</span>是宽、高、深度。<span class="math inline">\(f^{l_o}_{ijk}\)</span>是特征<span class="math inline">\(f^{l_o}\)</span>的第(<span class="math inline">\(i\)</span>, <span class="math inline">\(j\)</span>, <span class="math inline">\(k\)</span>)个元素，那么降维后的特征<span class="math inline">\(q^{l_o}=(q^{l_o}_k \in R^d)\)</span>由下式得到：
<span class="math display">\[\begin{equation}
q^{l_o}_k=\frac{1}{w\times h}\sum_{i=1}^{w}\sum_{j=1}^{h}|f^{l_o}_{ijk}|
\end{equation}\]</span>
作者提到，传统OCC方法例如OCSVM在高维数据性能不佳，在本文的方法中，提到了OODL，允许方法在高维数据上良好工作。另一个好处是可以利用训练好的原网络模型，这比抓取ID数据重训练一个OCC模型更有效。（注：个人理解是原神经网络起到一个特征提取的作用，当然比用原始ID更有效）。作者提到这是以往没有用过的OoD检测方法。</p>
<h3 id="finding-optimal-ood-discernment-layer-oodl">Finding optimal OoD
discernment layer (OODL)</h3>
<p>首先，需要找到网络<span class="math inline">\(Q\)</span>的OODL。作者提到，需要度量基于公式1的检测的误差，误差最小的层就是OODL。下面是具体的算法。
<img src="/2021/02/04/Detecting-OoD-Using-Early-layers/algo1.jpg" class title="this is algo1">
使用OoD数据集去寻找OODL会有一个问题，那就是这个层偏向于区分所选的OoD数据集所具有的特征。接着，作者用实验表明，对于不同的OoD
Dataset，在同一个网络和ID的情况下，最后选取的OODL基本一致；同时，网络模型的选取和ID的选取对OODL的结果影响比较大。
实验配置和结果的情况为: + 用CIFAR-10 作为ID dataset + 用ResNet
model作为网络模型 + 横坐标是层，纵坐标是检测误差 + 验证的OoD
dataset分别为TinyImageNet、LSUN、ISUN、SVHN +
结果是，四个OODL都选在第13层（这一层的检测误差最小）。</p>
<p>作者认为OODL往往选在较低的层，因为高层特征往往是分类的特征，和ID内的分类有关；而较低层特征是整体大概的特征，用来表征ID分布本身。那么到目前为止，实验表明了用倒数第二层有利于做ID内的分类，而OODL有利于做OoD的检测。</p>
<h3 id="input-preprocessing">Input preprocessing</h3>
<p>这是源自ODIN的方法，是用来增大max-softmax类别概率的。在本文中，作者用这个方法来增强ID的特征，这样OSVM分类器就更容易检测出ID的输入。作者还提到，即使不用输入预处理的方式，本文的方法也比其他很多方法性能要好。具体的Input
proprocessing的方法是：对于测试阶段的一个输入数据<span class="math inline">\(x\)</span>，用如下公式计算<span class="math inline">\(x&#39;\)</span> <span class="math display">\[\begin{equation}
x&#39;=x-\epsilon\cdot sign(-\nabla_{x}log(\max_{i}Q_{i}(x)))
\end{equation}\]</span> 其中<span class="math inline">\(\epsilon\)</span>是一个微扰程度，而微扰的大小由梯度(max-softmax关于x)反向传播计算。</p>
<h2 id="experiments">Experiments</h2>
<p>作者对几个ID和OoD
dataset在不同的网络模型上运用了本文的方法。作者把性能和max-softmax,ODIN,MD进行了比较。正如前文所讨论的，本文的方法关注的是不用OoD数据参与分类器的训练，然而，为了遵守文献中的传统，作者还是使用了input
preprocessing(需要访问OoD数据)的方法作为一个补充选项。和基于不确定度的方法的对比在附加材料中提到。作者的方法是开源可复现的。</p>
<h3 id="id-datasets-and-models">ID datasets and models</h3>
<ul>
<li>ID datasets包括：MNIST, CIFAR-10, CIFAR-100</li>
<li>MNIST的模型：两个卷积层两个全连接层的CNN，测试集精确度99.22%</li>
<li>CIFAR-10:的模型： VGG-16(by Simonyan and Zisserman 2014)和ResNet(by
He et al. 2015)。测试集精度为93.56%和92.01%</li>
<li>CIFAR-100的模型：同CIFAR-10，测试集精度为70.48%和69.17%</li>
</ul>
<h3 id="ood-datasets">OoD datasets</h3>
<p>作者用OoD的数据集进行测试评估，并保持ID和OoD的相同的测试规模，具体的数据集如下:
+ Fashion-MNIST + Omniglot + TinyImageNet + LSUN + iSUN + SVHN +
Gaussian noise + Uniform noise</p>
<h3 id="evaluation-metrics">Evaluation metrics</h3>
<p>本节对方法评估的指标进行说明。 + FPR at 95% TPR：FPR是<span class="math inline">\(\frac{FP}{FP+TN}\)</span>，TPR是<span class="math inline">\(\frac{TP}{TP+FN}\)</span>。ID是正例。 + Detection
error at 95% TPR：假设测试集正反例同规模，则该指标等价于<span class="math inline">\(0.5\times(1-TPR)+0.5\times(FPR)\)</span> +
AUROC：Area Under the Receiver Operating Characteristic
curve，即正例相比于反例获得更高detecton score的可能性。 + AUPR：Area
Under the Precision-Recall curve, 即查准率和查全率的曲线</p>
<h3 id="osvm-and-hyper-parameters">OSVM and hyper parameters</h3>
<ul>
<li>使用 <span class="math inline">\(rbf\)</span> 核作为
kernel，比其他核效果好；</li>
<li>training error <span class="math inline">\(nu =
0.001\)</span>；</li>
<li>temperature
scale的T设置为1000，因为根据以为的paper，这是最理想的数值；</li>
<li>扰动级别<span class="math inline">\(\epsilon\)</span>由FPR at 95%
TPR来优化，随机使用20%的OoD datasets；</li>
<li>F-MNIST和TinyImageNet数据集用来寻找OODLs。每个ID和相应的模型都确定一个OODL；</li>
<li>用CIFAR-10和CIFAR-100训练的VGG-16模型的OODLs分别为第二个卷积层和第一个max-polling层；</li>
<li>用CIFAR-10和CIFAR-100训练的ResNet模型的OODLs分别为第13层和第9层residual
layers；</li>
<li>更多的参数细节在补充材料中...</li>
</ul>
<h3 id="detection-results">Detection results</h3>
<p>1.对于MNIST&amp;CUSTOM-CNN，结果如下(<span class="math inline">\(\uparrow\)</span> 表示值高性能好，<span class="math inline">\(\downarrow\)</span> 表示值低性能好):
<img src="/2021/02/04/Detecting-OoD-Using-Early-layers/performance_compared1.jpg" class title="this is performance_compared"></p>
<p>可以发现，作者的方法在各个指标性能都能胜出。</p>
<p>2.对于CIFAR-10 and CIFAR-100 &amp; 使用输入预处理，结果如下：
<img src="/2021/02/04/Detecting-OoD-Using-Early-layers/performance_compared2.jpg" class title="this is performance_compared"></p>
<p>本文方法的性能在两个数据集上都胜出，同时，作者的方法有能力完全的检测出不同模型下的高维和低维的噪声。</p>
<p>3.对于作者的方法，不使用输入预处理和其他使用输入预处理的方法比较，结果如下图：
<img src="/2021/02/04/Detecting-OoD-Using-Early-layers/performance_compared3.jpg" class title="this is performance_compared"> 可以看到除了TinyImageNet for
CIFAR-100,本文的方法性能都胜出。作者的方法有明显更优秀的AUROC，但detection
error 和FPR at 95%
TPR仅仅比ODIN的方法略好一点。有趣的是，MD的方法有时候比max-softmax更差。</p>
<h2 id="conclusion">Conclusion</h2>
<p>检测DNN中的OoD
inputs在安全相关的领域非常重要，比如自动驾驶和医疗领域。大部分OoD检测的方法都是基于DNN的倒数第二层提取的特征，这样的层用来区别ID的分类比较适合。与这些方法相反，本文提出的依赖于一个关键的思想，那就是寻找最适合的中间较低层作为OODL，来提供了一个容易分离ID和OoD的隐藏空间。结果指导我们训练一个单分类器检测OoD输入，不需要OoD的样本参与训练。当然，如果允许使用OoD的样本，本文的方法可以补充拓展为使用input
preprocessing的改进版本。作者用几个低维和高维的数据集在不同的深度网络模型上评估了本文的方法。结果表明对于baseline和state-of-the-art的一些方法，在很多指标上都有明显进步。作者提出，他们未来的工作主要是使用一个专用的损失函数去改进OODL层提取的特征，以便更好地进行OoD检测和ID的类别的划分。</p>
]]></content>
      <categories>
        <category>OoD Detection</category>
      </categories>
      <tags>
        <tag>Reading Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>【阅读笔记】 Generalied ODIN:Detecting Out-of-distribution Image without Learning from Out-of-distribution Data</title>
    <url>/2021/04/04/Generalized-ODIN/</url>
    <content><![CDATA[<h2 id="abstract">Abstract</h2>
<p>对于和训练集同分布的数据，深度神经网络已经获得了惊人的性能，但对于其他数据集性能会明显变差。因此，检测一个样本是不是OoD对于能拒绝或警示这种样本的系统是重要的。包含
一些小数据集的OoD
benchmarks下的工作在近期已经取得了巨大的进展。然而，这些方法很多都需要神经网络训练、调参的时候同时有in-distribution和out-of-distribution的数据。后者是难以先验定义的，不同的OoD数据会产生不同的学习效果。本文的工作基于一个流行的方法：ODIN。这个方法提出两个重要的策略，不需要OoD的数据，同时改进了OoD的检测性能。本文具体的提出了<strong>分解置信度</strong>的方法以及<strong>改进input
preprocessing</strong>的方法。本文展示了这两者都得能显著提高检测OoD的性能。并且，作者在更大规模的图像数据集上进行了分析，表明数据的分布迁移有两种：语义迁移和非语义迁移。这两者会让问题的难度变得非常不同，这提供了一个关于ODIN-like的策略何时能有效的分析。</p>
<h2 id="introduction">Introduction</h2>
<p>先进的机器学习模型，具体来说是深度神经网络，通常在静态封闭世界假设下设计的。这些模型需要引入测试集和训练集独立同分布的假设。在真实世界，数据分布会以复杂和动态的方式进行迁移。更坏的是，新概念（如新的分类对象）可能在任何时刻输入到模型中。这样的类内的迁移或者是新概念的数据都会导致灾难性的失败，因为模型依然是基于封闭世界假设来预测的。这些失效经常是无声的，模型不会输出明显的错误。</p>
<p>以上的问题已经被规范为一个检测问题，即判断一个输入数据是不是in-distribution的数据，或者是out-of-distribution。这个问题已经被研究了很多年，也以各种观点被讨论了，例如rejection,
anomaly detection, open set recognition, uncertainty
estimation。最近几年，一个流行的基于神经网络检测的baseline使用了类别的后验概率（即softmax）的最大值，这个方法可以在有些情况是一个良好的区分in-distribution和out-of-distribution的指示器。</p>
<p>ODIN，基于训练好的神经网络分类器，提供两个策略，temperature
scaling和input
preprocessing，使得用最大的输出概率检测OoD变的更有效。这个方法的性能已经深入的确认了，并且和很多其他的OoD检测方法都在相同的评估准则下进行了比较。ODIN的方法，比很多流行策略都要好，例如MC-Dropout，DeepEnsemble，PixelCNN++，OpenMax等等。</p>
<p>尽管ODIN的方法非常高效，它仍需要OoD的数据集来调超参。这样做的问题是，用一个OoD数据集调好的最佳超参数，换一个OoD数据集可能就不再理想。事实上，其他的基于神经网络的方法，在同样的问题设置下，都有同样的要求，观点上都是通过精挑细选OoD数据集来规范后验学习概率，这样就使得OoD的数据置信度比In-Distribution的置信度要低。最近，还有文章使用生成式模型来建模OoD相对于In-Distribution的边界。</p>
<p>尽管上面的工作展示了OoD数据参与学习是有效的，但其实OoD范围在高维空间是很宽泛的，比如说像素空间，因此很难被完美覆盖，潜在的导致了学习的选择偏差。一些以往的工作也尝试了不用OoD数据集参与学习，例如用单词嵌入作为额外的监督；或者使用度量学习的标准。然而这俩方法的报告性能都和ODIN差不多，表明不用OoD数据集参与训练是一个有挑战的设置。</p>
<p>在本文的工作中，作者遵循着ODIN的设置，采用两个相应的策略，不需要OoD数据来解决问题。首先，作者提出一个新的概率的视角来分解网络预测的置信度。增加了一个明确采用封闭世界假设的变量来表示数据是不是in-distribution的，然后讨论它在分解后的概率的角色。收到概率观点的启发，我们使用除数结构作为分类器，这鼓励了神经网络的行为更像分解后的置信度效果。如下图(Figure1)所示。</p>
<img src="/2021/04/04/Generalized-ODIN/Figure1.png" class title="this is Figure1">
<p>我们注意到这个除法结构和temperature
scaling紧密联系，且scaling依赖于输入而不是调好的超参数；第二，作者构建了ODIN中输入预处理的方法，然后研究出一个有效的策略去调节到微扰级别这个超参数，并且只需要in-distribution的数据。</p>
<p>接着，作者对基准图像数据集(如CIFAR10/100、TinyImageNet、LSUN、SVHN以及更大规模的数据集DomainNet)进行广泛的评估，以调查所提议的策略有用或没用。结果表明，这两种策略可以显著提高ODIN的性能，其性能接近甚至在某些情况下超过使用OoD数据调优的最先进方法。最后，我们在DomainNet上的系统评估揭示了两种分布迁移类型检测的相对难度:语义迁移和非语义迁移。这两者的区别是，迁移中是否包含新的类别。</p>
<p>综上所述，本文的贡献有三个方面:</p>
<ul>
<li>给出了分解置信度的新角度</li>
<li>提出一个不需要OoD调参的改进版input preprocessing的方法</li>
<li>在没有OoD数据参与学习的设置下，结合实验进行综合分析</li>
</ul>
<h2 id="background">Background</h2>
<p>本文研究了分类问题中的OoD检测设置问题。以一个数据集<span class="math inline">\(D_{in}=\{(\pmb{x}_i,y_i)\}_{i=1}^{N}\)</span>开始,
in-distribution数据集为<span class="math inline">\(\pmb{x}_i \in
R^k\)</span>, 以及对于C个类，类别标签<span class="math inline">\(y_i \in
\{y\}={1\cdots C}\)</span>。<span class="math inline">\(D_{in}\)</span>是从分布<span class="math inline">\(p_{in}(\pmb{x},y)\)</span>中抽样生成的。然后我们有一个具有区分力的模型<span class="math inline">\(f_{\theta}(\pmb{x})\)</span>，其中<span class="math inline">\(\theta\)</span>是从<span class="math inline">\(D_{in}\)</span>中学习到的参数，以更好的预测各个类的后验概率<span class="math inline">\(p(y|\pmb{x})\)</span>。</p>
<p>当学好的分类器<span class="math inline">\(f_{theta}\)</span>放置到开放世界中，他会遭遇到来自不同分布<span class="math inline">\(p_{out}\)</span>的数据。从所有可能的OoD位置采样是很困难的，例如维度很高的图像空间。注意我们可以在概念上把迁移的类别分为语义迁移和非语义的迁移。非语义迁移的数据是从分布<span class="math inline">\(p_{out}(\pmb{x},y)\)</span>中抽样的。而语义迁移的样本来自于同一个对象类，但以不同的形式进行表达，例如卡通和素描图片。这样的迁移也是domain
adaptation中广泛被讨论的问题。对于语义迁移的情况，从<span class="math inline">\(p_{out}(x,\overline{y})\)</span>中抽取样本。换句话说，这些样本的类型在训练集的<span class="math inline">\(D_{in}\)</span>中都是看不到的。以下是一个图示(Figure2)。</p>
<img src="/2021/04/04/Generalized-ODIN/Figure2.png" class title="this is Figure2">
<p>对于开方世界的模型，上述的差异引出了两个自然需要解决的问题：模型在遇到<span class="math inline">\(\pmb{x} \sim
p_{out}(x,\overline{y})\)</span>时，怎么能避免进行预测；当模型遇到<span class="math inline">\(\pmb{x} \sim
p_{out}(x,y)\)</span>时拒绝低置信度的预测。在本文中，作者提出了一个明确的二值域变量<span class="math inline">\(d \in
{d_{in},d_{out}}\)</span>来表达决定。前者表示<span class="math inline">\(\pmb{x}\sim p_{in}\)</span>，后者表示<span class="math inline">\(\pmb{x}\sim
p_{out}\)</span>。注意到模型通常是无法区分这两种情况的，我们仍然可以说以上的问题都可以通过估计变量<span class="math inline">\(d\)</span>来回答。</p>
<p>最后的目标也就是发现一个评分函数<span class="math inline">\(S(\pmb{x})\)</span>，其与后验概率<span class="math inline">\(p(d|\pmb{x})\)</span>相关。较高的评分<span class="math inline">\(S(\pmb{x})\)</span>表明一个较高的后验概率<span class="math inline">\(p(d|\pmb{x})\)</span>。最后二值的决定可以用一个阈值来处理。选择的阈值受限于应用需求和性能度量计算。有了上面的标注，我们可以把baseline方法当作是一个特例<span class="math inline">\(S_{Base}(\pmb{x})=\max_{y}p(y|\pmb{x})\)</span>，其中<span class="math inline">\(p(y|\pmb{x})\)</span>从一个标准的从交叉熵训练的神经网络分类器中获取。然而，<span class="math inline">\(S(\pmb{x})\)</span>可以是一个可学习的带参函数，不同的OoD方法可以按具体的参数和学习步骤来归类。方法间一个最关键的差异是，是否用OoD的数据参与<span class="math inline">\(S(\pmb{x})\)</span>训练过程。</p>
<h3 id="related-methods">Related Methods</h3>
<p>本节描述了和本文最相关的两个方法：<strong>ODIN</strong> 和
<strong>Mahalanobis</strong>。这两个方法将作为评估时两个很强的baseline进行比较，而且马氏距离是比ODIN更有优势的。注意到，这个两个方法都是用<span class="math inline">\(D_{in}\)</span>训练一个普通的分类器<span class="math inline">\(f_{\theta}\)</span>(单入口单出口)，然后有一个打分函数<span class="math inline">\(S(\pmb{x},f_{theta})\)</span>，有额外的超参数需要调。按两个方法原本的工作，打分函数里的超参数都是需要OoD的数据去调的。本文将会描述不需要OoD去调超参数的方法。</p>
<h4 id="odin">ODIN</h4>
<p>该方法包含两个策略，即temperture scaling和input
preprocessing。前者是把打分函数设置如下： <span class="math display">\[\begin{equation}
S_{ODIN}(\pmb{x})=\max\limits_{i}\frac{exp(f_i(\pmb{x})/T)}{\sum_{j=1}^{N}exp(f_j(\pmb{x})/T)}
\end{equation}\]</span></p>
<p>尽管ODIN的原始方法需要用OoD数据集调超参数<span class="math inline">\(T\)</span>，但其也展示了<span class="math inline">\(T\)</span>很大的时候通常是效果很好的，并且建议<span class="math inline">\(T\)</span>设置超过1000。因此本文遵循建议，在实验中把<span class="math inline">\(T\)</span>设置为1000。</p>
<h4 id="mahalanobis">Mahalanobis</h4>
<p>马氏距离同样包含了两个部分：马氏距离的计算和输入预处理。马氏距离的打分函数如下：
<span class="math display">\[\begin{equation}
S^{l}_{Maha}(\pmb{x})=\max\limits_{i}\{-[f^l(\pmb{x})-\mu_i^l]^T\Sigma_{l}^{-1}[f^l(\pmb{x})-\mu_i^l]\}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
S_{Maha}(\pmb{x})=\sum\limits_{l}\alpha_lS_{Maha}^l(\pmb{x})
\end{equation}\]</span></p>
<ul>
<li><span class="math inline">\(f^l(\pmb{x})\)</span>：网络的第<span class="math inline">\(l\)</span>层输出特征</li>
<li><span class="math inline">\(\mu_i\)</span>：第i个类的特征均值</li>
<li><span class="math inline">\(\Sigma\)</span>：N个类的特征的协方差矩阵</li>
<li><span class="math inline">\(\alpha_l\)</span>：超参数，每个层参与集成的权重</li>
</ul>
<p>原文的马氏距离需要OoD数据调优，本文就采用基础情况，即<span class="math inline">\(S_{Maha}(\pmb{x})=\sum\limits_{l}S_{Maha}^l(\pmb{x})\)</span></p>
<p>我们注意到马氏距离和ODIN一样也都用到了input
preprocessing的策略，又会引入需要OoD调优的超参数。因此本文还会给出一个不需要OoD调参的input
preprocessing方法。</p>
<h2 id="approach">Approach</h2>
<h3 id="the-decomposed-confidence">The Decomposed Confidence</h3>
<p>我们知道softmax分类器倾向于输出一个较高置信度的预测结果，比如把高斯噪声放到MNIST图像分类器中会给出高达91%的预测概率。这是因为softmax是高度平滑的指示函数，会给出一个很陡的概率分布结果而不是一个类之间概率平缓的结果。我们也承让这个观点，并更深远的考虑把这个当作是softmax设计中的缺陷。为了解决这个限制，我们的启发是重新思考输出的形式，也就是后验概率<span class="math inline">\(p(y|\pmb{x})\)</span>，这个概率没有考虑到<span class="math inline">\(d\)</span>的域。换句话说，目前的方法是建立在封闭世界假设<span class="math inline">\(d=d_{in}\)</span>的情况下的。因此，作者在分类器中使用明确的变量<span class="math inline">\(d_{in}\)</span>，用条件概率的规则将其改写为商的形式如下：
<span class="math display">\[\begin{equation}
p(y|d_{in},\pmb{x})=\frac{p(y,d_{in}|\pmb{x})}{p(d_{in}|\pmb{x})}
\end{equation}\]</span></p>
<p>上面的公式提供了一个概率的视角解释为什么分类器会过度自信。考虑到<span class="math inline">\(\pmb{x}\sim
p_{out}\)</span>，很自然的想到，C个类中的最大的联合概率<span class="math inline">\(p(y,d_{in}|\pmb{x})\)</span>是比较小的(如0.09)，同时期望对应的<span class="math inline">\(p(d_{in}|\pmb{x})\)</span>也是比较小的(如0.1)。因此，计算条件概率<span class="math inline">\(p(y|d_{in},\pmb{x})\)</span>以后还是可能会给出一个比较高的概率结果(0.9)。这展示了高度的自信是怎么导致的。基于公式4，作者把<span class="math inline">\(p(y,d_{in}|\pmb{x})\)</span>和<span class="math inline">\(p(d_{in}|\pmb{x})\)</span>叫做已分解的置信度。</p>
<p>一个直接的解决方案来解决上述问题，就是学习一个分类器来预测联合概率分布<span class="math inline">\(p(y,d_{in}|\pmb{x})\)</span>，这样既考虑了标签<span class="math inline">\(y\)</span>又考虑了变量<span class="math inline">\(d\)</span>。而获取一个联合概率分布的分类器比获得一个OoD的检测器要好，这是因为前者既能通过<span class="math inline">\(arg
\max_{y_{in}}p(y,d_{in}|\pmb{x})\)</span>来进行分类，又可以通过给定阈值来拒绝预测(博主个人理解是找个合适的阈值和<span class="math inline">\(\sum_{y_{in}}p(y,d_{in}|\pmb{x})\)</span>进行比较)。这样的观点和有些工作相关，比如添加额外的损失惩罚项到预测OoD概率不均匀的分类器中。然而这样的策略还是需要OoD去参与和调节训练的。</p>
<p>不使用OoD的数据集，没有一个主流的方法能够学到<span class="math inline">\(p(y,d_{in}|\pmb{x})\)</span>和<span class="math inline">\(p(d_{in}|\pmb{x})\)</span>。这个场景非常像无监督学习，需要插入关于学习的假设和先验知识。在本文中，作者使用了公式4的除法结构作为先验知识来设置分类器，提供分类器分解概率置信度的能力。</p>
<p>对于分类器的除法结构，作者定义第i个类的输出logit为<span class="math inline">\(f_i(\pmb{x})\)</span>，并且可以写成除法的形式：</p>
<p><span class="math display">\[\begin{equation}
f_i(\pmb{x})=\frac{h_i(\pmb{x})}{g(\pmb{x})}
\end{equation}\]</span></p>
<p>这个商<span class="math inline">\(f_i(\pmb{x})\)</span>然后用指数函数归一化，变成softmax，然后被当成条件概率<span class="math inline">\(p(y|d_{in},\pmb{x})\)</span>，这个条件概率受限于交叉熵损失。</p>
<p>在softmax指数归一化的影响下，交叉熵损失将会以两种方式减小，增加<span class="math inline">\(h_i(\pmb{x})\)</span>或者减小<span class="math inline">\(g(\pmb{x})\)</span>。换句话说，当数据不是in-distribution总的高密度区域时，<span class="math inline">\(h_i(\pmb{x})\)</span>趋向于比较小的值。这样，<span class="math inline">\(g(\pmb{x})\)</span>也会比较小以最小化交叉熵损失。其他的情况，也就是数据在高密度区域，<span class="math inline">\(h_i(\pmb{x})\)</span>会很容易变大，因此<span class="math inline">\(g(\pmb{x})\)</span>不鼓励变小。这些对分子分母的讨论和条件概率分解后的分子分母有着相似性，这样单独看分子分母的分布，OoD和ID是有较小的重叠的，这也是<span class="math inline">\(p(y,d_{in}|\pmb{x})\)</span>和<span class="math inline">\(p(d_{in}|\pmb{x})\)</span>的本质性质，如之前图1所展示的那样。</p>
<h4 id="design-choices">Design Choices</h4>
<p>尽管除法结构提供了一个趋势，但它不能保证分解置信度的效果一定发生。<span class="math inline">\(h_i(\pmb{x})\)</span>和<span class="math inline">\(g(\pmb{x})\)</span>的特点可以极大的影响分解发生的可能性。因此我们讨论了一系列简单的设计选择，来考察分解通常是不是能够获得的。</p>
<p>具体而言，使用<span class="math inline">\(g(\pmb{x})=\sigma[BN(\pmb{\omega}_gf^p(\pmb{x})+b_g)]\)</span>，其中：</p>
<ul>
<li><span class="math inline">\(f^p(\pmb{x})\)</span>：网络倒数第二层，后面还要套上线性层、BN、sigmoid函数</li>
<li><span class="math inline">\(\sigma\)</span>：sigmoid函数</li>
<li><span class="math inline">\(\pmb{\omega}\)</span>和<span class="math inline">\(b\)</span>表示可学习的权重</li>
</ul>
<p>对于<span class="math inline">\(h_i(\pmb{x})\)</span>，我们研究了三个相似性的度量：
+ 内积：<span class="math inline">\(h_i^I(\pmb{x})=\pmb{\omega}_i^Tf^p(\pmb{x})+b_i\)</span>
+ 欧氏距离的相反数：<span class="math inline">\(h_i^E(\pmb{x})=-||f^p(\pmb{x})-\pmb{\omega}_i||^2\)</span>
+ 余弦相似性：<span class="math inline">\(h_i^C(\pmb{x})=\frac{\pmb{\omega}_i^Tf^p(\pmb{x})}{||\pmb{\omega}_i||||f^p(\pmb{x})||}\)</span></p>
<p>因此整个网络<span class="math inline">\(f_{\theta}\)</span>在倒数第二层后分为两个分支<span class="math inline">\(h_i\)</span>和<span class="math inline">\(g\)</span>。在训练时，模型计算softmax函数处理后的logit的交叉熵；在测试阶段，类别的预测将由<span class="math inline">\(arg \max_if_i(\pmb{x})\)</span>或<span class="math inline">\(arg
\max_ih_i(\pmb{x})\)</span>来给出，俩者预测结果是一样的。对于OoD检测，score函数是<span class="math inline">\(S_{DeConf}(\pmb{x})=\max_ih_i(\pmb{x})\)</span>或<span class="math inline">\(g(\pmb{x})\)</span>。如果令<span class="math inline">\(h_i(\pmb{x})=h_i^I(\pmb{x})\)</span>且<span class="math inline">\(g(\pmb{x})=1\)</span>那么将退化为baseline。本文把三个变量的方法分别成为Deconf-I,Deconf-E和DeConf-C。为了简单起见，用<span class="math inline">\(h_i(\pmb{x})\)</span>作为scores，而<span class="math inline">\(g(\pmb{x})\)</span>的使用之后会具体说明。 ####
Temperature Scaling</p>
<h3 id="a-modified-input-preprocessing-strategy">A Modified Input
Preprocessing Strategy</h3>
<h2 id="experiments">Experiments</h2>
<h3 id="experimental-settings">Experimental Settings</h3>
<h3 id="results-and-discussion">Results and Discussion</h3>
<h3 id="semantic-shift-versus-non-semantic-shift">Semantic Shift versus
Non-semantic Shift</h3>
<h2 id="conclusion">Conclusion</h2>
]]></content>
      <categories>
        <category>OoD Detection</category>
      </categories>
      <tags>
        <tag>Reading Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第二章-随机变量及其概率分布</title>
    <url>/2021/11/26/ProbabilityAndStatistics2/</url>
    <content><![CDATA[<ul>
<li>本知识总结不提供完整的理论体系汇总，旨在给出<em>概念的理解</em>以及<em>各类问题的思考框架</em>。</li>
<li>笔记为个人整理，禁止商业用途</li>
<li>如有疏漏，欢迎留言</li>
</ul>
<h2 id="随机变量及其分布函数">随机变量及其分布函数</h2>
<ul>
<li>随机变量：从样本点到某个实数的函数</li>
<li>分布函数：<span class="math inline">\(F(x)=P(X\leq x)\)</span>
<ul>
<li>单调非减</li>
<li>右连续</li>
<li><span class="math inline">\(P\{X=x\}=F(x)-F(x-0)\)</span></li>
</ul></li>
</ul>
<h2 id="离散型随机变量">离散型随机变量</h2>
<ul>
<li>定义：随机变量的取值为有限个或可数无穷个</li>
<li>分布律：算出每个取值的概率
<ul>
<li>表示：一般用表格列出每个取值的概率</li>
<li>性质：每项非负，总和为1</li>
</ul></li>
</ul>
<h2 id="连续型随机变量">连续型随机变量</h2>
<ul>
<li>定义：能找到一个非负可积的函数<span class="math inline">\(f(x)\)</span>，使得随机变量的分布函数<span class="math inline">\(F(x)=\int_{-\infty}^xf(t)dt,-\infty&lt;x&lt;+\infty\)</span>
<ul>
<li><span class="math inline">\(f(x)\)</span>为密度函数</li>
</ul></li>
<li>性质：连续型随机变量的分布函数一定连续，反之则不一定（比如康托尔函数）</li>
<li>密度函数性质
<ul>
<li>非负</li>
<li>实数域积分为1</li>
<li><span class="math inline">\(P(x_1&lt;X\leq
x_2)=\int_{x_1}^{x_2}f(t)dt\)</span>（不等式端点的概率值为0，可带上可不带上）</li>
<li>密度函数不连续的点，一般认为分布函数不可导（不考虑实变函数、测度论）</li>
<li>密度函数连续的点，概率密度等于分布函数的导数</li>
</ul></li>
</ul>
<h2 id="常见分布">常见分布</h2>
<h3 id="离散型">离散型</h3>
<ul>
<li>0-1分布
<ul>
<li><span class="math inline">\(X\sim B(1,p)\)</span></li>
<li><span class="math inline">\(P\{X=k\}=p,P(X=0)=1-p\)</span></li>
</ul></li>
<li>二项分布
<ul>
<li><span class="math inline">\(X\sim B(n,p)\)</span></li>
<li><span class="math inline">\(P\{X=k\}=C_n^kp^k(1-p)^(n-k),k=0,1,\cdots,n\)</span></li>
</ul></li>
<li>几何分布
<ul>
<li>参数<span class="math inline">\(p\)</span></li>
<li><span class="math inline">\(P\{X=k\}=p(1-p)^{k-1},k=1,2,\cdots\)</span>
<ul>
<li>即伯努利试验第<span class="math inline">\(k\)</span>次才成功的概率</li>
</ul></li>
</ul></li>
<li>超几何分布
<ul>
<li>参数<span class="math inline">\(n,N,M\)</span></li>
<li><span class="math inline">\(P\{X=k\}=\frac{C_M^kC_{N-M}^{n-k}}{C_N^n}\)</span>
<ul>
<li>总共<span class="math inline">\(N\)</span>个产品，<span class="math inline">\(M\)</span>个次品，抽出<span class="math inline">\(n\)</span>件样品，有<span class="math inline">\(k\)</span>个次品的概率</li>
</ul></li>
</ul></li>
<li>泊松分布
<ul>
<li><span class="math inline">\(X\sim P(\lambda)\)</span></li>
<li><span class="math inline">\(P\{X=k\}=\frac{\lambda^k}{k!e^\lambda},k=0,1,\cdots\)</span></li>
<li>泊松定理的使用
<ul>
<li>对于伯努利分布<span class="math inline">\(B(n,p)\)</span>，当<span class="math inline">\(n\)</span>大、<span class="math inline">\(p\)</span>小、<span class="math inline">\(np\)</span>不太大时，可近似为泊松分布<span class="math inline">\(P(np)\)</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="连续型">连续型</h3>
<ul>
<li>均匀分布
<ul>
<li><span class="math inline">\(X\sim U(a,b)\)</span>
<ul>
<li>在<span class="math inline">\((a,b)\)</span>上均匀分布</li>
</ul></li>
<li><span class="math inline">\(X\sim U[a,b]\)</span>
<ul>
<li>在<span class="math inline">\([a,b]\)</span>上均匀分布</li>
</ul></li>
</ul></li>
<li>指数分布
<ul>
<li><span class="math inline">\(X\sim E(\lambda)\)</span>
<ul>
<li><span class="math inline">\(f(x)=\lambda e^{-\lambda
x},x&gt;0\)</span></li>
<li><span class="math inline">\(f(x)=0,x\leq 0\)</span></li>
</ul></li>
</ul></li>
<li>正态分布
<ul>
<li><span class="math inline">\(X\sim N(\mu,\sigma^2)\)</span>
<ul>
<li>标准正态分布为<span class="math inline">\(N(0,1)\)</span></li>
</ul></li>
<li><span class="math inline">\(f(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}\)</span>
<ul>
<li>标准正态分布函数<span class="math inline">\(\Phi(x)\)</span>，密度函数<span class="math inline">\(\phi(x)\)</span></li>
</ul></li>
<li>性质
<ul>
<li><span class="math inline">\(F(x)=\Phi(\frac{x-\mu}{\sigma})\)</span></li>
<li><span class="math inline">\(\phi(x)=\phi(-x)\)</span></li>
<li><span class="math inline">\(\Phi(x)=1-\Phi(-x)\)</span></li>
</ul></li>
<li>标准化
<ul>
<li><span class="math inline">\(P\{\frac{X-\mu}{\sigma}\leq
\frac{x-\mu}{\sigma}\}=P\{X\leq
x\}=F(x)=\Phi(\frac{x-\mu}{\sigma})\)</span></li>
<li>故<span class="math inline">\(P\{\frac{X-\mu}{\sigma}\leq
y\}=\Phi(y)\)</span></li>
<li>即<span class="math inline">\(\frac{X-\mu}{\sigma}\sim
N(0,1)\)</span></li>
</ul></li>
</ul></li>
</ul>
<h2 id="随机变量函数的分布">随机变量函数的分布</h2>
<p>即求<span class="math inline">\(Y=g(X)\)</span>的分布</p>
<h3 id="离散型-1">离散型</h3>
<ul>
<li>列表求解即可，核心是<strong>把随机变量的函数中相同的值的概率合并</strong></li>
</ul>
<h3 id="连续型-1">连续型</h3>
<ul>
<li>公式法
<ul>
<li>要求<span class="math inline">\(g\)</span>函数为一一映射，比如单调</li>
<li>利用<span class="math inline">\(|f_X(x)dx|=|f_Y(y)dy|\)</span>，得到<span class="math inline">\(f_Y(y)=\frac{dx}{dy}f_X(g^{-1}(y))\)</span></li>
</ul></li>
<li>定义法
<ul>
<li>利用<span class="math inline">\(F_Y(y)=P\{Y\leq y\}=P\{g(X)\leq
y\}=\int_{g(x)\leq y} f_X(x)dx\)</span></li>
<li>往往需要分三段讨论<span class="math inline">\(y\)</span>
<ul>
<li>太小时分布函数为<span class="math inline">\(0\)</span></li>
<li>太大时分布函数为<span class="math inline">\(1\)</span></li>
<li>适中时再深入计算</li>
</ul></li>
</ul></li>
<li>重要结论
<ul>
<li>任一连续型随机变量<span class="math inline">\(X\)</span>，分布函数为<span class="math inline">\(F(x)\)</span>，则<span class="math inline">\(Y=F(X)\sim
U(0,1)\)</span>（用定义法即可证明）</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>概率论与数理统计</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第一章-随机事件和概率</title>
    <url>/2021/11/26/ProbabilityAndStatistics1/</url>
    <content><![CDATA[<ul>
<li>本知识总结不提供完整的理论体系汇总，旨在给出<em>概念的理解</em>以及<em>各类问题的思考框架</em>。</li>
<li>笔记为个人整理，禁止商业用途</li>
<li>如有疏漏，欢迎留言</li>
</ul>
<h2 id="事件">事件</h2>
<ul>
<li>随机试验：可重复、已知所有可能的结果、结果无法预知的实验</li>
<li>样本点：随机试验可能的结果</li>
<li>样本空间：所有样本点的集合</li>
<li>随机事件：样本空间的子集（是一个集合）
<ul>
<li>关系
<ul>
<li>包含</li>
<li>相等</li>
<li>互斥</li>
<li>对立（补运算）</li>
</ul></li>
<li>运算
<ul>
<li>交</li>
<li>并</li>
<li>差（<span class="math inline">\(A-B=A\overline{B}\)</span>）</li>
<li>补（对立关系）</li>
</ul></li>
<li>运算规律
<ul>
<li>交换律</li>
<li>结合律</li>
<li>分配律（两个）</li>
<li>对偶律（德摩根律）</li>
</ul></li>
</ul></li>
<li>推导时用韦恩图辅助</li>
</ul>
<h2 id="概率">概率</h2>
<ul>
<li>定义
<ul>
<li>概率非负</li>
<li>必然事件概率为1</li>
<li>互斥事件的并的概率 = 互斥事件概率的和</li>
</ul></li>
<li>条件概率
<ul>
<li><span class="math inline">\(P(A|B)=\frac{P(AB)}{P(B)}\)</span></li>
</ul></li>
<li>独立
<ul>
<li>两个事件独立
<ul>
<li><span class="math inline">\(P(A|B)=P(A)\Leftrightarrow
P(AB)=P(A)P(B)\)</span></li>
</ul></li>
<li>多个事件独立
<ul>
<li>任取<span class="math inline">\(k\)</span>个事件，<span class="math inline">\(P(A_{i_1}A_{i_2}\cdots
A_{i_k})=P(A_{i_1})P(A_{i_2})\cdots P(A_{i_k})\)</span></li>
</ul></li>
<li>充要条件
<ul>
<li>互相独立的n个事件中的任何几个换成相应对立事件，新的n个事件依然相互独立</li>
</ul></li>
</ul></li>
<li>五大公式（用韦恩图记忆）
<ul>
<li>加法
<ul>
<li><span class="math inline">\(P(A\cup B)=P(A)+P(B)-P(AB)\)</span></li>
</ul></li>
<li>减法
<ul>
<li><span class="math inline">\(P(A-B)=P(A)-P(AB)\)</span></li>
</ul></li>
<li>乘法（本质是条件概率）
<ul>
<li><span class="math inline">\(P(A_1A_2\cdots
A_n)=P(A_1)P(A_2|A_1)\cdots P(A_n|A_1A_2\cdots A_{n-1})\)</span></li>
</ul></li>
<li>全概率
<ul>
<li>全集划分为<span class="math inline">\(B_i\)</span></li>
<li><span class="math inline">\(P(A)=\sum P(B_i)P(A|B_i)\)</span></li>
</ul></li>
<li>贝叶斯（全概率+条件概率）
<ul>
<li>全集划分为<span class="math inline">\(B_i\)</span></li>
<li><span class="math inline">\(P(B_j|A)=\frac{P(B_jA)}{P(A)}=\frac{P(B_j)P(A|B_j)}{\sum
P(B_i)P(A|B_i)}\)</span></li>
<li>第一个等号用条件概率；第二个等号的分子用条件概率；第二个等号的分母用全概率</li>
</ul></li>
</ul></li>
</ul>
<h2 id="基本概型">基本概型</h2>
<ul>
<li>古典概型
<ul>
<li>事件的概率 = 事件的样本点数 比 样本空间总点数</li>
</ul></li>
<li>几何概型
<ul>
<li>把古典概型离散的样本点连续化推广</li>
</ul></li>
<li>伯努利试验
<ul>
<li>一次伯努利试验只有对立的正反两个结果</li>
<li>每次伯努利试验独立</li>
<li><span class="math inline">\(n\)</span>次伯努利试验，出现<span class="math inline">\(k\)</span>次正结果的概率是<span class="math inline">\(C_n^kp^k(1-p)^{n-k}\)</span></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>概率论与数理统计</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第三章-多维随机变量及其概率分布</title>
    <url>/2021/11/28/ProbabilityAndStatistics3/</url>
    <content><![CDATA[<ul>
<li>本知识总结不提供完整的理论体系汇总，旨在给出<em>概念的理解</em>以及<em>各类问题的思考框架</em>。</li>
<li>笔记为个人整理，禁止商业用途</li>
<li>如有疏漏，欢迎留言</li>
</ul>
<h2 id="二维离散型随机向量">二维离散型随机向量</h2>
<ul>
<li>联合概率分布
<ul>
<li>用二维的<strong>列联表</strong>表示</li>
</ul></li>
<li>联合分布函数
<ul>
<li><span class="math inline">\(F(x,y)=P\{X\leq x,Y\leq
y\}\)</span></li>
</ul></li>
<li>边缘分布
<ul>
<li>关于<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>的边缘分布为<span class="math inline">\(F_X(x)=P\{X\leq x\}\)</span>和<span class="math inline">\(F_Y(y)=P\{Y\leq y\}\)</span></li>
<li>把列联表按行或按列累加</li>
</ul></li>
<li>条件分布
<ul>
<li>一个条件对应列联表的某行或某列</li>
<li>把该行或列标准化，写成一维表，表示条件分布律</li>
</ul></li>
</ul>
<h2 id="二维随机变量及其分布">二维随机变量及其分布</h2>
<ul>
<li>联合分布函数
<ul>
<li><span class="math inline">\(F(x,y)=P\{X\leq x,Y\leq
y\}\)</span></li>
</ul></li>
<li>联合密度函数
<ul>
<li>存在非负可积二元函数<span class="math inline">\(p(x,y)\)</span>使得<span class="math inline">\(F(x,y)=\int_{-\infty}^x\int_{-\infty}^yp(u,v)dudv\)</span></li>
<li><span class="math inline">\(p(x,y)\)</span>即密度函数
<ul>
<li>非负</li>
<li>平面上积分为1</li>
</ul></li>
</ul></li>
<li>边缘分布
<ul>
<li><span class="math inline">\(F_X(x)=F(x,+\infty)\)</span></li>
<li><span class="math inline">\(F_Y(y)=F(+\infty,y)\)</span></li>
</ul></li>
<li>边缘密度
<ul>
<li><span class="math inline">\(p_X(x)=\int_{-\infty}^{+\infty}p(x,v)dv\)</span></li>
<li><span class="math inline">\(p_Y(y)=\int_{-\infty}^{+\infty}p(u,y)du\)</span></li>
</ul></li>
<li>条件分布
<ul>
<li><span class="math inline">\(F_{Y|X=x}(y|x)=\int_{-\infty}^y\frac{p(x,v)}{P_X(x)}dv\)</span></li>
<li><span class="math inline">\(F_{X|Y=y}(x|y)=\int_{-\infty}^x\frac{p(u,y)}{P_Y(y)}du\)</span></li>
</ul></li>
<li>条件密度
<ul>
<li><span class="math inline">\(p_{Y|X=x}(y|x)=\frac{p(x,y)}{P_X(x)}\)</span></li>
<li><span class="math inline">\(p_{X|Y=y}(x|y)=\frac{p(x,y)}{P_Y(y)}\)</span></li>
</ul></li>
</ul>
<h2 id="随机变量独立性">随机变量独立性</h2>
<ul>
<li>两个随机变量相互独立
<ul>
<li><span class="math inline">\(F(x,y)=F_X(x)F_Y(y)\)</span></li>
</ul></li>
<li>两个离散型随机变量相互独立
<ul>
<li><span class="math inline">\(P\{X=x_i,Y=y_j\}=P\{X=x_i\}P\{Y=y_j\}\)</span></li>
</ul></li>
<li>两个连续型随机变量相互独立
<ul>
<li><span class="math inline">\(f(x,y)=f_X(x)f_Y(y)\)</span></li>
</ul></li>
</ul>
<h2 id="二维均匀分布">二维均匀分布</h2>
<ul>
<li>在某个区域内概率密度为常数</li>
</ul>
<h2 id="二维正态分布">二维正态分布</h2>
<ul>
<li>表示
<ul>
<li><span class="math inline">\((X,Y)\sim
N(\mu_1,\mu_2;\sigma_1^2,\sigma_2^2;\rho)\)</span></li>
</ul></li>
<li>性质
<ul>
<li><span class="math inline">\(X\sim N(\mu_1,\sigma_1^2),Y\sim
N(\mu_2,\sigma_2^2)\)</span></li>
<li><span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>为一维正态分布且相互独立 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\((X,Y)\)</span>为二维正态分布且<span class="math inline">\(\rho=0\)</span></li>
<li>当<span class="math inline">\(a\neq 0\)</span>或<span class="math inline">\(b\neq 0\)</span>，<span class="math inline">\(aX+bY\)</span>服从一维正态分布</li>
<li>当<span class="math inline">\(ad\neq bc\)</span>，<span class="math inline">\((aX+bY,cX+dY)\)</span>服从二维正态分布</li>
</ul></li>
</ul>
<h2 id="两个随机变量函数的分布">两个随机变量函数的分布</h2>
<p>设<span class="math inline">\(Z=g(X,Y)\)</span></p>
<h3 id="两个离散型">两个离散型</h3>
<ul>
<li>列出<span class="math inline">\((X,Y)\)</span>的联合概率分布表</li>
<li>求<span class="math inline">\(Z\)</span>各个取值的概率，列出一维分布律表</li>
</ul>
<h3 id="两个连续型">两个连续型</h3>
<ul>
<li><strong>定义法</strong>
<ul>
<li><span class="math inline">\(F_Z(z)=p\{Z\leq
z\}=\iint\limits_{g(x,y)\leq z}f(x,y)dxdy\)</span></li>
</ul></li>
<li><span class="math inline">\(Z=X+Y\)</span>的分布函数（<strong>定义法</strong>）
<ul>
<li><span class="math inline">\(F_Z(z)=\iint\limits_{x+y\leq
z}f(x,y)dxdy\)</span></li>
<li>即<span class="math inline">\(F_Z(z)=\int_{-\infty}^{+\infty}dy\int_{-\infty}^{z-y}f(x,y)dx=\int_{-\infty}^{+\infty}dx\int_{-\infty}^{z-x}f(x,y)dy\)</span></li>
</ul></li>
<li><span class="math inline">\(Z=X+Y\)</span>的密度函数（<strong>定义法的结果求导</strong>）
<ul>
<li><span class="math inline">\(f_Z(z)=\int_{-\infty}^{+\infty}f(z-y,y)dy=\int_{-\infty}^{+\infty}f(x,z-x)dx\)</span></li>
</ul></li>
<li><span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>独立时，<span class="math inline">\(Z=X+Y\)</span>的密度函数（<strong>卷积公式</strong>）
<ul>
<li><span class="math inline">\(f_Z(z)=\int_{-\infty}^{+\infty}f(z-y)f(y)dy=\int_{-\infty}^{+\infty}f(x)f(z-x)dx\)</span></li>
</ul></li>
</ul>
<h3 id="一个离散型一个连续型">一个离散型一个连续型</h3>
<ul>
<li>设<span class="math inline">\(X\)</span>为离散型，<span class="math inline">\(Y\)</span>为连续型</li>
<li>利用定义法结合全概率
<ul>
<li><span class="math inline">\(F_Z(z)=P\{Z\leq z\}=P\{g(X,Y)\leq
z\}=\sum\limits_iP\{X=x_i\}P\{g(X,Y)\leq z|X=x_i\}\)</span></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>概率论与数理统计</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第四章-随机变量的数字特征</title>
    <url>/2021/11/28/ProbabilityAndStatistics4/</url>
    <content><![CDATA[<ul>
<li>本知识总结不提供完整的理论体系汇总，旨在给出<em>概念的理解</em>以及<em>各类问题的思考框架</em>。</li>
<li>笔记为个人整理，禁止商业用途</li>
<li>如有疏漏，欢迎留言</li>
</ul>
<h2 id="数学期望">数学期望</h2>
<ul>
<li>离散型
<ul>
<li><span class="math inline">\(E(X)=\sum\limits_k
x_kP\{X=x_k\}\)</span></li>
</ul></li>
<li>连续型
<ul>
<li><span class="math inline">\(E(x)=\int_{-\infty}^{+\infty}xf(x)dx\)</span></li>
</ul></li>
<li>性质
<ul>
<li><span class="math inline">\(E(X\pm Y)=E(X)\pm E(Y)\)</span></li>
<li><span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>不相关，当且仅当<span class="math inline">\(E(XY)=E(X)E(Y)\)</span></li>
</ul></li>
<li>随机变量函数的数学期望
<ul>
<li>法一：求出随机变量函数的分布，再用定义求数学期望，比较麻烦</li>
<li>法二：直接用数学期望的定义求解，不需要算随机变量函数的分布，方便</li>
</ul></li>
</ul>
<h2 id="方差">方差</h2>
<ul>
<li>方差
<ul>
<li><span class="math inline">\(D(X)=E\{\[X-E(X)\]^2\}\)</span></li>
</ul></li>
<li>标准差
<ul>
<li><span class="math inline">\(\sigma(X)=\sqrt{D(X)}\)</span></li>
</ul></li>
<li>性质
<ul>
<li><span class="math inline">\(D(X)=E(X^2)-E^2(X)\)</span></li>
<li><span class="math inline">\(D(aX+b)=a^2D(X)\)</span></li>
<li><span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>不相关，当且仅当<span class="math inline">\(D(X\pm Y)=D(X)+ D(Y)\)</span></li>
</ul></li>
</ul>
<h2 id="常见分布的期望和方差">常见分布的期望和方差</h2>
<ul>
<li>0-1分布
<ul>
<li><span class="math inline">\(E(X)=p,D(X)=p(1-p)\)</span></li>
</ul></li>
<li>二项分布
<ul>
<li><span class="math inline">\(E(X)=np,D(X)=np(1-p)\)</span></li>
</ul></li>
<li>泊松分布
<ul>
<li><span class="math inline">\(E(X)=\lambda,D(X)=\lambda\)</span></li>
</ul></li>
<li>几何分布
<ul>
<li><span class="math inline">\(E(X)=\frac{1}{p},D(X)=\frac{1-p}{p^2}\)</span></li>
</ul></li>
<li>均匀分布
<ul>
<li><span class="math inline">\(E(X)=\frac{a+b}{2},D(X)=\frac{(a-b)^2}{12}\)</span></li>
</ul></li>
<li>指数分布
<ul>
<li><span class="math inline">\(E(X)=\frac{1}{\lambda},D(X)=\frac{1}{\lambda^2}\)</span></li>
</ul></li>
<li>正态分布
<ul>
<li><span class="math inline">\(E(X)=\mu,D(X)=\sigma^2\)</span></li>
</ul></li>
</ul>
<h2 id="矩">矩</h2>
<ul>
<li><span class="math inline">\(k\)</span>阶原点矩（<span class="math inline">\(k=1,2,\cdots\)</span>）
<ul>
<li><span class="math inline">\(E(X^k)\)</span></li>
</ul></li>
<li><span class="math inline">\(k\)</span>阶中心矩（<span class="math inline">\(k=1,2,\cdots\)</span>）
<ul>
<li><span class="math inline">\(E\{\[X-E(X)\]^k\}\)</span></li>
</ul></li>
<li><span class="math inline">\(k+l\)</span>阶混合原点矩（<span class="math inline">\(k,l=1,2,\cdots\)</span>）
<ul>
<li>简称混合矩</li>
<li><span class="math inline">\(E(X^kY^l)\)</span></li>
</ul></li>
<li><span class="math inline">\(k+l\)</span>阶混合中心矩（<span class="math inline">\(k,l=1,2,\cdots\)</span>）
<ul>
<li><span class="math inline">\(E\{\[X-E(X)\]^k\[Y-E(Y)\]^l\}\)</span></li>
</ul></li>
</ul>
<h2 id="协方差">协方差</h2>
<ul>
<li>定义
<ul>
<li><span class="math inline">\(Cov(X,Y)=E\{\[X-E(X)\]\[Y-E(Y)\]\}\)</span></li>
</ul></li>
<li>性质
<ul>
<li><span class="math inline">\(Cov(X,Y)=E(XY)-E(X)E(Y)\)</span></li>
<li><span class="math inline">\(D(X\pm Y)=D(X)+D(Y)\pm
2Cov(X,Y)\)</span></li>
</ul></li>
</ul>
<h2 id="相关系数">相关系数</h2>
<ul>
<li>定义
<ul>
<li>当<span class="math inline">\(D(X)D(Y)\neq 0\)</span>
<ul>
<li><span class="math inline">\(\rho_{XY}=\frac{Cov(X,Y)}{\sqrt{D(X)D(Y)}}\)</span></li>
</ul></li>
<li>当<span class="math inline">\(D(X)D(Y)= 0\)</span>
<ul>
<li><span class="math inline">\(\rho_{XY}=0\)</span></li>
</ul></li>
</ul></li>
<li>性质
<ul>
<li><span class="math inline">\(\rho_{XY}=0\)</span> 当且仅当 <span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>不相关</li>
<li><span class="math inline">\(|\rho_{XY}|\leq 1\)</span></li>
<li><span class="math inline">\(|\rho_{XY}|=1\)</span> 当且仅当
存在<span class="math inline">\(a,b\)</span>使得<span class="math inline">\(P\{Y=aX+b\}=1\)</span></li>
</ul></li>
</ul>
<h2 id="独立和不相关">独立和不相关</h2>
<ul>
<li>独立一定不相关</li>
<li>不相关不一定独立</li>
<li>如果是二维正态分布，则相互独立等价于不相关
<ul>
<li>可以参考第三章二维正态分布的结论</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>概率论与数理统计</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第五章-大数定律和中心极限定理</title>
    <url>/2021/11/29/ProbabilityAndStatistics5/</url>
    <content><![CDATA[<ul>
<li>本知识总结不提供完整的理论体系汇总，旨在给出<em>概念的理解</em>以及<em>各类问题的思考框架</em>。</li>
<li>笔记为个人整理，禁止商业用途</li>
<li>如有疏漏，欢迎留言</li>
</ul>
<h2 id="切比雪夫不等式">切比雪夫不等式</h2>
<ul>
<li><span class="math inline">\(P\{|X-E(X)|\geq \epsilon\}\leq
\frac{D(X)}{\epsilon^2}\)</span></li>
<li>记忆：<strong>离谱的概率不大</strong></li>
</ul>
<h2 id="依概率收敛">依概率收敛</h2>
<ul>
<li>对任意<span class="math inline">\(\epsilon\)</span>，有<span class="math inline">\(\lim\limits_{n\rightarrow
\infty}P\{|X_n-A|&lt;\epsilon\}=1\)</span>，则<span class="math inline">\(X_n\stackrel{P}\longrightarrow\ A\)</span></li>
<li>记忆：类似于极限的定义</li>
</ul>
<h2 id="大数定律">大数定律</h2>
<h3 id="核心结论">核心结论</h3>
<ul>
<li><span class="math inline">\(\frac{1}{n}\sum\limits_{i=1}^n
X_i\stackrel{P}\longrightarrow E(\frac{1}{n}\sum\limits_{i=1}^n
X_i)\)</span></li>
<li>记忆：随机变量的均值 <strong>依概率收敛到</strong>
均值的期望（一个数值）
<ul>
<li>体现均值的稳定性，稳定到某个数值</li>
</ul></li>
</ul>
<h3 id="各版本的表述">各版本的表述</h3>
<p>随机变量序列的各随机变量需要<strong>满足一定条件</strong>如下</p>
<ul>
<li>切比雪夫大数定律
<ul>
<li>条件：相互独立、方差一致有上界</li>
<li>注：一致有上界是数学分析的内容，了解即可</li>
</ul></li>
<li>伯努利大数定律
<ul>
<li>条件：互相独立的0-1分布</li>
<li>注：其和是满足伯努利分布的随机变量</li>
</ul></li>
<li>辛钦大数定律
<ul>
<li>条件：独立同分布、期望存在</li>
<li>注：常用形式</li>
</ul></li>
</ul>
<h2 id="中心极限定理">中心极限定理</h2>
<h2 id="核心结论-1">核心结论</h2>
<ul>
<li><span class="math inline">\(X_1,X_2,\cdots,X_n\)</span>独立同分布且期望<span class="math inline">\(\mu\)</span>和方差<span class="math inline">\(\sigma^2\)</span>存在
<ul>
<li>则<span class="math inline">\(n\rightarrow \infty\)</span>时，<span class="math inline">\(\sum\limits_{i=1}^nX_i \sim
N(n\mu,n\sigma^2)\)</span></li>
<li>即<span class="math inline">\(\lim\limits_{n\rightarrow
\infty}P\{\frac{\sum\limits_{i=1}^nX_i-n\mu}{\sqrt{n}\sigma}\leq
x\}=\Phi(x)\)</span></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>概率论与数理统计</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第六章-数理统计的基本概念</title>
    <url>/2021/12/02/ProbabilityAndStatistics6/</url>
    <content><![CDATA[<ul>
<li>本知识总结不提供完整的理论体系汇总，旨在给出<em>概念的理解</em>以及<em>各类问题的思考框架</em>。</li>
<li>笔记为个人整理，禁止商业用途</li>
<li>如有疏漏，欢迎留言</li>
</ul>
<h2 id="基本概念">基本概念</h2>
<ul>
<li>总体
<ul>
<li>研究对象某个数量指标（随机变量）的全体</li>
<li><strong>总体的分布</strong>即该随机变量的分布</li>
</ul></li>
<li>简单随机样本
<ul>
<li><strong>独立同分布</strong>（同总体的分布）的随机变量</li>
</ul></li>
<li>样本值
<ul>
<li>样本的观测数值</li>
</ul></li>
<li>统计量
<ul>
<li>简单随机样本的函数</li>
<li><strong>随机变量</strong>的函数</li>
</ul></li>
<li>抽样分布
<ul>
<li>统计量的分布</li>
</ul></li>
<li>统计值
<ul>
<li>统计量的观测数值</li>
</ul></li>
<li>分布的上<span class="math inline">\(\alpha\)</span>分位点
<ul>
<li>该分布的随机变量大于此分位点的概率是<span class="math inline">\(\alpha\)</span></li>
</ul></li>
</ul>
<h2 id="概率论和数理统计的宏观理解">概率论和数理统计的宏观理解</h2>
<p><em>本节不是严格的理论，仅提供各个概念的大致理解，便于记忆繁杂的内容</em></p>
<ul>
<li>概率论
<ul>
<li>核心问题
<ul>
<li>求总体的分布（随机变量的分布），进而求数字特征（反映总体分布特征的数字）</li>
</ul></li>
<li>核心步骤
<ul>
<li>定义法计算总体的分布，定义法求数字特征</li>
</ul></li>
</ul></li>
<li>数理统计
<ul>
<li>核心问题
<ul>
<li>已知样本值，通过各种方法，对总体的参数进行估计（参数估计），对总体的参数满足的性质进行验证（假设检验）</li>
</ul></li>
<li>矩估计的原理
<ul>
<li>用样本统计值（数字）估计总体的数字特征（数字），从而得到总体的分布</li>
</ul></li>
<li>极大似然估计
<ul>
<li>让样本的联合密度函数在样本值处取最大，从而估计出总体的参数</li>
</ul></li>
<li>置信区间的理解（置信度给定）
<ul>
<li><strong>某个数字落在该数字的置信区间的概率，等于置信度</strong></li>
<li>统计值和总体参数有各自的置信区间，但是两者和置信区间的位置关系是等价对应的</li>
</ul></li>
<li>区间估计的原理
<ul>
<li>首先用统计量的分布（带总体参数），求出统计值的置信区间（带总体参数）</li>
<li>令统计值落在统计值的置信区间内，求出总体参数的置信区间（估计区间）</li>
</ul></li>
<li>假设检验的原理
<ul>
<li>在假设成立的基础上，构造统计量，计算置信区间（估计区间）</li>
<li>根据置信区间，得到拒绝域（实际处理时一般跳过置信区间直接计算拒绝域）</li>
<li>统计值大概率落在统计量的置信区间，小概率落在统计量的拒绝域</li>
<li>小概率事件发生，拒绝原假设，否则接受原假设</li>
</ul></li>
</ul></li>
</ul>
<h2 id="常用统计量">常用统计量</h2>
<ul>
<li>样本均值
<ul>
<li><span class="math inline">\(\overline{X}=\frac{1}{n}\sum\limits_{i=1}^{n}X_i\)</span></li>
</ul></li>
<li>样本方差
<ul>
<li><span class="math inline">\(S^2=\frac{1}{n-1}\sum\limits_{i=1}^n(X_i-\overline{X})^2=\frac{1}{n-1}(\sum\limits_{i=1}^nX_i^2-n\overline{X}^2)\)</span></li>
</ul></li>
<li>样本标准差
<ul>
<li><span class="math inline">\(S=\sqrt{\frac{1}{n-1}\sum\limits_{i=1}^n(X_i-\overline{X})^2}\)</span></li>
</ul></li>
<li>样本<span class="math inline">\(k\)</span>阶原点矩
<ul>
<li><span class="math inline">\(A_k=\frac{1}{n}\sum\limits_{i=1}^nX_i^k,k=1,2\)</span></li>
<li><span class="math inline">\(A_1=\overline{X}\)</span></li>
</ul></li>
<li>样本<span class="math inline">\(k\)</span>阶中心矩
<ul>
<li><span class="math inline">\(B_k=\frac{1}{n}\sum\limits_{i=1}^n(X_i-\overline{X})^k,k=1,2\)</span></li>
<li><span class="math inline">\(B_2=\frac{n-1}{n}S^2\)</span></li>
</ul></li>
<li>第<span class="math inline">\(k\)</span>顺序统计量
<ul>
<li>指的是独立同分布样本<span class="math inline">\(X_1,X_2,\cdots,X_n\)</span>中第<span class="math inline">\(k\)</span>大的样本<span class="math inline">\(X_{(k)}\)</span></li>
<li><span class="math inline">\(X_{(1)}=\min\{X_1,X_2,\cdots,X_n\},X_{(n)}=\max\{X_1,X_2,\cdots,X_n\},\)</span></li>
</ul></li>
</ul>
<h2 id="统计量的数字特征">统计量的数字特征</h2>
<p><em>一般用的总体的数字特征表示</em></p>
<ul>
<li><span class="math inline">\(E(\overline{X})=E(X)\)</span></li>
<li><span class="math inline">\(D(\overline{X})=\frac{D(X)}{n}\)</span></li>
<li><span class="math inline">\(E(S^2)=D(X)\)</span></li>
<li><span class="math inline">\(A_k\stackrel{P}\longrightarrow
E(X^k)\)</span>
<ul>
<li>本条指统计量依概率收敛域总体的某个数字特征</li>
</ul></li>
</ul>
<h2 id="常见抽样分布">常见抽样分布</h2>
<p><em>即统计量的分布</em></p>
<h3 id="正态分布">正态分布</h3>
<ul>
<li>定义和性质
<ul>
<li>第二章介绍过</li>
</ul></li>
<li>标准正态分布的上<span class="math inline">\(\alpha\)</span>分位点
<ul>
<li><span class="math inline">\(\mu_{\alpha}\)</span></li>
</ul></li>
</ul>
<h3 id="卡方分布">卡方分布</h3>
<ul>
<li>定义
<ul>
<li><span class="math inline">\(X_i\stackrel{i.i.d}\sim
N(0,1)\Rightarrow X_1^2+\cdots+X_n^2\sim \chi^2(n)\)</span></li>
<li><span class="math inline">\(n\)</span>为卡方分布的自由度</li>
</ul></li>
<li>卡方分布的上<span class="math inline">\(\alpha\)</span>分位点
<ul>
<li><span class="math inline">\(\chi^2_\alpha(n)\)</span></li>
</ul></li>
<li>性质
<ul>
<li><span class="math inline">\(X_1\sim \chi^2(n_1),X_2\sim
\chi^2(n_2)\)</span>且两者独立，则<span class="math inline">\(X_1+X_2\sim \chi^2(n_1+n_2)\)</span></li>
<li><span class="math inline">\(X\sim \chi^2(n)\Rightarrow
E(X)=n,D(X)=2n\)</span></li>
</ul></li>
</ul>
<h3 id="学生分布">学生分布</h3>
<ul>
<li>定义
<ul>
<li><span class="math inline">\(X\sim N(0,1),Y\sim
\chi^2(n)\)</span>且两者独立，则<span class="math inline">\(T=\frac{X}{\sqrt{\frac{Y}{n}}}\sim
t(n)\)</span></li>
<li><span class="math inline">\(n\)</span>是学生分布的自由度</li>
</ul></li>
<li>学生分布的上<span class="math inline">\(\alpha\)</span>分位点
<ul>
<li><span class="math inline">\(t_\alpha(n)\)</span></li>
</ul></li>
<li>性质
<ul>
<li>密度函数为偶函数
<ul>
<li><span class="math inline">\(t_\alpha(n)=-
t_{1-\alpha}(n)\)</span></li>
<li><span class="math inline">\(E(T)=0\)</span></li>
</ul></li>
<li><span class="math inline">\(n\)</span>很大时，<span class="math inline">\(T\)</span>近似是<span class="math inline">\(N(0,1)\)</span>
<ul>
<li>利用<span class="math inline">\(\frac{Y}{n}\stackrel{P}\longrightarrow
E(X^2)=E(X)^2+D(X)=1+0\)</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="f分布">F分布</h3>
<ul>
<li>定义
<ul>
<li><span class="math inline">\(X\sim \chi^2(n_1),Y\sim
\chi^2(n_2)\)</span>且两者独立，则<span class="math inline">\(F=\frac{\frac{X}{n_1}}{\frac{Y}{n_2}}\sim
F(n_1,n_2)\)</span></li>
<li><span class="math inline">\(n_1,n_2\)</span>是<span class="math inline">\(F\)</span>分布第一自由度和第二自由度</li>
</ul></li>
<li><span class="math inline">\(F\)</span>分布的上<span class="math inline">\(\alpha\)</span>分位点
<ul>
<li><span class="math inline">\(F_\alpha(n1,n_2)\)</span></li>
</ul></li>
<li>性质
<ul>
<li><span class="math inline">\(\frac{1}{F}\sim F(n_2,n_1)\)</span></li>
<li><span class="math inline">\(F_\alpha(n_1,n_2)=\frac{1}{F_{1-\alpha}(n_2,n_1)}\)</span></li>
<li><span class="math inline">\(T\sim t(n)\Rightarrow T^2\sim
F(1,n)\)</span></li>
</ul></li>
</ul>
<h2 id="正态总体的抽样分布">正态总体的抽样分布</h2>
<p><em>即总体满足标准正态分布时，各统计量满足的分布</em> ###
一个正态总体 已知总体<span class="math inline">\(X\)</span>满足<span class="math inline">\(X\sim N(\mu,\sigma^2)\)</span>，则</p>
<ul>
<li>样本均值<span class="math inline">\(\overline{X}\)</span>和样本方差<span class="math inline">\(S^2\)</span>独立</li>
<li>统计量<span class="math inline">\(U=\frac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}\)</span>
<ul>
<li>分布
<ul>
<li><span class="math inline">\(U\sim N(0,1)\)</span></li>
</ul></li>
<li>原理
<ul>
<li><span class="math inline">\(\overline{X}\sim
N(\mu,\frac{\sigma^2}{n})\)</span></li>
<li>正态分布的标准化</li>
</ul></li>
</ul></li>
<li>统计量<span class="math inline">\(\chi_n^2=\sum\limits_{i=1}^n(\frac{X_i-\mu}{\sigma})^2\)</span>
<ul>
<li>分布
<ul>
<li><span class="math inline">\(\chi_n^2\sim \chi^2(n)\)</span></li>
</ul></li>
<li>原理
<ul>
<li><span class="math inline">\(\frac{X_i-\mu}{\sigma}\sim
N(0,1)\)</span></li>
<li>卡方分布的定义</li>
</ul></li>
</ul></li>
<li>统计量<span class="math inline">\(\chi_{n-1}^2=\frac{(n-1)S^2}{\sigma^2}=\sum\limits_{i=1}^n(\frac{X_i-\overline{X}}{\sigma})^2\)</span>
<ul>
<li>分布
<ul>
<li><span class="math inline">\(\chi_{n-1}^2\sim
\chi^2(n-1)\)</span></li>
</ul></li>
<li>原理
<ul>
<li><span class="math inline">\(\chi_{n-1}^2\)</span>比<span class="math inline">\(\chi_{n}^2\)</span>自由度少1</li>
</ul></li>
</ul></li>
<li>统计量<span class="math inline">\(T=\frac{\overline{X}-\mu}{\frac{S}{\sqrt{n}}}\)</span>
<ul>
<li>分布
<ul>
<li><span class="math inline">\(T\sim t(n-1)\)</span></li>
</ul></li>
<li>原理
<ul>
<li><span class="math inline">\(T=\frac{U}{\sqrt{\frac{\chi_{n-1}^2}{n-1}}}\)</span></li>
<li><span class="math inline">\(t\)</span>分布的定义</li>
</ul></li>
</ul></li>
<li>统计量<span class="math inline">\(F=\frac{n(\overline{X}-\mu)^2}{S^2}\)</span>
<ul>
<li>分布
<ul>
<li><span class="math inline">\(F\sim F(1,n-1)\)</span></li>
</ul></li>
<li>原理
<ul>
<li><span class="math inline">\(F=T^2\)</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="两个正态总体">两个正态总体</h3>
<p>已知总体<span class="math inline">\(X\)</span>满足<span class="math inline">\(X\sim N(\mu_1,\sigma_1^2)\)</span>，总体<span class="math inline">\(Y\)</span>满足<span class="math inline">\(Y\sim
N(\mu_2,\sigma_2^2)\)</span></p>
<ul>
<li><span class="math inline">\(\overline{X},\overline{Y},S_1^2,S_2^2\)</span>相互独立</li>
<li>统计量<span class="math inline">\(U=\frac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{\sqrt{\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2}}}\)</span>
<ul>
<li>分布
<ul>
<li><span class="math inline">\(U\sim N(0,1)\)</span></li>
</ul></li>
<li>原理
<ul>
<li><span class="math inline">\(\overline{X}-\overline{Y}\sim
N(\mu_1-\mu_2,\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2})\)</span></li>
<li>正态分布的标准化</li>
</ul></li>
</ul></li>
<li>统计量<span class="math inline">\(\chi^2=\frac{(n_1-1)S_1^2}{\sigma_1}+\frac{(n_2-1)S_2^2}{\sigma_2}\)</span>
<ul>
<li>分布
<ul>
<li><span class="math inline">\(\chi^2\sim \chi(n_1+n_2-2)\)</span></li>
</ul></li>
<li>原理
<ul>
<li><span class="math inline">\(\frac{(n_1-1)S_1^2}{\sigma_1}\sim
\chi^2(n_1-1),\frac{(n_2-1)S_2^2}{\sigma_2}\sim
\chi^2(n_2-1)\)</span></li>
<li>卡方分布的性质</li>
</ul></li>
</ul></li>
<li>当<span class="math inline">\(\sigma_1=\sigma_2=\sigma\)</span>，统计量<span class="math inline">\(T=\frac{U}{\sqrt{\frac{\chi^2}{n_1+n_2-2}}}\)</span>
<ul>
<li>分布
<ul>
<li><span class="math inline">\(T\sim t(n_1+n_2-2)\)</span></li>
</ul></li>
<li>原理
<ul>
<li><span class="math inline">\(t\)</span>分布的定义</li>
</ul></li>
</ul></li>
<li>统计量<span class="math inline">\(F=\frac{\frac{S_1^2}{\sigma_1^2}}{\frac{S_2^2}{\sigma_2^2}}\)</span>
<ul>
<li>分布
<ul>
<li><span class="math inline">\(F\sim F(n_1-1,n_2-1)\)</span></li>
</ul></li>
<li>原理
<ul>
<li><span class="math inline">\(\frac{(n_1-1)S_1^2}{\sigma_1}\sim
\chi^2(n_1-1),\frac{(n_2-1)S_2^2}{\sigma_2}\sim
\chi^2(n_2-1)\)</span></li>
<li><span class="math inline">\(F\)</span>分布的定义</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>概率论与数理统计</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第七章-参数估计</title>
    <url>/2021/12/05/ProbabilityAndStatistics7/</url>
    <content><![CDATA[<ul>
<li>本知识总结不提供完整的理论体系汇总，旨在给出<em>概念的理解</em>以及<em>各类问题的思考框架</em>。</li>
<li>笔记为个人整理，禁止商业用途</li>
<li>如有疏漏，欢迎留言</li>
</ul>
<p><em>本章旨在根据抽样结果，对总体分布函数中的参数值进行估计</em></p>
<h2 id="点估计">点估计</h2>
<h3 id="矩估计法">矩估计法</h3>
<ul>
<li>估计量
<ul>
<li>作为参数的估计结果的统计量</li>
</ul></li>
<li>估计值
<ul>
<li>估计量的观测值</li>
</ul></li>
<li>步骤
<ul>
<li>令<strong>样本原点矩的观测值</strong>等于<strong>总体分布的原点矩</strong>（实际不一定相等，只是估计）</li>
<li>几个未知参数就列几个等式，从一阶原点矩开始列有效等式（等式右侧必须包含参数才有效），然后解方程</li>
<li>参数<span class="math inline">\(\theta\)</span>的估计结果要写成<span class="math inline">\(\hat{\theta}\)</span>，并注意是矩估计量还是矩估计值</li>
</ul></li>
</ul>
<h3 id="极大似然估计法">极大似然估计法</h3>
<ul>
<li>本质
<ul>
<li>求参数为多少时，样本值出现的概率（或样本联合密度）最大</li>
</ul></li>
<li>步骤
<ul>
<li>求似然函数
<ul>
<li>离散型总体：<span class="math inline">\(L(\theta)=\prod\limits_{i=1}^nP(x_i;\theta)\)</span></li>
<li>连续型总体：<span class="math inline">\(L(\theta)=\prod\limits_{i=1}^nf(x_i;\theta)\)</span></li>
</ul></li>
<li>似然函数取对数
<ul>
<li>变成累加的形式</li>
</ul></li>
<li>求最大值对应的参数值
<ul>
<li>一般令偏导为0即可</li>
<li>似然函数单调时，按定义求最值</li>
<li>似然函数常数时，按定义求最值，估计值不一定唯一</li>
</ul></li>
<li>参数<span class="math inline">\(\theta\)</span>的估计结果要写成<span class="math inline">\(\hat{\theta}\)</span>，并注意是极大似然估计量还是估计值</li>
</ul></li>
<li>原理
<ul>
<li>设<span class="math inline">\(X_1,X_2,\cdots,X_n\)</span>表示样本随机变量，<span class="math inline">\(x_1,x_2,\cdots,x_n\)</span>表示样本值</li>
<li><span class="math inline">\(\hat{\theta}=\arg\max\limits_{\theta_j}P\{\theta=\theta_j|X_1=x_1,\cdots,X_n=x_n\}\)</span></li>
<li>即<span class="math inline">\(\hat{\theta}=\arg\max\limits_{\theta_j}\frac{P\{\theta=\theta_j\}P\{X_1=x_1,\cdots,X_n=x_n|\theta=\theta_j\}}{P\{X_1=x_1,\cdots,X_n=x_n\}}\)</span></li>
<li>先验情况认为<span class="math inline">\(\theta\)</span>是均匀分布，则<span class="math inline">\(\hat{\theta}=\arg\max\limits_{\theta_j}P\{X_1=x_1,\cdots,X_n=x_n|\theta=\theta_j\}\)</span></li>
</ul></li>
<li>不变性原理
<ul>
<li>若求的是<span class="math inline">\(u=g(\theta)\)</span>的极大似然估计，必须存在单值反函数<span class="math inline">\(\theta=g^{-1}(u)\)</span>，此时<span class="math inline">\(\hat{u}=g(\hat{\theta})\)</span></li>
</ul></li>
</ul>
<h3 id="估计量的评价">估计量的评价</h3>
<p><em>主要考虑估计量的数字特征的性质</em></p>
<ul>
<li>无偏估计量
<ul>
<li>估计量的期望等于参数</li>
</ul></li>
<li>更有效估计量
<ul>
<li>估计量的方差更小</li>
</ul></li>
<li>一致估计量（相合估计量）
<ul>
<li>估计量依概率收敛于参数</li>
<li>可以计算估计量的方差，然后利用切比雪夫不等式来证明依概率收敛</li>
</ul></li>
</ul>
<h2 id="区间估计">区间估计</h2>
<ul>
<li>显著性水平
<ul>
<li>接近0的正数<span class="math inline">\(\alpha\)</span></li>
</ul></li>
<li>置信度
<ul>
<li>接近1的正数<span class="math inline">\(1-\alpha\)</span></li>
</ul></li>
<li>步骤
<ul>
<li>根据已知条件，构造分布合适的带参数统计量
<ul>
<li>构造主要考虑常见的抽样分布</li>
</ul></li>
<li>计算该统计量的带参数置信区间
<ul>
<li>默认情况区间是对称的，两端有界</li>
<li>单侧置信区间不对称，一端有界</li>
<li>说明统计值在该区间的概率是置信度</li>
</ul></li>
<li>计算参数的带统计值的置信区间
<ul>
<li>说明参数落在该区间的概率是置信度</li>
</ul></li>
<li>该区间就是参数的估计区间</li>
</ul></li>
<li>统计量构造记忆
<ul>
<li>单正态总体
<ul>
<li><span class="math inline">\(U=\frac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}\)</span>：总体方差已知求总体均值</li>
<li><span class="math inline">\(\chi_{n-1}^2=\frac{(n-1)S^2}{\sigma^2}\)</span>：求总体方差</li>
<li><span class="math inline">\(T=\frac{\overline{X}-\mu}{\frac{S}{\sqrt{n}}}\)</span>：总体方差未知求总体均值</li>
</ul></li>
<li>双正态总体
<ul>
<li><span class="math inline">\(U=\frac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{\sqrt{\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2}}}\)</span>：总体方差已知，求总体均值的差</li>
<li><span class="math inline">\(T=\frac{U}{\sqrt{\frac{\frac{(n_1-1)S_1^2}{\sigma_1}+\frac{(n_2-1)S_2^2}{\sigma_2}}{n_1+n_2-2}}}\)</span>：总体方差未知但相等时，求总体均值的差</li>
<li><span class="math inline">\(F=\frac{\frac{S_1^2}{\sigma_1^2}}{\frac{S_2^2}{\sigma_2^2}}\)</span>：求总体方差的比值</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>概率论与数理统计</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第八章-假设检验</title>
    <url>/2021/12/05/ProbabilityAndStatistics8/</url>
    <content><![CDATA[<ul>
<li>本知识总结不提供完整的理论体系汇总，旨在给出<em>概念的理解</em>以及<em>各类问题的思考框架</em>。</li>
<li>笔记为个人整理，禁止商业用途</li>
<li>如有疏漏，欢迎留言</li>
</ul>
<h2 id="假设类型">假设类型</h2>
<ul>
<li>参数假设
<ul>
<li>对总体分布函数的未知参数进行假设</li>
</ul></li>
<li>非参数假设
<ul>
<li>不是参数假设的假设</li>
</ul></li>
<li>简单假设
<ul>
<li>假设后的总体分布确定的假设</li>
</ul></li>
<li>复合假设
<ul>
<li>不算简单假设的假设</li>
</ul></li>
</ul>
<h2 id="错误类型">错误类型</h2>
<ul>
<li>第一类错误
<ul>
<li>原假设正确，但被推翻（拒绝）</li>
<li>优先保证不犯第一类错误</li>
</ul></li>
<li>第二类错误
<ul>
<li>原假设错误，但被接受</li>
</ul></li>
</ul>
<h2 id="显著性检验">显著性检验</h2>
<ul>
<li>显著性水平<span class="math inline">\(0&lt;\alpha&lt;1\)</span>
<ul>
<li>犯第一类错误的概率</li>
<li>让<span class="math inline">\(\alpha\)</span>尽量小，使得第一类错误概率小</li>
</ul></li>
<li>显著性检验
<ul>
<li>行为：出现小概率事件才推翻原假设，否则接收原假设</li>
<li>基调：<span class="math inline">\(\alpha\)</span>越小，越谨慎的推翻原假设，越保护原假设</li>
<li>效果：<span class="math inline">\(\alpha\)</span>越小，第一类错误的概率越小，但第二类错误的概率有可能增大</li>
</ul></li>
<li>置信区间
<ul>
<li>统计值落在置信区间的概率等于置信度<span class="math inline">\(1-\alpha\)</span></li>
<li>参数落在置信区间的概率等于置信度<span class="math inline">\(1-\alpha\)</span></li>
<li>注：参数估计先求统计值的置信区间，再求参数的置信区间</li>
</ul></li>
<li>拒绝域
<ul>
<li>统计值落在拒绝域的概率等于显著性水平<span class="math inline">\(\alpha\)</span></li>
<li>参数落在拒绝域的概率等于显著性水平<span class="math inline">\(\alpha\)</span></li>
<li>注：假设检验先求统计值的拒绝域，再求参数的拒绝域</li>
</ul></li>
<li>步骤
<ul>
<li>提出原假设
<ul>
<li>原假设带有等号，对立假设不带有等号，因此如果检验的不等式带等号，则原假设待检验不等式，否则对立假设为待检验不等式</li>
</ul></li>
<li>给出显著性水平</li>
<li>在假设下<strong>构造合适分布的统计量</strong>并<strong>确定统计量的拒绝域形式</strong>
<ul>
<li>构造的统计量一般是第六章的几个抽样分布，并代入原假设条件（<strong>一律用等式条件</strong>）</li>
<li>拒绝域形式取决于对立假设</li>
</ul></li>
<li>查表得到统计量的拒绝域</li>
<li>计算统计值，判断统计值是否落在统计值拒绝域
<ul>
<li>也可以通过统计量的拒绝域，得到参数的拒绝域，从而判断参数是否落在参数的拒绝域</li>
</ul></li>
<li>落在拒绝域代表发生小概率事件，拒绝原假设，否则接受。</li>
</ul></li>
</ul>
<h2 id="正态总体参数的显著性检验">正态总体参数的显著性检验</h2>
<ul>
<li>统计量构造记忆
<ul>
<li>单正态总体
<ul>
<li><span class="math inline">\(U=\frac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}\)</span>：总体方差已知时，对总体均值检验</li>
<li><span class="math inline">\(\chi_n^2=\sum\limits_{i=1}^n(\frac{X_i-\mu}{\sigma})^2\)</span>：总体均值已知，对总体方差的检验</li>
<li><span class="math inline">\(\chi_{n-1}^2=\frac{(n-1)S^2}{\sigma^2}=\sum\limits_{i=1}^n(\frac{X_i-\overline{X}}{\sigma})^2\)</span>：总体的均值未知，对总体方差的检验</li>
<li><span class="math inline">\(T=\frac{\overline{X}-\mu}{\frac{S}{\sqrt{n}}}\)</span>：总体的方差未知，对总体的均值检验</li>
</ul></li>
<li>双正态总体
<ul>
<li><span class="math inline">\(U=\frac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{\sqrt{\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2}}}\)</span>：总体的方差已知，比较总体的均值</li>
<li><span class="math inline">\(T=\frac{U}{\sqrt{\frac{\frac{(n_1-1)S_1^2}{\sigma_1}+\frac{(n_2-1)S_2^2}{\sigma_2}}{n_1+n_2-2}}}\)</span>：总体的方差未知但相等，比较总体的均值</li>
<li><span class="math inline">\(F=\frac{n_2\sum\limits_{i=1}^{n_1}(\frac{X_i-\mu_1}{\sigma_1})^2}{n_1\sum\limits_{i=1}^{n_2}(\frac{X_i-\mu_2}{\sigma_2})^2}\)</span>：总体均值已知，比较总体方差</li>
<li><span class="math inline">\(F=\frac{\frac{S_1^2}{\sigma_1^2}}{\frac{S_2^2}{\sigma_2^2}}\)</span>：总体均值未知，比较总体方差</li>
</ul></li>
</ul></li>
<li>拒绝域形式记忆
<ul>
<li>当对立假设是不等号
<ul>
<li>拒绝域是双侧的，一般用<span class="math inline">\(\frac{\alpha}{2}\)</span>分位点和<span class="math inline">\(1-\frac{\alpha}{2}\)</span>分位点</li>
</ul></li>
<li>当对立假设是大于号
<ul>
<li>拒绝域有单侧下界，一般用<span class="math inline">\(\alpha\)</span>分位点</li>
</ul></li>
<li>当对立假设是小于号
<ul>
<li>拒绝域有单侧上界，一般用<span class="math inline">\(1-\alpha\)</span>分位点</li>
</ul></li>
</ul></li>
</ul>
<h2 id="双正态规约为单正态">双正态规约为单正态</h2>
<ul>
<li>对于相互独立的两个正态总体，总体方差未知的情况，比较总体的均值
<ul>
<li>正常情况：先验证方差相等，然后在方差未知且相等的情况下，比较总体均值</li>
<li>特殊情况：当两个总体的样本容量相同，把样本作差构造出单正态总体的样本，转换为单正态总体的假设检验，在总体方差未知的情况，用<span class="math inline">\(t\)</span>分布检验总体均值是否为0</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>概率论与数理统计</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【习题解答】 题解勘误</title>
    <url>/2021/07/03/algorithms-revision/</url>
    <content><![CDATA[<h2 id="section">8.28</h2>
<p>第六问的复杂度和正确性部分，把第三行的图中“每个顶点，其能到达的顶点都是标记的”改完“每个标记的顶点，其能到达的顶点都是标记的”</p>
<h2 id="section-1">9.11</h2>
<p>对于书上的109页算法，一方面要修改第3行的判断条件；另一方面在第7-10行关于邻点的处理完成后还要再进行非邻点的处理。复杂度是O(V^2)的。</p>
<h2 id="section-2">12.2</h2>
<p>“每次选择与“最短路径树”相邻的且capcity值最小的点”改为“每次选择与“最短路径树”相邻的且capcity值最大的点”</p>
<h2 id="section-3">20.5</h2>
<ul>
<li>本题使用q算法解决p问题，注意到p随着调用的嵌套是一个变动的值；q是一个固定值，因为q是算法是已知算法</li>
<li>如果删除至还剩余k个元素，且k小于q时，此时q算法无法被调用。但此时还需要<span class="math inline">\(O(q^2)\)</span>的固定代价额外处理即可</li>
</ul>
<h2 id="section-4">21.5</h2>
<p>第2问状态转移方程改成<span class="math inline">\(dp[i][w] =
\max\{dp[i-1][w],\ dp[i-1][w - wt[i]] + val[i]\}\)</span></p>
<p><strong>勘误致谢（字母序）：ljw、枸杞（匿名群昵称）、zyb、zjj、zzh</strong></p>
<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>
]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Problem Set Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>【习题解答】 抽象算法设计与分析</title>
    <url>/2021/03/19/algorithms1-hw/</url>
    <content><![CDATA[<p><strong><em>注：</em></strong>
<em>本题解为个人完成，难免有疏漏，请勿抄袭，仅供参考，同时欢迎留言指正。</em>
##1.1 ###(1) 算法设计 <img src="/2021/03/19/algorithms1-hw/1_1.jpg" class title="this is algorithms"> ###(2)
本问针对个人设计的算法，假设所有输入等可能出现，则： + 有<span class="math inline">\(\frac{1}{3}\)</span>可能性, <span class="math inline">\(D[2]\)</span>序最大, 进行第2、5行比较; + 有<span class="math inline">\(\frac{2}{3}\)</span>可能性, <span class="math inline">\(D[2]\)</span>序不为最大, 进行第2、5、7行比较;</p>
<p><strong>最坏情况</strong> 需要进行3次比较。 <strong>平均情况</strong>
需要进行<span class="math inline">\(\frac{1}{3}\times 2 +\frac{2}{3}
\times 3=\frac{8}{3}\)</span>次比较</p>
<p>###(3) 本问求最坏情况(面向所有输入)比较次数的下界(面向所有算法)。
即<span class="math inline">\(\min\limits_{method}\max\limits_{in}
cost(method,in)\)</span></p>
<p>易得结果为3次，下面给出严格证明，分为两个步骤： +
存在一个可行算法，使得最坏输入情况的比较次数等于3; +
不存在一个可行的算法，最坏输入情况的比较次数都小于3。</p>
<p>前者用举例证明：如第1小问设计的算法，最坏情况的比较次数就是3;
后者用反证法：假设某可行算法进行了不到3次比较，通过改变输入，可以使得3个整数中至少有1对整数之间的序关系是未知的，那么就需要进行3次比较，产生矛盾。因此后者得证。
<strong>综合上述，最坏情况比较次数的下界为3次。</strong></p>
<p>##1.2 <em>本题和1.1非常类似，只需要进行略微的修改即可。</em> ###(1)
算法设计 <img src="/2021/03/19/algorithms1-hw/1_2.jpg" class title="this is algorithms"> ###(2)
本问针对个人设计的算法，假设所有输入等可能出现，则： + 有<span class="math inline">\(\frac{1}{3}\)</span>可能性, <span class="math inline">\(D[2]\)</span>序最大, 进行第2、5行比较; + 有<span class="math inline">\(\frac{2}{3}\)</span>可能性, <span class="math inline">\(D[2]\)</span>序不为最大, 进行第2、5、7行比较;</p>
<p><strong>最坏情况</strong> 需要进行3次比较。 <strong>平均情况</strong>
需要进行<span class="math inline">\(\frac{1}{3}\times 2 +\frac{2}{3}
\times 3=\frac{8}{3}\)</span>次比较</p>
<p>###(3) 本问求最坏情况(面向所有输入)比较次数的下界(面向所有算法)。
即<span class="math inline">\(\min\limits_{method}\max\limits_{in}
cost(method,in)\)</span></p>
<p>易得结果为3次，下面给出严格证明，分为两个步骤： +
存在一个可行算法，使得最坏输入情况的比较次数等于3; +
不存在一个可行的算法，最坏输入情况的比较次数都小于3。</p>
<p>前者用举例证明：如第1小问设计的算法，最坏情况的比较次数就是3;
后者用反证法：假设某可行算法进行了不到3次比较，通过改变输入，可以使得<strong>3个整数中至少有1对整数之间的序关系是未知的</strong>，那么不能确定中位数。
具体而言对于a、b、c三个数： (i)
若已知1对序关系(a,b)，那么不能确定中位数； (ii)
若已知2对序关系(a,b)和(a,c)，这两对序关系必然相同,否则(b,c)的序关系就可知,故不能确定中位数。
那么就需要进行3次比较，产生矛盾。因此后者得证。
<strong>综合上述，最坏情况比较次数的下界为3次。</strong></p>
<p>##1.3 ###(1) 答：例如全集<span class="math inline">\(U=\{1,2,3,4,5,6\}\)</span>，子集<span class="math inline">\(S_1=\{1,2,3,4\}\)</span>、<span class="math inline">\(S_2=\{1,2,3\}\)</span>、<span class="math inline">\(S_3=\{4,5,6\}\)</span>、<span class="math inline">\(S_4=\{5\}\)</span>、<span class="math inline">\(S_5=\{6\}\)</span>。按这个算法最后找到的最小覆盖是<span class="math inline">\(\{S_1,S_4,S_5\}\)</span>。但正确的最小覆盖是<span class="math inline">\(\{S_2,S_3\}\)</span>。</p>
<p>###(2)
<em>最小集合覆盖是一个NP问题，这里就简单给出一种集合覆盖的求法，答案不唯一</em>
<img src="/2021/03/19/algorithms1-hw/1_3.jpg" class title="this is algorithms"></p>
<p><strong>正确性证明</strong>： 如果集合族<span class="math inline">\(S\)</span>是<span class="math inline">\(U\)</span>的一个覆盖，即<span class="math inline">\(\bigcup\limits_{S_i\in
S}S_i=U\)</span>，那么算法中的if语句满足，那么将会返回S，显然求得了一个集合覆盖;</p>
<p>如果集合族<span class="math inline">\(S\)</span>不是<span class="math inline">\(U\)</span>的一个覆盖，那么算法中的if语句不满足，else块将被运行,同时找不到满足条件的<span class="math inline">\(T\subseteq S\)</span>，使得<span class="math inline">\(\bigcup\limits_{S_i\in T}S_i=U\)</span>(否则<span class="math inline">\(S\)</span>是<span class="math inline">\(U\)</span>的覆盖，产生矛盾)。因此不存在集合覆盖，算法将报错退出，符合预期。</p>
<p>###(3) 答：不能保证得到最小覆盖，例如全集<span class="math inline">\(U=\{1,2,3,4,5\}\)</span>，子集<span class="math inline">\(S_1=\{1,3,5\}\)</span>、<span class="math inline">\(S_2=\{2,4\}\)</span>、<span class="math inline">\(S_3=\{1,4\}\)</span>、<span class="math inline">\(S_4=\{2,5\}\)</span>。按这个算法最后找到的覆盖是<span class="math inline">\(\{S_1,S_2,S_3,S_4\}\)</span>。但最小覆盖是<span class="math inline">\(\{S_1,S_2\}\)</span>。</p>
<p>##1.4 1)的算法描述 <img src="/2021/03/19/algorithms1-hw/1_4_1.jpg" class title="this is algorithms"> 2)的算法描述 <img src="/2021/03/19/algorithms1-hw/1_4_2.jpg" class title="this is algorithms">
3)的算法描述 <img src="/2021/03/19/algorithms1-hw/1_4_3.jpg" class title="this is algorithms"></p>
<p><strong>反例</strong>： 例如<span class="math inline">\(n=4\)</span>,<span class="math inline">\(S=\{5,1,10,100\}\)</span>,T=101，上述三个算法都找不到满足要求的硬币集合，但是存在集合{1,100}满足要求。</p>
<p>##1.5 <em>本题很经典，可以考虑如果用状态机来解决，要怎么画</em>
算法设计 <img src="/2021/03/19/algorithms1-hw/1_5.jpg" class title="this is algorithms"> <strong>正确性证明</strong> (1)当<span class="math inline">\(N=8\)</span>的时候，程序返回第三个return，即a=1和b=1，算法正确工作。</p>
<p>(2)设当<span class="math inline">\(N=5+3k(k\in
N+)\)</span>的时候，程序正确，即从第三个return中返回了a=k和b=1,那么当<span class="math inline">\(N=5+3k+3\)</span>的时候，程序还是返回第三个return，返回值是a=k+1,b=1，程序正确。</p>
<p>(3)故对于任意<span class="math inline">\(N=5+3n(n\in
N+)\)</span>，程序都正确</p>
<p>以上证明了模3等于2的所有正整数<span class="math inline">\(N(N\geq
8)\)</span>的正确性，模3等于1和0的情况同理，从略。</p>
<p>本题证明核心是使用<strong>数学归纳法</strong>。</p>
<p>##1.6
<em>注意本题并不是指KMP算法的next，而是在下一页附上了算法的内容。</em>
证明： (1)当<span class="math inline">\(n=0\)</span>时，后继是1显然算法正确；</p>
<p>(2)当<span class="math inline">\(n=2k(k\geq 0,k\in
Z)\)</span>时,算法返回2n+1,显然也正确；</p>
<p>(3)若<span class="math inline">\(n=2k(k\geq 0,k\in
Z)\)</span>时算法正确，则<span class="math inline">\(n=2k+1\)</span>时,算法返回<span class="math inline">\(2\times(1+\lfloor\frac{2k+1}{2}\rfloor)\)</span>,也就是<span class="math inline">\(2\times(1+k)=2k+2\)</span>,故此时算法正确</p>
<p>(4)故对任意非负整数<span class="math inline">\(n\)</span>，显然算法都正确。</p>
<p>##1.7
<em>本题证明的核心还是归纳推理，但是和数学归纳法不同，本题的推理是有限回合的，也就是利用循环不变式进行证明</em>
我们先观察一下每次循环的结果(<strong>注意!
我们要通过观察找循环不变式！</strong>)： +
当3-4行的for循环第1次执行的开始，<span class="math inline">\(p=a_n\)</span> +
当3-4行的for循环第2次执行的开始，<span class="math inline">\(p=a_nx+a_{n-1}\)</span> +
当3-4行的for循环第3次执行的开始，<span class="math inline">\(p=a_nx^2+a_{n-1}x+a_{n-2}\)</span>
那么通过观察归纳，for循环第j次执行(j=1,2,3...,n)的开始时：</p>
<p><span class="math inline">\(p=a_nx^{j-1}+a_{n-1}x^{j-2}+\cdots+a_{n-j+1}x^0\)</span>，</p>
<p>而j=n-i
(i是循环变量，i=n-1,n-2,..,0)，那么用i来替换j以表示p，我们就知道了循环不变式是</p>
<p><span class="math inline">\(p=a_nx^{n-i-1}+a_{n-1}x^{n-i-2}+\cdots+a_{i+1}x^0=\sum\limits_{k=0}^{n-(i+1)}a_{k+i+1}x^k\)</span></p>
<p>也就是说循环开始时，根据循环变量i，循环不变式p都是上述的形式，<strong>上述都是心里活动，下面就是用循环不变式证明算法正确性的标准三步走格式</strong>。</p>
<p>(1)<strong>初始化</strong>：<span class="math inline">\(i=n-1,p=a_n=\sum\limits_{k=0}^{0}a_{k+n}x^k\)</span>，显然正确</p>
<p>(2)<strong>保持</strong>：当前循环开始时满足循环不变式<span class="math inline">\(p=\sum\limits_{k=0}^{n-(i+1)}a_{k+i+1}x^k\)</span>，</p>
<p>经过循环体运算后，<span class="math inline">\(p=x[\sum\limits_{k=0}^{n-(i+1)}a_{k+i+1}x^k]+a_i=\sum\limits_{k=0}^{n-[(i-1)+1]}a_{k+(i-1)+1}x^k\)</span></p>
<p>那么下一轮刚开始的时候，i会自减1，故循环不变式<span class="math inline">\(p=\sum\limits_{k=0}^{n-(i+1)}a_{k+i+1}x^k\)</span>仍然满足。</p>
<p>(3)<strong>终止</strong>：当i为0，最后一次循环开始时，有循环不变式<span class="math inline">\(p=\sum\limits_{k=0}^{n-1}a_{k+1}x^k\)</span>，故最后一次循环结束后，<span class="math inline">\(p=x[\sum\limits_{k=0}^{n-1}a_{k+1}x^k]+a_0=\sum\limits_{k=0}^{n}a_{k}x^k\)</span>，显然返回值p就是我们希望的值。</p>
<p>故算法正确。</p>
<p><em>注：关于循环不变式的内容，可以参考算法导论第二章2.1的内容，本题是算导原题，即习题2.3</em></p>
<p>##1.8 不妨直接证第二问，也就是说当<span class="math inline">\(c\geq2,c\in
Z\)</span>，证明算法正确。那么考虑对<span class="math inline">\(z\)</span>进行<strong>强数学归纳法</strong>。</p>
<p>(1)当<span class="math inline">\(z=0\)</span>，显然返回<span class="math inline">\(y\times z=0\)</span>正确</p>
<p>(2)假设<span class="math inline">\(z=0,1,2..,k\)</span>(<span class="math inline">\(k\)</span>是非负整数)时，算法正确</p>
<p>则对于<span class="math inline">\(z=k+1\)</span>，因为<span class="math inline">\(\lfloor\frac{z}{c}\rfloor&lt;
z\)</span>,则子调用INT-MULT正确，则返回<span class="math inline">\(c\times
y\times(\lfloor\frac{z}{c}\rfloor)+y\times(z\ mod\ c)=y\times
[(c\times\lfloor\frac{z}{c}\rfloor)+(z\ mod\
c)]\)</span>,又由数学知识，<span class="math inline">\((c\times\lfloor\frac{z}{c}\rfloor)+(z\ mod\
c)=z\)</span>。故此时返回值为<span class="math inline">\(y\times
z\)</span>，也是正确的。</p>
<p>(3)因此对任意<span class="math inline">\(z=n\)</span>,<span class="math inline">\(n\)</span>是非负整数，算法都正确。</p>
<p>##1.9 题干给的是输入r的概率密度函数，利用积分可以得到： <span class="math inline">\(Pr(r\leq \frac{n}{4})=\frac{1}{4}\)</span>，<span class="math inline">\(Pr(\frac{n}{4} &lt; r\leq
\frac{n}{2})=\frac{1}{2}\)</span>，<span class="math inline">\(Pr(\frac{n}{2} &lt; r\leq
\frac{3n}{4})=\frac{1}{8}\)</span>，<span class="math inline">\(Pr(\frac{3n}{4} &lt; r\leq
\frac{n})=\frac{1}{8}\)</span></p>
<p>故平均情况时间复杂度就是<span class="math inline">\(\frac{1}{4}\times10+\frac{1}{2}\times20+\frac{1}{8}\times30+\frac{1}{8}\times
n=\frac{n}{8}+\frac{65}{4}=O(n)\)</span></p>
<p>##1.10
该算法判断数组中元素是不是没有重复的，没有重复则返回TRUE，有重复返回FALSE。</p>
<ol type="1">
<li>当数组没有重复元素，两层循环全部跑完，返回TRUE的情况，就是最坏情况。复杂度是</li>
</ol>
<p><span class="math inline">\(\sum\limits_{i=0}^{n-2}(n-1-i)=\frac{n(n-1)}{2}=O(n^2)\)</span>。</p>
<ol start="2" type="1">
<li>在给定条件下，两个元素等可能的取n个位置中的两个，每种情况也就是<span class="math inline">\(\frac{1}{C_{n}^2}\)</span>的概率，也可以理解成两层循环的中的每个if生效的概率是相等的。因此平均情况时间复杂度为：</li>
</ol>
<p><span class="math inline">\(\sum\limits_{k=1}^{C_{n}^2}(\frac{1}{C_{n}^2})k=\frac{n^2}{4}-\frac{n}{4}+\frac{1}{2}=O(n^2)\)</span></p>
<ol start="3" type="1">
<li>首先，本题的输入是数组A[0...n-1]，那么输入规模就是n。现在的目标就是求n无穷大的时候，算法平均时间代价的量级。题干给的k认为是一个常数，不属于问题的输入规模。又任意两个数相等的概率是<span class="math inline">\(\frac{1}{k}\)</span>，故从数学期望来看需要的平均比较次数是k。故平均情况时间复杂度是O(k)。但作为答案，这种说法比较粗糙，下面给出个人认为的相对合理的计算方法。</li>
</ol>
<p>假设时间复杂度的主项是<span class="math inline">\(F(n)\)</span>，则:</p>
<p><span class="math inline">\(F(n)=\frac{1}{k}+\frac{k-1}{k}(1+F(n-1))=1+\frac{k-1}{k}F(n-1)\Rightarrow
1=\frac{1}{F(n)}+\frac{k-1}{k}\frac{F(n-1)}{F(n)}\)</span></p>
<p>取极限后，<span class="math inline">\(\lim\limits_{n\rightarrow
\infty}\frac{F(n-1)}{F(n)}=1\)</span></p>
<p>故<span class="math inline">\(\lim\limits_{n\rightarrow
\infty}F(n)=k\)</span></p>
<p>从而时间复杂度是<span class="math inline">\(O(k)\)</span></p>
<p><strong>注</strong>：个人认为如果把k不当作问题的规模，也可以写成O(1)。下面不妨思考一下本题的最坏情况时间复杂度，由抽屉原理，前k+1个数必然有重复的元素，那么最坏情况时间代价就是<span class="math inline">\((n-1)+(n-2)+\cdots+(n-k+1)+1=1+\frac{(2n-k)(k-1)}{2}\)</span>，也就是<span class="math inline">\(O(nk)\)</span>。如果考虑k不是规模，那么也可以认为是<span class="math inline">\(O(n)\)</span>。</p>
<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>
]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Problem Set Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 抽象算法设计与分析</title>
    <url>/2021/01/31/algorithms1/</url>
    <content><![CDATA[<h2 id="ram模型的引入">RAM模型的引入</h2>
<h3 id="计算的基本概念">计算的基本概念</h3>
<ul>
<li>计算的关键特征：基于有限种类操作的灵活组合完成复杂的计算任务</li>
<li>算法的宏观定义：一组计算机操作的序列，遵循算法的指示，计算机对任意合法输入执行一系列操作，并给出正确结果。</li>
</ul>
<h3 id="计算模型的基本概念">计算模型的基本概念</h3>
<ul>
<li>算法掌握的一种抽象原则，与编程语言和机器无关，假设在抽象机器上完成算法设计和分析。</li>
<li>在不同具体机器上实例化算法时，虽然底层提供的基本操作不同，但是总是常数倍的关系，本质相同。</li>
<li>上述的抽象机器就是计算模型，是抽象算法设计与分析的基础。图灵机是描述能力很强的计算模型，对于算法设计分析的基础知识来说，RAM模型更简单易用。</li>
</ul>
<h3 id="ram模型random-access-machine">RAM模型(Random Access
Machine)</h3>
<ul>
<li>组成：输入纸带、输出纸带、存储寄存器、程序指令、位置计数器。</li>
<li>指令的分类：简单操作、复杂操作、存储访问</li>
<li>单位代价RAM和对数代价RAM：前者不管操作数多大都认为单位时间完成，后者认为操作代价和比特数成正比。未说明的情况都是单位代价RAM，特定问题（如背包问题）会显示指出对数代价RAM。</li>
</ul>
<h3 id="计算模型的选择易用性与精确性">计算模型的选择：易用性与精确性</h3>
<ul>
<li>RAM模型：具有易用性，不会给出原则错误，但细节不精确。</li>
<li>外部存储模型：对不同存储介质的不同访问代价精细建模，不像RAM模型认为存储空间是无穷的。</li>
<li>PRAM（Parallel Random Access Machine）模型：刻画并行计算</li>
</ul>
<p>有了RAM模型，我们清楚了需要完成的计算任务（<strong>算法问题</strong>），论证需要何种顺序执行哪些操作才能完成指定任务（<strong>算法设计</strong>），还可以统计完成任务需要的开销（<strong>算法分析</strong>）。</p>
<h2 id="抽象算法设计">抽象算法设计</h2>
<h3 id="算法问题规约">算法问题规约</h3>
<ul>
<li>输入：明确算法的所有合法输入</li>
<li>输出：明确规定对于每个合法输入，相应的输出是什么</li>
</ul>
<h3 id="算法正确性证明数学归纳法">算法正确性证明：数学归纳法</h3>
<p>要证明算法正确性，就是证明对于每个合法输入，算法的输出都满足规约的要求。其中的难点往往是合法的输入是无穷的，无法测试穷举来证明正确性（测试只能证明算法是错的）。证明的手段是数学归纳法。</p>
<p><strong>定义 (弱数学归纳法)</strong>
假设P是一个定义在正整数集合N上的命题。如果： + <span class="math inline">\(P(1)\)</span>为TRUE。 + <span class="math inline">\(\forall k \in N\)</span>, <span class="math inline">\(P(k) \to P(k+1)\)</span>。 则对所有自然数<span class="math inline">\(n\)</span>,<span class="math inline">\(P(n)\)</span>为TRUE。</p>
<p><strong>定义 (强数学归纳法)</strong>
假设P是一个定义在正整数集合N上的命题。如果： + <span class="math inline">\(P(1)\)</span>为TRUE。 + <span class="math inline">\(\forall k \in N\)</span>, <span class="math inline">\(P(1)\wedge P(2)\wedge...\wedge P(k) \to
P(k+1)\)</span>。 则对所有自然数<span class="math inline">\(n\)</span>,
<span class="math inline">\(P(n)\)</span>为TRUE。</p>
<p><strong>定义(良序原理)</strong>
任意非空正整数集合必然有最小元素。</p>
<p>数学归纳法和良序原理本质是等价的。在各自的场景下更加便捷。</p>
<h2 id="抽象算法分析">抽象算法分析</h2>
<p>正确设计算法后，下一步就是分析算法的性能。</p>
<h3 id="抽象算法的性能指标">抽象算法的性能指标</h3>
<ul>
<li>时间复杂度：在RAM模型上执行简单操作的个数,
可以精炼为关键操作的个数</li>
<li>空间复杂度：在RAM模型中需要的寄存器的个数</li>
</ul>
<h3 id="最坏情况时间复杂度分析">最坏情况时间复杂度分析</h3>
<p>对于不同的输入，时间代价不同。给定输入规模，最坏的输入对应最高的时间代价。假设规模为n,
则最坏情况时间复杂度定义为<span class="math inline">\(W(n)=\max\limits_{I \in
D_n}f(I)\)</span>。最坏情况空间复杂度的定义类似。</p>
<h3 id="平均情况时间复杂度分析">平均情况时间复杂度分析</h3>
<p>假设输入服从一个分布，时间复杂度看作一个随机变量，它的期望值就是平均情况时间复杂度。定义为：<span class="math inline">\(A(n)=\sum\limits_{I \in D_n}Pr(I)\cdot
f(I)\)</span></p>
<h3 id="期望情况时间复杂度分析">期望情况时间复杂度分析</h3>
<p>最坏输入情况下的期望时间复杂度，主要针对随机算法的随机数求期望。</p>
<h3 id="平摊时间复杂度分析">平摊时间复杂度分析</h3>
<p>详见第18章的笔记，大概理解就是<strong>用平摊分析法计算出的平均情况时间复杂度。</strong></p>
]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【习题解答】 图优化问题的贪心求解</title>
    <url>/2021/06/09/algorithms10-hw/</url>
    <content><![CDATA[<h2 id="section">10.3</h2>
<ul>
<li><span class="math inline">\(e_1\)</span>一定在</li>
<li>若<span class="math inline">\(e_2\)</span>是<span class="math inline">\(e_1\)</span>的重边则不在</li>
<li>不一定在，可能产生环</li>
</ul>
<h2 id="section-1">10.6</h2>
<ul>
<li>Prim
<ul>
<li>数组实现优先队列：<span class="math inline">\(O(n^2)\)</span></li>
<li>堆实现优先队列-稠密图:<span class="math inline">\(O(n^2log\
n)\)</span></li>
<li>堆实现优先队列-稀疏图：<span class="math inline">\(O(nlog\
n)\)</span></li>
</ul></li>
<li>Kruskal
<ul>
<li>稠密图：<span class="math inline">\(O(n^2log\ n)\)</span></li>
<li>稀疏图：<span class="math inline">\(O(nlog\ n)\)</span></li>
</ul></li>
<li>Prim适合稠密图，Kruskal适合稀疏图</li>
</ul>
<h2 id="section-2">10.10</h2>
<ul>
<li>第一问：不用更新</li>
<li>第二问：在原最小生成树上添加e形成一个环，删除环上最大边</li>
<li>第三问：不用更新</li>
<li>第四问：在原最小生成树上删除e形成两个连通分支。添加连接两个连通分支的权值最小的边</li>
</ul>
<h2 id="section-3">10.13</h2>
<ul>
<li>在Kruskal算法基础上改进</li>
<li>初始化：S中的边全部加入MST，并对S中关联的点依次加入并查集</li>
<li>算法思想：在E-S中依次挑选权重最小且不会产生环的边加入MST</li>
</ul>
<h2 id="section-4">10.14</h2>
<ul>
<li>记e两端点是uv，删除所有权值大于等于e的边。</li>
<li>从u出发搜索v
<ul>
<li>如果能搜到，说明e是某环上唯一的最重边，不可能在最小生成树上</li>
<li>如果搜不到，反设e不在任意最小生成树上，则任意最小生成树加上e都会形成圈，且e是圈上唯一的最重边（否则e和同重的边替换即可得到一个最小生成树）。因此u会搜到v，矛盾。因此e在某个最小生成树上。</li>
</ul></li>
</ul>
<h2 id="section-5">10.15</h2>
<ul>
<li>错，反例是割边</li>
<li>对，环上的唯一最重边不可能属于任何最小生成树。证明用反证法，即假设属于某个MST，则可以把环上那个不在MST的边和最重边替换，还是连通的，且权值更小了。</li>
<li>对，可以分为割边和非割边两种情况讨论</li>
<li>对，可以分为割边和非割边两种情况讨论</li>
<li>错，例如正四面体的平面图，一个三角面的三条边权很大，其他的三条边权很小。</li>
<li>错，例如三角形，边权为2，2，3。</li>
<li>正确，不同于Dijkstra算法</li>
</ul>
<h2 id="section-6">10.16</h2>
<ul>
<li>两个图有着相同的边权大小序</li>
<li>因此例如调用Prim算法，结果一样</li>
</ul>
<h2 id="section-7">10.17</h2>
<ul>
<li>假设G的MST和H的交中的边e不在T的一个MST上</li>
<li>添加e使得H中产生圈</li>
<li>e是圈上最重的边</li>
<li>设e的两端是u、v。在G的MST删除e后，u和v在G的MST的两个不相交点集中。</li>
<li>这两个点集和H交后还是两个不相交点集，又因为H的最小生成树上没有e，但包含u和v，因此必然存在一个边e'，连接着这两个不相交点集。</li>
<li>根据第三行，e'不比e重。若e'比e轻，则把e替换为e'能得到更小的G的MST。所以e和e'同重</li>
<li>把T的MST的e'换成e，得到了T的另一个MST，此时e在该MST上。</li>
<li>即G的MST和H的交中的边e必然在T的某个MST上</li>
</ul>
<h2 id="section-8">10.21</h2>
<ul>
<li>反例：四边形，按上右下左顺序，边权为1，2，1，2</li>
<li>竖直切一刀把其分为左右两个点集，显然算法不正确。</li>
</ul>
<h2 id="section-9">10.23</h2>
<ul>
<li>第一问：生成最小生成树铺设管道，在最小造价的节点打井</li>
<li>第二问
<ul>
<li>想象有一个水源节点，打井的代价可以开作是从水源节点运水的管道代价。</li>
<li>那么问题可以这样转化，新加一个水源节点，连向每个房子。管道造价为原图的打井代价。对新图生成MST。MST上原图有的边对应管道代价，原图没的边对应打井代价。</li>
</ul></li>
</ul>
<h2 id="section-10">10.25</h2>
<ul>
<li>例如ABC三个点，A为起点，B为终点，AB权重为2，BC权重为-2，AC权重为3</li>
<li>dijkstra算法算出最短路径是2，但其实是1</li>
</ul>
<h2 id="section-11">10.27</h2>
<ul>
<li>设负边为<span class="math inline">\(uv\)</span>，权重为<span class="math inline">\(w\)</span></li>
<li>删除<span class="math inline">\(uv\)</span>，以<span class="math inline">\(s\)</span>、<span class="math inline">\(u\)</span>、<span class="math inline">\(v\)</span>为起点，调用三次Dijkstra算法，结果为<span class="math inline">\(dist_s[],\ dist_u[],\ dist_v[]\)</span>。</li>
<li>对于<span class="math inline">\(s\)</span>到<span class="math inline">\(t\)</span>的最短路径，<span class="math inline">\(dist[t]=\min\{dist_s[t],\ dist_s[u]+w+dist_v[t],
dist_s[v]+w+dist_u[t] \}\)</span></li>
</ul>
<h2 id="section-12">10.31</h2>
<ul>
<li>最小生成树不变，因为序关系不变</li>
<li>最短路径可能变化，例如四条边的权重为1、1、1、4。增加1后，变为2、2、2、5,显然改变了最短路径。</li>
</ul>
<h2 id="section-13">10.33</h2>
<ul>
<li>对Dijkstra算法计算路径权值进行修改即可</li>
<li>源点<span class="math inline">\(s\)</span>：<span class="math inline">\(dist[s]=c[s]\)</span></li>
<li>其他点<span class="math inline">\(v\)</span>: <span class="math inline">\(dist[v]=\min\{dist[v],\
dist[u]+uv.weight+c[u]\}\)</span>，其中<span class="math inline">\(u\rightarrow v\)</span>，且<span class="math inline">\(u\)</span>在最短路径树中</li>
</ul>
<h2 id="section-14">10.34</h2>
<ul>
<li>仍然正确</li>
<li>dijkstra算法在扩充最短路径树时选择的是fringe中的局部最优解，这个解也是全局最优的，因为fringe以外的边必然都是正的，“fringe的最优解”一定比“fring的次优解加上一些正边”要优（路径更短）。</li>
</ul>
<h2 id="section-15">10.36</h2>
<ul>
<li>在Dijkstra算法中维护best[]即可</li>
<li>初始化，best[s]=1</li>
<li>在fringe中求min时，如果发现多个最短路径（u1,u2,uk和v相连）指向了fringe中的同一个点v，则best[v]=best[u1]+...+best[uk]</li>
</ul>
<h2 id="section-16">10.38</h2>
<ul>
<li>第一问：把权值大于L的边删去，从s出发dfs搜t即可，线性复杂度。</li>
<li>第二问：
<ul>
<li>给每个点定义变量capacity：从s到该点的所有路径上最大边权值的最小值</li>
<li>初始化：s的capacity为0,其他点的capacity为无穷。</li>
<li>每次选择与最短路径树相邻的且capcity值最小的点，加入最小路径树。第一步把s加入。</li>
<li>每次向最短路径树增加一个点u后，更新其邻居v的capacity</li>
<li>v.capacity=min{v.capacity, max{u.capacity,uv.weight}}</li>
<li>返回第三行继续选点加入最小路径树。</li>
<li>最终t.capacity就是从s到t的最小油箱容量。</li>
<li>复杂度同Dijkstra,O((m+n)log n)</li>
</ul></li>
</ul>
<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>
]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Problem Set Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>【习题解答】 贪心算法设计要素</title>
    <url>/2021/06/09/algorithms11-hw/</url>
    <content><![CDATA[<h2 id="section">11.1</h2>
<p>算法思想如下： + 把S表示为c进制形式<span class="math inline">\(s_{n-1}\cdots s_0\)</span> + 拿<span class="math inline">\(s_i\)</span>枚面值为<span class="math inline">\(c^i\)</span>的硬币,<span class="math inline">\(i=0,\cdots,n-1\)</span></p>
<p>正确性如下： +
首先该算法输出的硬币，确实刚好能换S金额的钱，这个根据c进制运算即可。 +
假设存在更优的换法，该更优的换法同样可以用c进制串（要求每一位的值都小于c）表示出来。
*
更优的换法之所以可以表示为c进制串（每一位的值都小于c）是因为如果某一位大于等于c，则可以用更高一位的硬币代替（也就是进位操作），这样能得到一个更优的串，直至得到c进制串
* <strong>c进制串对同一个大小的数表示是唯一的</strong>，这个结论很重要。
*
更优的换法经过若干次优化后变成了我们的换法，矛盾。说明我们的换法就是最优的。</p>
<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>
]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Problem Set Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>【习题解答】 图优化问题的动态规划求解</title>
    <url>/2021/06/09/algorithms12-hw/</url>
    <content><![CDATA[<h2 id="section">12.1</h2>
<p>在更新<span class="math inline">\(D_{ij}^{(k)}\)</span>时加入：</p>
<ul>
<li>第一问：<span class="math inline">\(GO[i][j]=GO[i][k]\)</span></li>
<li>第二问：<span class="math inline">\(FROM[i][j]=FROM[k][j]\)</span></li>
</ul>
<h2 id="section-1">12.2</h2>
<h3 id="section-2">(1)</h3>
<ul>
<li>基于Dijkstra算法改进，找从s到各点的所有路径的最小权边的最大值。</li>
<li>类似于10.38
<ul>
<li>给每个点定义变量capacity：从s到该点的所有路径上最小边权值的最大值</li>
<li>初始化：s的capacity为无穷,其他点的capacity为0。</li>
<li>每次选择与“最短路径树”相邻的且capcity值最大的点，加入“最小路径树”（这里即已确定capacity的点集）。第一步把s加入。</li>
<li>每次向最短路径树增加一个点u后，更新其邻居v的capacity</li>
<li>v.capacity=max{v.capacity, min{u.capacity,uv.weight}}</li>
<li>返回第三行继续选点加入最小路径树。</li>
<li>最终t.capacity就是从s到t的最大吞吐量。</li>
<li>复杂度同Dijkstra,O((m+n)log n)</li>
</ul></li>
</ul>
<h3 id="section-3">(2)</h3>
<ul>
<li>类似于课本第147页的Floyd-Warshall算法，但状态转移方程（算法44的第5行）要修改如下。</li>
<li><span class="math inline">\(D_{ij}^{(k)}=\max\{D_{ij}^{(k-1)},\min\{D_{ik}^{(k-1)},\
D_{kj}^{(k-1)}\}\}\)</span></li>
</ul>
<h2 id="section-4">12.4</h2>
<ul>
<li>添加点s连向S中的点，添加t被T中的点连向。</li>
<li>对新图使用dijkstra算法</li>
<li>复杂度O(mlog n)</li>
</ul>
<h2 id="section-5">12.7</h2>
<ul>
<li>以<span class="math inline">\(v_0\)</span>为源点调用dijkstra算法</li>
<li>对转置图以<span class="math inline">\(v_0\)</span>为源点调用dijkstra算法</li>
<li>i到j的最短路，就是i到<span class="math inline">\(v_0\)</span>与<span class="math inline">\(v_0\)</span>到j的最短路的和。</li>
</ul>
<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>
]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Problem Set Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>【习题解答】 动态规划算法设计要素</title>
    <url>/2021/06/09/algorithms13-hw/</url>
    <content><![CDATA[<h2 id="section">13.1</h2>
<p>大概思路是 + <span class="math inline">\(O(n^3)\)</span>代价初始化<span class="math inline">\(S[,]\)</span> + 从左到右，从下到上以<span class="math inline">\(O(n^3)\)</span>代价计算<span class="math inline">\(c[,]\)</span></p>
<p>具体请根据160页、161页两个数组的定义将思路写成算法形式。</p>
<h2 id="section-1">13.2</h2>
<ul>
<li>设<span class="math inline">\(f(i,j)\)</span>表示前i个自然数构成的集合是否存在元素和是j</li>
<li>状态初始化
<ul>
<li><span class="math inline">\(f(i,j)=True\)</span>，若<span class="math inline">\(j=0\)</span></li>
<li><span class="math inline">\(f(i,j)=False\)</span>，若<span class="math inline">\(i=0 \ \&amp;\&amp;\  j\neq 0\)</span></li>
</ul></li>
<li>状态转移方程
<ul>
<li><span class="math inline">\(f(i,j)=f(i-1,j)\)</span>，若<span class="math inline">\(s_i&gt;j\)</span></li>
<li><span class="math inline">\(f(i,j)=f(i-1,j)\
||\  f(i-1,j-s_i)\)</span>，若<span class="math inline">\(s_i\leq
j\)</span></li>
</ul></li>
<li>时间复杂度<span class="math inline">\(O(nS)\)</span></li>
</ul>
<h2 id="section-2">13.4</h2>
<ul>
<li>d[i]表示以第i个数结尾的最长非减序列的长度</li>
<li>d[1]=1</li>
<li>状态转移方程<span class="math inline">\(d[i]=\max\{1,d[j]+1\},\  j&lt;i,A[j]\leq
A[i]\)</span></li>
<li>复杂度<span class="math inline">\(O(n^2)\)</span></li>
</ul>
<h2 id="section-3">13.5</h2>
<ul>
<li>设问题<span class="math inline">\(f(i,j)\)</span>表示前<span class="math inline">\(i\)</span>个数字划分为<span class="math inline">\(j\)</span>份的最低代价</li>
<li>目标问题是解决<span class="math inline">\(f(n,k)\)</span></li>
<li>线性代价先求出<span class="math inline">\(x\)</span>的前<span class="math inline">\(n\)</span>项和<span class="math inline">\(S\)</span></li>
<li>初始状态
<ul>
<li><span class="math inline">\(f(i,1)=S[i]\)</span></li>
<li><span class="math inline">\(f(1,j)=S[1]\)</span></li>
</ul></li>
<li>状态转移方程为是<span class="math inline">\(f(i,j)=\min\limits_{\lambda =1}^{i-1}
\max\{f(\lambda,j-1),S[i]-S[\lambda]\}\)</span></li>
<li><span class="math inline">\(\lambda\)</span>表示的是在第<span class="math inline">\(\lambda\)</span>个切最后一刀划分的情况。</li>
<li>时间复杂度为<span class="math inline">\(O(kn^2)\)</span>，空间复杂度为<span class="math inline">\(O(kn)\)</span></li>
</ul>
<p><strong>下面再给出一些改进的思路</strong> + <span class="math inline">\(f(\lambda,j-1)\)</span>是关于<span class="math inline">\(\lambda\)</span>的增函数 + <span class="math inline">\(S[i]-S[\lambda]\)</span>是关于<span class="math inline">\(\lambda\)</span>的减函数 +
本质是二分法找俩函数的交点，即比较<span class="math inline">\(f(\lambda,j-1)\)</span>和<span class="math inline">\(S[i]-S[\lambda]\}\)</span>的大小 *
若小于，则左半边递归查找 * 若大于，则右半边递归查找 +
改进后时间复杂度<span class="math inline">\(O(knlog\ n)\)</span> +
观察状态转移方程，事实上空间复杂度可以降为<span class="math inline">\(O(n)\)</span></p>
<h2 id="section-4">13.8</h2>
<h3 id="section-5">(1)</h3>
<ul>
<li>以<span class="math inline">\(C[i,j]\)</span>表示x中前i个构成的串，和y中前j个构成的串的最长公共子序列</li>
<li>则<span class="math inline">\(C[i,j]=\)</span>
<ul>
<li><span class="math inline">\(0\)</span>，若<span class="math inline">\(i=0\ ||\ j=0\)</span></li>
<li><span class="math inline">\(C[i-1,j-1]+1\)</span>，若<span class="math inline">\(i,j&gt;0\ \&amp;\&amp;\ x_i=y_j\)</span></li>
<li><span class="math inline">\(\max\{C[i,j-1],C[i-1,j]\}\)</span>，若<span class="math inline">\(i,j&gt;0\ \&amp;\&amp;\ x_i\neq y_j\)</span></li>
</ul></li>
</ul>
<h3 id="section-6">(2)</h3>
<ul>
<li>以<span class="math inline">\(C[i,j]\)</span>表示x中前i个构成的串，和y中前j个构成的串的最长公共子序列</li>
<li>则<span class="math inline">\(C[i,j]=\)</span>
<ul>
<li><span class="math inline">\(0\)</span>，若<span class="math inline">\(i=0\ ||\ j=0\)</span></li>
<li><span class="math inline">\(C[i,j-1]+1\)</span>，若<span class="math inline">\(i,j&gt;0\ \&amp;\&amp;\ x_i=y_j\)</span></li>
<li><span class="math inline">\(\max\{C[i,j-1],C[i-1,j]\}\)</span>，若<span class="math inline">\(i,j&gt;0\ \&amp;\&amp;\ x_i\neq y_j\)</span></li>
</ul></li>
</ul>
<h3 id="section-7">(3)</h3>
<ul>
<li>以<span class="math inline">\(C[i,j]\)</span>表示x中前i个构成的串，和y中前j个构成的串的最长公共子序列</li>
<li>以<span class="math inline">\(rest[i,j]\)</span>表示最长公共子序列对应的<span class="math inline">\(x_i\)</span>将来还能使用的次数。</li>
<li>则<span class="math inline">\(C[i,j]=\)</span>
<ul>
<li><span class="math inline">\(0\)</span>，若<span class="math inline">\(i=0\ ||\ j=0\)</span></li>
<li><span class="math inline">\(C[i,j-1]+1\)</span>，若<span class="math inline">\(i,j&gt;0\ \&amp;\&amp;\ x_i=y_j\ \&amp;\&amp;\
rest[i,j-1]&gt;0\)</span></li>
<li><span class="math inline">\(\max\{C[i,j-1],C[i-1,j]\}\)</span>，若<span class="math inline">\(i,j&gt;0\ \&amp;\&amp;\ (x_i\neq y_j\ ||\
rest[i,j-1]=0)\)</span></li>
</ul></li>
<li>则<span class="math inline">\(rest[i,j]=\)</span>
<ul>
<li><span class="math inline">\(k\)</span>，若<span class="math inline">\(j=0\)</span></li>
<li><span class="math inline">\(rest[i,j-1]-1\)</span>，若<span class="math inline">\(i,j&gt;0\ \&amp;\&amp;\ x_i=y_j\ \&amp;\&amp;\
rest[i,j-1]&gt;0\)</span></li>
<li><span class="math inline">\(rest[i,j-1]\)</span>，若<span class="math inline">\(i,j&gt;0\ \&amp;\&amp;\ (x_i\neq y_j\ ||\
rest[i,j-1]=0)\ \&amp;\&amp;\ (C[i,j-1]&gt;C[i-1,j])\)</span></li>
<li><span class="math inline">\(k\)</span>，若<span class="math inline">\(i,j&gt;0\ \&amp;\&amp;\ (x_i\neq y_j\ ||\
rest[i,j-1]=0)\ \&amp;\&amp;\ (C[i,j-1]\leq C[i-1,j])\)</span></li>
</ul></li>
</ul>
<h2 id="section-8">13.9</h2>
<ul>
<li>设<span class="math inline">\(L(i,j)\)</span>表示以<span class="math inline">\(T[i]\)</span>结尾和以<span class="math inline">\(T[j]\)</span>开头的两个最长连续子串，且<span class="math inline">\(i&lt;j\)</span></li>
<li>则<span class="math inline">\(L[i,j]=\)</span>
<ul>
<li><span class="math inline">\(0\)</span>，若<span class="math inline">\(i=0\ ||\ j=n+1\ ||\ i\geq j\ ||\ T[i]\neq
T[j]\)</span></li>
<li><span class="math inline">\(L[i-1,j+1]+1\)</span>，若<span class="math inline">\(0&lt;i&lt;j\ \&amp;\&amp;\ T[i]=T[j]\)</span></li>
</ul></li>
<li>计算<span class="math inline">\(L\)</span>的代价是<span class="math inline">\(O(n^2)\)</span>，同时结果还需<span class="math inline">\(O(n^2)\)</span>开销来遍历<span class="math inline">\(L\)</span>取最大值</li>
<li>总的复杂度是平方级别</li>
</ul>
<h2 id="section-9">13.10</h2>
<ul>
<li>设<span class="math inline">\(S[i,j]\)</span>表示<span class="math inline">\(A[1,...,i]\)</span>和<span class="math inline">\(B[1,...,j]\)</span>的最短公共超序列</li>
<li>则<span class="math inline">\(S[i,j]=\)</span>
<ul>
<li><span class="math inline">\(B[1,...,j]\)</span>，若<span class="math inline">\(i=0\)</span></li>
<li><span class="math inline">\(A[1,...,i\)</span>，若<span class="math inline">\(j=0\)</span></li>
<li><span class="math inline">\(S[i-1,j-1].add(A[i])\)</span>，若<span class="math inline">\(i,j&gt;0\ \&amp;\&amp;\ A[i]=B[j]\)</span></li>
<li><span class="math inline">\(S[i,j-1].add(B[j])\)</span>，若<span class="math inline">\(i,j&gt;0\ \&amp;\&amp;\ A[i]\neq B[j]\
\&amp;\&amp; S[i,j-1]&lt;S[i-1,j]\)</span></li>
<li><span class="math inline">\(S[i-1,j].add(A[i])\)</span>，若<span class="math inline">\(i,j&gt;0\ \&amp;\&amp;\ A[i]\neq B[j]\
\&amp;\&amp; S[i,j-1]\geq S[i-1,j]\)</span></li>
</ul></li>
</ul>
<h2 id="section-10">13.11</h2>
<h3 id="section-11">(1)</h3>
<p>不对，例如<span class="math inline">\(X=(ABC),Y=(BACA),Z=(\pmb{A}_X\pmb{B}_YA_Y\pmb{C}_YB_XA_YC_X)\)</span>，正确答案是可以合并，但算法中Z'=(ABAC)不等于Y</p>
<h3 id="section-12">(2)</h3>
<ul>
<li>设<span class="math inline">\(f(i,j)\)</span>为<span class="math inline">\(X\)</span>中前i个数和<span class="math inline">\(Y\)</span>中前j个数能否合成为<span class="math inline">\(Z\)</span>中前i+j个数</li>
<li><span class="math inline">\(f(i,j)=[f(i-1,j)\ \&amp;\&amp;\
(Z[i+j]=X[i])]\ ||\ [f(i,j-1)\ \&amp;\&amp;\
(Z[i+j]=Y[j])]\)</span></li>
<li>复杂度<span class="math inline">\(O(mn)\)</span></li>
</ul>
<h3 id="section-13">(3)</h3>
<ul>
<li>设<span class="math inline">\(f(i,j,k)\)</span>为<span class="math inline">\(X\)</span>中前i个数和<span class="math inline">\(Y\)</span>中前j个数合成为<span class="math inline">\(Z\)</span>中前k个数需要删除的元素集合。</li>
<li><span class="math inline">\(f(i,j,k)\)</span>是下面几种可能的情况中最小的集合
<ul>
<li><span class="math inline">\(f(i-1,j,k-1)\)</span>，若<span class="math inline">\((Z[k]=X[i])\)</span></li>
<li><span class="math inline">\(f(i,j-1,k-1)\)</span>，若<span class="math inline">\((Z[k]=Y[j])\)</span></li>
<li><span class="math inline">\(f(i-1,j,k).add(X[i])\)</span></li>
<li><span class="math inline">\(f(i,j-1,k).add(Y[j])\)</span></li>
<li><span class="math inline">\(f(i,j,k-1).add(Z[k])\)</span></li>
</ul></li>
<li>复杂度<span class="math inline">\(O(mnk)\)</span></li>
</ul>
<h2 id="section-14">13.12</h2>
<h3 id="section-15">(1)</h3>
<ul>
<li>设<span class="math inline">\(f(i)\)</span>表示前i个字符的子串是否合法</li>
<li><span class="math inline">\(f(i)=[f(1)\&amp;\&amp;dict(S[2...i])]\
||\ [f(2)\&amp;\&amp;dict(S[3...i])]...||\
[f(i-1)\&amp;\&amp;dict(S[i])]\)</span></li>
<li>复杂度<span class="math inline">\(O(n^2)\)</span></li>
</ul>
<h3 id="section-16">(2)</h3>
<p>第一问的<span class="math inline">\(f(i)\)</span>取的是布尔二值变量，事实上可以改进为整型。
+ 状态转移方程修改为：f(i)=j if f(j)&gt;0 and dict(S[j+1...i])==True +
设函数getSeq(k)表示求合法序列s[1...k]的单词序列 +
则getSeq(n)=getSeq(f(n)) + S[ f(n)+1...n ]</p>
<h2 id="section-17">13.13</h2>
<h3 id="section-18">(1)</h3>
<ul>
<li><span class="math inline">\(str[1...n]\)</span>表示原串</li>
<li><span class="math inline">\(f(i,j)\)</span>表示以第<span class="math inline">\(i\)</span>个字符结尾的长度为<span class="math inline">\(j\)</span>的子串对应的最长回文子序列长度</li>
<li><span class="math inline">\(f(0,j)=f(i,0)=0\)</span></li>
<li>若<span class="math inline">\(str[i]==str[i-j+1]\)</span>，则<span class="math inline">\(f(i,j)=f(i-1,j-2)+2\)</span></li>
<li>若<span class="math inline">\(str[i]\neq
str[i-j+1]\)</span>，则<span class="math inline">\(f(i,j)=\max\{f(i,j-1),f(i-1,j-1)\}\)</span></li>
<li>这里为什么要这样假设<span class="math inline">\(i,j\)</span>？如果认为<span class="math inline">\(f(i,j)\)</span>表示子串<span class="math inline">\(str[i...j]\)</span>的最长回文子序列长度，有什么不好的地方？</li>
</ul>
<h3 id="section-19">(2)</h3>
<ul>
<li>本题和13.12的第一问几乎一个思路。</li>
<li>首先对于给定的一个子串str[i...j]，需要判断是不是回文串check[p,q]，其中p=j，q=j-i+1，表示以第p个字符结尾的长度为q的子串是否为回文串。</li>
<li>check的功能对应到13.12的dict()函数</li>
<li>回文串的判断本身可以用dp来做，<span class="math inline">\(O(n^2)\)</span>的复杂度。
<ul>
<li>若<span class="math inline">\(q==1\)</span>，则<span class="math inline">\(check[p,q]=True\)</span></li>
<li>若<span class="math inline">\(q==2\)</span>，则<span class="math inline">\(check[p,q]=(str[p-1]==str[p])\)</span></li>
<li>否则<span class="math inline">\(check[p,q]=[str(p-q+1)==str(p)] \
\&amp;\&amp;\ check[p-1,q-2]\)</span></li>
</ul></li>
<li>设<span class="math inline">\(f(i)\)</span>表示以第i个字符结尾的子串最少拆分回文数</li>
<li><span class="math inline">\(f(0)=0\)</span></li>
<li><span class="math inline">\(f(i)=\min\limits_{check[i,t]==True}\{f(i-t)+1\}, t
\in {1,2,...,i}\)</span></li>
</ul>
<h2 id="section-20">13.15</h2>
<p>本题只考虑<span class="math inline">\(v\geq
\max\{x_1,...,x_n\}\)</span>的情况，否则把大面值的硬币剔除出去。 ### (1)
+ <span class="math inline">\(f(i,j)\)</span>表示用面值<span class="math inline">\(x_1,...,x_i\)</span>的硬币能否兑换j + <span class="math inline">\(f(i,j)=f(i-1,j)\ ||\ f(i,j-x_i)\)</span> +
复杂度O(nv)</p>
<h3 id="section-21">(2)</h3>
<ul>
<li><span class="math inline">\(f(i,j)\)</span>表示用面值<span class="math inline">\(x_1,...,x_i\)</span>的硬币能否兑换j</li>
<li><span class="math inline">\(f(i,j)=f(i-1,j)\ ||\
f(i-1,j-x_i)\)</span></li>
<li>复杂度O(nv)</li>
</ul>
<h3 id="section-22">(3)</h3>
<ul>
<li><span class="math inline">\(f(i,j,t)\)</span>表示用面值<span class="math inline">\(x_1,...,x_i\)</span>的硬币能否兑换j，且要求使用不超过t个硬币</li>
<li><span class="math inline">\(f(i,j,t)=f(i-1,j,t)\ ||\
f(i,j-x_i,t-1)\)</span></li>
<li>复杂度O(nvk)</li>
</ul>
<h2 id="section-23">13.16</h2>
<ul>
<li>设<span class="math inline">\(f[i]\)</span>表示第i个节点所在子树的最小点覆盖数，且要求节点i在点覆盖集中</li>
<li>设<span class="math inline">\(g[i]\)</span>表示第i个节点所在子树的最小点覆盖数，且要求节点i不在点覆盖集中</li>
<li>则状态转移方程
<ul>
<li><span class="math inline">\(f[i]=1+\sum\limits_{parent[j]=i}\min\{f[j],g[j]\}\)</span></li>
<li><span class="math inline">\(g[i]=\sum\limits_{parent[j]=i}f[j]\)</span></li>
</ul></li>
<li>转移顺序是从叶子节点向根节点转移</li>
<li>复杂度是线性，因为每个节点在做一次根节点和做一次子节点时访问到，O(2n)</li>
</ul>
<h2 id="section-24">13.18</h2>
<ul>
<li>假设<span class="math inline">\(f[i]\)</span>表示到达第i个旅店的最小惩罚</li>
<li>则<span class="math inline">\(f[i]=\min\limits_{j=1}^{i-1}(f[j]+(200-(a_i-a_j))^2),\
a_j&gt;a_i-200\)</span></li>
<li>通过<span class="math inline">\(O(n^2)\)</span>的代价获得到每个旅店的最小惩罚</li>
<li>在更新<span class="math inline">\(f\)</span>的状态转移矩阵的时候可以记录每个旅店最小惩罚对应的前一个旅店位置<span class="math inline">\(last[]\)</span></li>
<li><span class="math inline">\(last[i]=arg\min\limits_{j=1}^{i-1}(f[j]+(200-(a_i-a_j))^2),\
a_j&gt;a_i-200\)</span></li>
</ul>
<h2 id="section-25">13.23</h2>
<ul>
<li>本题是树的dp，思路和13.16几乎一样，设友好度评价为<span class="math inline">\(judge[]\)</span></li>
<li>设<span class="math inline">\(f[i]\)</span>表示第i个节点所在子树的最大评价，且要求节点i在名单中</li>
<li>设<span class="math inline">\(g[i]\)</span>表示第i个节点所在子树的最大评价，且要求节点i不在名单中</li>
<li>则状态转移方程
<ul>
<li><span class="math inline">\(f[i]=\sum\limits_{parent[j]=i}g[j]\)</span></li>
<li><span class="math inline">\(g[i]=\sum\limits_{parent[j]=i}\max\{f[j],g[j]\}\)</span></li>
</ul></li>
<li>转移顺序是从叶子节点向根节点转移</li>
<li>复杂度是线性，因为每个节点在做一次根节点和做一次子节点时访问到，O(2n)</li>
</ul>
<h2 id="section-26">13.24</h2>
<ul>
<li>换个角度思考，题目等价于把比萨店进行划分，使得两条路线的和最小（想象是两个骑手）。</li>
<li>假设<span class="math inline">\(f[i,j]\)</span>是对前i个店进行划分后的最短路程，i&gt;j，并且第一个骑手以i店结尾，第二个骑手以j店结尾。</li>
<li>显然第j+1到第i个店都是属于第一个骑手的。</li>
<li>初始情况，<span class="math inline">\(f[1,1]=0,f[2,1]=dist(1,2)\)</span></li>
<li>假设已知<span class="math inline">\(f[i,j],j=
1,2,...,i-1\)</span>,则状态转移方程如下
<ul>
<li><span class="math inline">\(f[i+1,j]=f[i,j]+dist(i,i+1),j=1,2,...,i-1\)</span></li>
<li><span class="math inline">\(f[i+1,i]=\min\limits_{j=1}^{i-1}\{f[i][j]+dist(j,i+1)\}\)</span></li>
</ul></li>
<li>上述状态转移方程本质上讨论的是比萨店<span class="math inline">\(a_{i+1}\)</span>分配给哪个骑手。</li>
<li>复杂度<span class="math inline">\(O(n^2)\)</span></li>
</ul>
<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>
]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Problem Set Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>【习题解答】 堆与偏序关系</title>
    <url>/2021/04/11/algorithms14-hw/</url>
    <content><![CDATA[<p><strong><em>注：</em></strong>
<em>本题解为个人完成，难免有疏漏，请勿抄袭，仅供参考，同时欢迎留言指正。</em>
## 14.1 + <span class="math inline">\(\lfloor \frac{h}{2}
\rfloor\)</span>是第h个节点的父节点 + <span class="math inline">\(\lceil
log(h+1) \rceil\)</span>是第h个节点的层数 + <span class="math inline">\(\lceil log(\lfloor \frac{h}{2} \rfloor+1)
\rceil\)</span>是第h个节点的父节点的层数 + <span class="math inline">\(\lceil log(\lfloor \frac{h}{2} \rfloor+1)
\rceil+1=\lceil log(h+1) \rceil\)</span>，因为<span class="math inline">\(h\)</span>的层数比<span class="math inline">\(h\)</span>父节点的层数多一层</p>
<h2 id="section">14.2</h2>
<p>取堆的前<span class="math inline">\(k\)</span>层即可，找第<span class="math inline">\(k\)</span>大的数，复杂度<span class="math inline">\(O(k^2)\)</span>，和<span class="math inline">\(n\)</span>无关</p>
<h2 id="section-1">14.3</h2>
<h3 id="d-ary-parent">D-ARY-PARENT</h3>
<p>用数学归纳法证明： + 基本情况：<span class="math inline">\(i=2\rightarrow 1+d\)</span>，父节点是<span class="math inline">\(1=\lfloor \frac{i-2}{d} +1\rfloor\)</span> +
归纳推理：设<span class="math inline">\(i=2+kd\rightarrow
1+d+kd\)</span>时，父节点是<span class="math inline">\(\lfloor\frac{i-2}{d}+1\rfloor=k+1\)</span>成立，则对于<span class="math inline">\(i=2+(k+1)d\rightarrow
1+d+(k+1)d\)</span>，父节点是<span class="math inline">\(k+1+1=\lfloor\frac{i-2}{d}+1\rfloor+1\)</span>也成立
+ 故i节点的父亲节点是<span class="math inline">\(\lfloor \frac{i-2}{d}
+1\rfloor\)</span></p>
<h3 id="d-ary-child">D-ARY-CHILD</h3>
<p>可以还用数学归纳法，当然也可以直接父节点的结论。</p>
<p>考虑节点<span class="math inline">\(d(i-1)+1+1=d(i-1)+2\)</span>的父节点是<span class="math inline">\(\lfloor \frac{d(i-1)+2-2}{d}
+1\rfloor=i\)</span></p>
<p>节点<span class="math inline">\(d(i-1)+1=d(i-1)+1\)</span>的父节点是<span class="math inline">\(\lfloor \frac{d(i-1)+1-2}{d}
+1\rfloor=i-1\)</span></p>
<p>因此<span class="math inline">\(i\)</span>的第一个子节点是<span class="math inline">\(d(i-1)+1+1\)</span>，故<span class="math inline">\(i\)</span>的第<span class="math inline">\(j\)</span>个子节点是<span class="math inline">\(d(i-1)+j+1(1\leq j\leq d)\)</span></p>
<h2 id="section-2">14.4</h2>
<p>只给思路： + 首先用数学归纳法证明节点数为<span class="math inline">\(n=2^k\)</span>(<span class="math inline">\(k\)</span>为非负整数)时，高度和恰为<span class="math inline">\(n-1\)</span> + 然后考虑<span class="math inline">\(n=2^k+x, x\in
{1,2,\cdots,2^k-1}\)</span>的情况，多出节点x个，高度和多出<span class="math inline">\(\lfloor\frac{x}{2}\rfloor+\lfloor\frac{x}{4}\rfloor+\cdots+1&lt;x\)</span>
+ 因此若节点数为<span class="math inline">\(n\)</span>，则高度和最多为<span class="math inline">\(n-1\)</span></p>
<h2 id="section-3">14.5</h2>
<p>用分治的思路即可： + 先把数组二分，解决两个子问题 +
然后合并链表即可</p>
<p>复杂度分析：<span class="math inline">\(f(k,\frac{n}{k})=2f(\frac{k}{2},\frac{n}{k})+n=nlog\
k\)</span></p>
<p>注：本题同4.8的思路，如果用堆的方法也可以。</p>
<h2 id="section-4">14.6</h2>
<p>只给思路：</p>
<ul>
<li>利用两个元素规模最多差1的堆结构，分别为最大堆和最小堆，其中最大堆的堆顶比最小堆的堆顶小。</li>
<li>通过维护这样的结构，可以在常数时间查出中位数，并且插入、删除都是对数时间代价。</li>
<li>详细算法表述从略。主要需注意维护两个堆的规模大小，始终最多差1个元素。</li>
</ul>
<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>
]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Problem Set Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>【习题解答】 并查集与动态等价关系</title>
    <url>/2021/04/15/algorithms15-hw/</url>
    <content><![CDATA[<p><strong><em>注：</em></strong>
<em>本题解为个人完成，难免有疏漏，请勿抄袭，仅供参考，同时欢迎留言指正。</em>
## 15.1 ### (1) 基于矩阵的算法实现： +
矩阵每个位置存放着两个元素的等价关系 + 初始化矩阵<span class="math inline">\(M\)</span>的时候考虑自反性 +
判断两个元素是不是在一个并查集中，开销<span class="math inline">\(O(1)\)</span> + 两个元素并操作，<span class="math inline">\(Union(i,j)\)</span>，先遍历<span class="math inline">\(M\)</span>的第<span class="math inline">\(i\)</span>行，对于满足<span class="math inline">\(M(i,p)==True\)</span>的<span class="math inline">\(p\)</span>，把第<span class="math inline">\(j\)</span>行加到第<span class="math inline">\(p\)</span>行；再遍历<span class="math inline">\(M\)</span>的第<span class="math inline">\(j\)</span>行，对于满足<span class="math inline">\(M(j,q)==True\)</span>的<span class="math inline">\(q\)</span>，把第<span class="math inline">\(i\)</span>行加到第<span class="math inline">\(q\)</span>行；</p>
<p>正确性证明：主要考虑，是不是同一个等价类中任意一对元素，在矩阵中都是<span class="math inline">\(True\)</span>，那么用数学归纳法证明，因为查不会改变矩阵，那么对并操作进行归纳推理。
+ 初始情况，满足 + 假设进行了<span class="math inline">\(k\)</span>次并操作<span class="math inline">\((k\in
N)\)</span>，命题成立，则再进行一次并，两个元素各自所在的等价类的内部自然已经满足命题，那么再考虑从两个等价类中分别取一个元素，在算法完成后矩阵对应位置改成了<span class="math inline">\(True\)</span></p>
<p>时间复杂性：每次最多是线性遍历2次，算法复杂度<span class="math inline">\(O(nl)\)</span>，开销主要是矩阵的行运算</p>
<h3 id="section">(2)</h3>
<p>基于数组的算法实现： + 数组<span class="math inline">\(A\)</span>每个位置存放对应代表元的下标 +
查操作<span class="math inline">\(find(x)\)</span>，即反复查找其代表元，直到到达根为止，单次查最坏情况是线性的<span class="math inline">\(O(n)\)</span> + 并操作<span class="math inline">\(union(i,j)\)</span>，即找到<span class="math inline">\(i,j\)</span>的根下标<span class="math inline">\(p,q\)</span>，然后把p挂到q上，即令<span class="math inline">\(A[find(i)]=find(j)\)</span>，单次操作复杂度最坏情况也是线性的<span class="math inline">\(O(n)\)</span> + 总的复杂度是<span class="math inline">\(O(nl)\)</span></p>
<h2 id="section-1">15.3</h2>
<p>利用并查集来解决： + 起始的时候每个变量自身构成一个等价类 +
每个等式对应一个并操作 +
然后对所有不等式进行查操作，若发现某不等式的两边的变量，出现在一个等价类中，那么矛盾。</p>
<p>复杂度分析： + m个约束，对应着m次并查的操作 +
n个变量，对应着并查集的n元素 + 最坏情况时间复杂度<span class="math inline">\(O((m+n)log^\star n)\)</span>，近似是<span class="math inline">\(O(m+n)\)</span></p>
<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>
]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Problem Set Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>【习题解答】 哈希表与查找</title>
    <url>/2021/04/16/algorithms16-hw/</url>
    <content><![CDATA[<p><strong><em>注：</em></strong>
<em>本题解为个人完成，难免有疏漏，请勿抄袭，仅供参考，同时欢迎留言指正。</em>
## 16.1 这是一个概率论的问题 + 总的样本空间是<span class="math inline">\(n^n\)</span> + 符合要求的子样本空间是<span class="math inline">\(\tbinom{n}{k}(n-1)^{n-k}\)</span> +
故概率是两者的商</p>
<h2 id="section">16.4</h2>
<h3 id="section-1">(1)</h3>
<p>采用封闭寻址时，哈希表的存储消耗考虑： + <span class="math inline">\(h_c\)</span>个表头，每个表头1个单位空间 + <span class="math inline">\(h_c\times
\alpha\)</span>个节点，每个节点2个单位空间 + 空间消耗为<span class="math inline">\((1+2\alpha)h_c\)</span>，即<span class="math inline">\(1.5h_c,2_hc,3h_c,5h_c\)</span></p>
<p>同样的空间，即<span class="math inline">\((1+2\alpha)h_c\)</span>，用于开放寻址哈希表，节点还是<span class="math inline">\(h_c\times
\alpha\)</span>个，每个节点需要1个单位空间，则位置个数为<span class="math inline">\((1+2\alpha)h_c\)</span>。故负载因子是<span class="math inline">\(\frac{h_c\times
\alpha}{(1+2\alpha)h_c}\)</span>，即<span class="math inline">\(\frac{1}{6},\frac{1}{4},\frac{1}{3},\frac{2}{5}\)</span></p>
<h3 id="section-2">(2)</h3>
<p>采用封闭寻址时，哈希表的存储消耗考虑： + <span class="math inline">\(h_c\)</span>个表头，每个表头1个单位空间 + <span class="math inline">\(h_c\times
\alpha\)</span>个节点，每个节点5个单位空间 + 空间消耗为<span class="math inline">\((1+5\alpha)h_c\)</span>，即<span class="math inline">\(\frac{9h_c}{4},\frac{7h_c}{2},6h_c,11h_c\)</span></p>
<p>同样的空间，即<span class="math inline">\((1+5\alpha)h_c\)</span>，用于开放寻址哈希表，节点还是<span class="math inline">\(h_c\times
\alpha\)</span>个，每个节点需要4个单位空间，则位置个数为<span class="math inline">\(\frac{(1+5\alpha)h_c}{4}\)</span>。故负载因子是<span class="math inline">\(\frac{4h_c\times
\alpha}{(1+5\alpha)h_c}\)</span>，即<span class="math inline">\(\frac{4}{9},\frac{4}{7},\frac{2}{3},\frac{8}{11}\)</span></p>
<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>
]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Problem Set Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>【习题解答】 平摊分析</title>
    <url>/2021/04/16/algorithms18-hw/</url>
    <content><![CDATA[<p><strong><em>注：</em></strong>
<em>本题解为个人完成，难免有疏漏，请勿抄袭，仅供参考，同时欢迎留言指正。</em>
## 18.1 ### (1)
首先所有元素都要进栈一次，而出栈的元素，都是因为不满足海景房的条件，那么现在问题就从证明<strong>返回的栈中的元素就是所有海景房</strong>，变成证明，<strong>返回的栈中的每个元素都是海景房</strong>，也就是说都比自己东边的元素高。</p>
<p>那么我们找的循环不变式就是，每次外循环第<span class="math inline">\(i\)</span>次结束时，栈中元素从栈底到栈顶高度递减，且每个元素<span class="math inline">\(A[t]\)</span>都比<span class="math inline">\(A[t+1\cdots
i]\)</span>的所有元素高，只要证明了这个不变式，那么取循环结束时的情况，就证得了原命题。</p>
<p>这个不变式的证明用类似于数学归纳法的思想，但是为有穷步的归纳推理： +
起始情况：栈中只有一个元素<span class="math inline">\(A[1]\)</span>，显然成立$ + 归纳推理：假设第<span class="math inline">\(i=k\)</span>次循环结束，栈中元素递减，且栈中的任意元素<span class="math inline">\(A[t]\)</span>比<span class="math inline">\(A[t+1\cdots
k]\)</span>的元素都高，那么对于下一次循环k+1，<span class="math inline">\(A[k+1]\)</span>如果大于栈顶则把栈顶弹出，然后再把<span class="math inline">\(A[k+1]\)</span>压入栈顶，这保证了第<span class="math inline">\(k+1\)</span>次循环结束时，栈中元素从底到顶是递减的；同时由栈顶是栈中最小的元素，这保证了栈顶的进入后，依然有栈中任意元素<span class="math inline">\(A[t]\)</span>比<span class="math inline">\(A[t+1\cdots k+1]\)</span>大。 +
故循环不变式得证</p>
<p>故原命题得证。</p>
<p>###(2) 由于每个元素都进行了且只进行了一次<span class="math inline">\(PUSH\)</span>，故算法一共进行了<span class="math inline">\(n\)</span>次<span class="math inline">\(PUSH\)</span>，而<span class="math inline">\(POP\)</span>的次数必然不超过<span class="math inline">\(PUSH\)</span>的次数，故算法复杂度为<span class="math inline">\(O(2n)=O(n)\)</span></p>
<h2 id="section">18.3</h2>
<p>为了更好地理解题目，我们这样思考： +
把集合合并问题的这个过程，转化为二进制串的自增过程，例如<span class="math inline">\(100111\)</span>自增后变成<span class="math inline">\(101000\)</span> +
自增的开销，按题干的要求，则取决于以多少个1结尾，例如<span class="math inline">\(100111\)</span>自增后变成<span class="math inline">\(101000\)</span>，开销是<span class="math inline">\(1+2\times1+2\times2+2\times4=1+2\times
(2^3-1)\)</span> + 对于<span class="math inline">\(k\)</span>个<span class="math inline">\(1\)</span>结尾的二进制串，自增的开销是<span class="math inline">\(1+2\times(2^k-1)=2^{k+1}-1\)</span> +
考虑二进制串从<span class="math inline">\(0\rightarrow
2^n=100\cdots00\)</span>的过程(<span class="math inline">\(n\)</span>个<span class="math inline">\(0\)</span>)，自增<span class="math inline">\(2^n\)</span>次 + 以<span class="math inline">\(k\)</span>个<span class="math inline">\(1\)</span>结尾的串(<span class="math inline">\(k\neq n\)</span>)的自增发生了<span class="math inline">\(2^{n-k-1}\)</span>次，以<span class="math inline">\(n\)</span>个1结尾的串，自增发生了一次，即最后一次。
+ 故整个过程的开销是<span class="math inline">\(\sum\limits_{k=0}^{n-1}[2^{n-k-1}\times
(2^{k+1}-1)]+1=(n+1)2^n\)</span> + 故自增<span class="math inline">\(n\)</span>次(插入元素<span class="math inline">\(n\)</span>次)时，整个过程开销是<span class="math inline">\(n(log\ n+1)=O(nlog\
n)\)</span>，平摊到单次的开销是<span class="math inline">\(O(log\
n)\)</span></p>
<p><strong>以上思路站在二进制串的自增的角度考虑的，也可以站在集合合并的角度考虑，假设插入元素n次</strong>
+ 创建大小为<span class="math inline">\(1\)</span>的新集合<span class="math inline">\(n\)</span>次，每次的开销是<span class="math inline">\(1\)</span> + 合并两个大小为<span class="math inline">\(1=2^0\)</span>的集合<span class="math inline">\(\frac{n}{2^{0+1}}\)</span>次，每次开销是<span class="math inline">\(2^{0+1}\)</span> + 合并两个大小为<span class="math inline">\(2=2^1\)</span>的集合<span class="math inline">\(\frac{n}{2^{1+1}}\)</span>，每次开销是<span class="math inline">\(2^{1+1}\)</span> + 合并两个大小为<span class="math inline">\(2=2^k\)</span>的集合<span class="math inline">\(\frac{n}{2^{k+1}}\)</span>，每次开销是<span class="math inline">\(2^{k+1}\)</span> + 故总开销是<span class="math inline">\(n+\sum\limits_{k=0}^{(log\ n-1)}n=n(log\
n+1)=O(nlog\ n)\)</span> + 平摊到单次的开销是<span class="math inline">\(O(log\ n)\)</span></p>
<h2 id="section-1">18.5</h2>
<ul>
<li>实现的结构可以是数组</li>
<li><span class="math inline">\(INSERT(S,x)\)</span>：直接把<span class="math inline">\(x\)</span>放到数组<span class="math inline">\(S\)</span>末尾，开销是<span class="math inline">\(1\)</span></li>
<li><span class="math inline">\(DEL-LARGER-HALF(S)\)</span>：先找到第<span class="math inline">\(\lceil\frac{|S|}{2}\rceil\)</span>大的元素，然后再遍历一遍保留比该元素小的即可，开销是线性的，不妨设开销不超过<span class="math inline">\(cS\leq 2c\times
\lceil\frac{|S|}{2}\rceil\)</span>，<span class="math inline">\(c\)</span>是常数</li>
<li>那么对于<span class="math inline">\(INSERT(S,x)\)</span>，我们除了计算大小为<span class="math inline">\(1\)</span>的开销以外，再额外计算大小为<span class="math inline">\(2c\)</span>的开销，这个开销是相当于为将来攒的(记账开销)，等到将来<span class="math inline">\(DEL-LARGER-HALF(S)\)</span>操作删除了<span class="math inline">\(\lceil\frac{|S|}{2}\rceil\)</span>个元素后，就能用此大小为<span class="math inline">\(2c\times
\lceil\frac{|S|}{2}\rceil\)</span>的攒的记账开销来作为<span class="math inline">\(DEL-LARGER-HALF(S)\)</span>需要的实际开销。</li>
<li>因此，可以认为<span class="math inline">\(INSERT(S,x)\)</span>的开销是<span class="math inline">\(2c+1\)</span>，<span class="math inline">\(DEL-LARGER-HALF(S)\)</span>开销是0，平摊代价是常数级别<span class="math inline">\(O(1)\)</span></li>
</ul>
<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>
]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Problem Set Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>【习题解答】 对手论证</title>
    <url>/2021/04/16/algorithms19-hw/</url>
    <content><![CDATA[<p><strong><em>注：</em></strong>
<em>本题解为个人完成，难免有疏漏，请勿抄袭，仅供参考，同时欢迎留言指正。</em>
## 19.1
决策树每个节点进行比较，最坏情况就是决策树从根到叶的最长路径L，显然<span class="math inline">\(2^L\geq Num_{leaf}\)</span>，其中叶子的数目<span class="math inline">\(Num_{leaf}\)</span>至少是<span class="math inline">\(n\)</span>，对应着第k大元素的n个不同的结果。因此<span class="math inline">\(2^L\geq
n\)</span>，即最坏情况时间复杂度的下界是<span class="math inline">\(\Omega(log\ n)\)</span></p>
<h2 id="section">19.3</h2>
<ul>
<li>最多有一个逆序对意味着逆序只可能出现在相邻两个元素之间，那么所有非相邻的元素都不是逆序对</li>
<li>只要找到这个相邻逆序对，调换位置即可完成排序，说明<span class="math inline">\(n-1\)</span>次操作确实可以完成排序</li>
<li>为了便于理解，可以用图的方式刻画这个过程，即n个元素是n个点，比较一次的结果可以确定两个点之间边的方向，可以根据两个点之间的可达性判断逆序情况</li>
<li>假设某算法A自认为可以用不到<span class="math inline">\(n-1\)</span>次比较，就判断出逆序对是<span class="math inline">\(0\)</span>个还是<span class="math inline">\(1\)</span>个</li>
<li>对手先采取这样的策略：输入数据设置为无逆序，这样算法A的每次比较都返回不是逆序对，最终一定返回无逆序对</li>
<li>进行了不到<span class="math inline">\(n-1\)</span>次比较，说明至少有一对相邻的节点<span class="math inline">\(v_i,v_{i+1}\)</span>之间是没有边的</li>
<li>此时<span class="math inline">\(v_i,v_{i+1}\)</span>在图中相互不可达，思考为什么</li>
<li>如果此时添加一条从<span class="math inline">\(v_i+1\)</span>到<span class="math inline">\(v_{i}\)</span>的边，图不会出现圈，思考为什么</li>
<li>对手可以按图当前表示的顺序关系重新构造输入数据，算法A<strong>有可能</strong>还是输出无逆序对，之所以说有可能是考虑到随机算法。</li>
<li>说明该算法有可能出错，从而得出矛盾，故比较次数的下界是<span class="math inline">\(n-1\)</span></li>
</ul>
<h2 id="section-1">19.5</h2>
<h3 id="section-2">(1)</h3>
<p><strong>算法思路</strong> + 利用锦标赛的方式，<span class="math inline">\(5\)</span>个元素为一组，每组内部比出的最大值为胜者，每轮的所有胜者进入下一轮。
+ 注意，除非是决赛，否则如果有一组人凑不满<span class="math inline">\(5\)</span>个，就全部晋级到下一轮，这个是为了保证算法的最优性。</p>
<p><strong>正确性</strong>
因为每轮必然会淘汰元素，而被淘汰的元素都不是对应组里5个元素的最大值，当然不可能是所有中的最大值，那么所有轮比完后剩下的最后一个元素，必然是最大值，因为其他元素都被淘汰了。</p>
<p><strong>最优性</strong> 算法每次<span class="math inline">\(SORT-FIVE\)</span>都会排除<span class="math inline">\(4\)</span>个元素，一共不重复的排除了<span class="math inline">\(n-1\)</span>个元素，故本算法进行了<span class="math inline">\(\lceil\frac{n-1}{4}\rceil\)</span>次<span class="math inline">\(SORT-FIVE\)</span>，假设有一个算法找到了最大值，且<span class="math inline">\(SORT-FIVE\)</span>次数小于<span class="math inline">\(\lceil\frac{n-1}{4}\rceil\)</span>次，那么必然存在至少2个元素没有被排除，对手可以设置输入，使得该算法输出的最大值不是正确结果，因此该算法不正确，由此证明了不存在更优的算法。</p>
<h3 id="section-3">(2)</h3>
<p><strong>算法思路</strong> + 锦标赛的轮数是<span class="math inline">\(\lceil log_5 n\rceil\)</span> +
最坏情况是冠军没有轮空过 + 每轮sort-five都是五个元素排序，都有第二名 +
所有可能的第二大元素，在最坏情况有<span class="math inline">\(\lceil
log_5 n\rceil\)</span>，对这些可能的第二名调用第一问的求最大算法即可 +
本算法选出次大元素的最坏情况时间复杂度是<span class="math inline">\(\lceil\frac{n-1}{4}\rceil+\lceil\frac{[\lceil
log_5 n\rceil]-1}{4}\rceil\)</span></p>
<p><strong>正确性</strong> +
选最大的元素时，没有和最大值比过就被淘汰的一定不是第二大 +
在所有可能的第二大中选出最大的那个，显然就是第二大的元素</p>
<p><strong>最优性</strong> +
证明最优性，就是证明不存在一个算法最坏情况比我们的代价小 +
我们可以构造一个输入的生成方式(对手策略)，使得对于任何算法，在该输入下代价都大于等于我们算法的代价。即找到对手策略，使得对任何算法，在最大者选出后，和最大者比赛输的第二名元素的总数不小于<span class="math inline">\(\lceil log_5 n\rceil\)</span> +
假设初始每个人都有1个金币，小组胜出的获得小组所有其他人的金币，而对手的策略就是，改变输入数据，使得小组中金币最多的那个人胜出
+
注意，对于任意的一个算法，此时已经没有轮数的概念了，因为轮数是我们锦标赛算法中的，但是还是有小组赛的概念，即以5个人为单位进行比赛选出最大者
+ 刚开始冠军有1个金币，比赛结束后，冠军拥有的金币数量是<span class="math inline">\(n\)</span> +
因为每组比赛是金币最多的人胜出，因此该组比完后，胜者金币数量最多变为原来的5倍
+ 因此冠军至少要比<span class="math inline">\(\lceil log_5
n\rceil\)</span>次小组赛，因此和最大者比赛输的元素的总数不小于<span class="math inline">\(\lceil log_5 n\rceil\)</span> +
因此我们的算法是最优的</p>
<h2 id="section-4">19.6</h2>
<h3 id="section-5">(1)</h3>
<ul>
<li>我们只考虑<span class="math inline">\(n\)</span>是大于<span class="math inline">\(2\)</span>的整数，等于<span class="math inline">\(1\)</span>或<span class="math inline">\(2\)</span>的情况意义不大</li>
<li>每次任意取数组中两个从没取过的数<span class="math inline">\(a[i]\)</span>,<span class="math inline">\(a[j]\)</span>进行比较</li>
<li>如果返回结果是"相同"，则继续循环取</li>
<li>如果返回结果是"不相同"，说明<span class="math inline">\(a[i]\)</span>,<span class="math inline">\(a[j]\)</span>中有且只有一个是特殊元素，那么把<span class="math inline">\(a[i]\)</span>和数组任意非<span class="math inline">\(a[j]\)</span>元素比一下即可，如"不相同"，则特殊元素是<span class="math inline">\(a[i]\)</span>，否则是<span class="math inline">\(a[j]\)</span></li>
<li>如果数组只剩1个元素可取，则该元素是特殊元素</li>
<li>如果数组剩2个元素<span class="math inline">\(a[i]\)</span>,<span class="math inline">\(a[j]\)</span>可取，说明<span class="math inline">\(a[i]\)</span>,<span class="math inline">\(a[j]\)</span>中有且只有一个是特殊元素，那么把<span class="math inline">\(a[i]\)</span>和数组任意非<span class="math inline">\(a[j]\)</span>元素比一下即可，如"不相同"，则特殊元素是<span class="math inline">\(a[i]\)</span>，否则是<span class="math inline">\(a[j]\)</span></li>
<li>说明算法为什么不超过<span class="math inline">\(\lfloor\frac{n+1}{2}\rceil\)</span></li>
</ul>
<h3 id="section-6">(2)</h3>
<p>假设<span class="math inline">\(n=2k\)</span>，则比较次数的期望是<span class="math inline">\(\frac{1}{k}[2+3+\cdots+(k-1)+k+k]=\frac{k^2+3k-2}{2k}=\frac{n^2+6n-8}{4n}\)</span></p>
<h3 id="section-7">(3)</h3>
<ul>
<li>为了证明方便，可以让对手设置<span class="math inline">\(n=2k\)</span>，即为偶数</li>
<li>假设某算法A自认为需要最多需要<span class="math inline">\(t&lt;\lfloor\frac{n+1}{2}\rceil=k\)</span>次就能找到特殊元素</li>
<li>对手可以采取这样的策略：控制输入数据，使得<span class="math inline">\(n\)</span>为偶数，且算法A的每次比较都返回"相同"</li>
<li>该算法最多比较<span class="math inline">\(t\leq
k-1\)</span>次，故比较次数用完时，必然存在至少2个元素从未参与比较</li>
<li>这样算法A无法判断特殊元素是哪一个，无论判断为哪个，对手都可以调整输入数据使得算法出错</li>
<li>故特殊元素问题最坏情况复杂度下界是<span class="math inline">\(\lfloor\frac{n+1}{2}\rceil\)</span></li>
</ul>
<p>注：其实证偶数情况会让算法A出错已经足够了，为了思考的完整性，下面提一下奇数情况怎么整:
+ 对手控制输入为奇数时，调整输入数据，使得算法<span class="math inline">\(A\)</span>在第<span class="math inline">\(t\)</span>次比较以前(不包括<span class="math inline">\(t\)</span>)都返回"相同" + 第<span class="math inline">\(t\)</span>次比较(如果算法会进行到第<span class="math inline">\(t\)</span>的话)，如果发生在两个从未参与比较的元素之间，则比较返回"不相同"；如果有元素已经参与了比较，则返回"相同"
+ 如果算法比较次数小于其宣称的上界<span class="math inline">\(t\)</span>，则每次比较都是返回"相同"，而<strong>从未参与比较的元素至少有3个</strong>，故找不到逆序元素，矛盾
+ 如果算法比较次数恰为其宣称的上界<span class="math inline">\(t\)</span>，那么前<span class="math inline">\(t-1\)</span>次返回"相同"，如果第<span class="math inline">\(t\)</span>次比较返回"相同"，则至少有2个元素还没参与比较，则无法确定特殊元素是哪个；如果第<span class="math inline">\(t\)</span>次比较返回"不相同"，那么由第<span class="math inline">\(t\)</span>发生在之前从未参与比较的两个元素之间，由对称性，同样无法确定特殊元素是哪一个</p>
<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>
]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Problem Set Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 从算法视角重审数学概念</title>
    <url>/2021/03/19/algorithms2/</url>
    <content><![CDATA[<h2 id="数学运算背后的算法操作">数学运算背后的算法操作</h2>
]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【习题解答】 从算法视角重审数学概念</title>
    <url>/2021/03/19/algorithms2-hw/</url>
    <content><![CDATA[<p><strong><em>注：</em></strong>
<em>本题解为个人完成，难免有疏漏，请勿抄袭，仅供参考，同时欢迎留言指正。</em>
##2.2 证明：对于任意整数<span class="math inline">\(n\geq1\)</span>,都存在非负整数<span class="math inline">\(k\)</span>，使得<span class="math inline">\(2^{k}\leq n\leq 2^{k+1}-1\)</span>。</p>
<p>则<span class="math inline">\(2^k+1\leq n+1\leq 2^{k+1} \Rightarrow
k&lt;log(n+1)\leq k+1 \Rightarrow \lceil log(n+1)\rceil=k+1\)</span></p>
<p>又<span class="math inline">\(2^k\leq n\leq 2^{k+1}-1 \Rightarrow k
\leq log\ n&lt; k+1 \Rightarrow \lfloor log\ n\rfloor+1=k+1\)</span></p>
<p>故对于任意整数<span class="math inline">\(n\geq 1\)</span>都有<span class="math inline">\(\lceil log(n+1)\rceil=\lfloor log\
n\rfloor+1\)</span></p>
<p>##2.5 <em>本题直接证明第二问即可</em>
证明:利用数学归纳法，很容易证明二叉树的边数比点数少一个。</p>
<p>基础：根节点0条边，1个点。</p>
<p>归纳：假设k个点的二叉树，边数比点数少1，则k+1个点的二叉树，去掉某叶节点后的子树有k个点，k-1个边，故加上该叶节点后有k+1个点，和k个边，假设依然成立。</p>
<p>结论：二叉树的边数比点数少一个。</p>
<p>故<span class="math inline">\(0\times n_0+1\times n_1+ 2\times n_2 =
n_0+n_1+n_2 -1 \Rightarrow n_2+1=n_0\)</span></p>
<p>所以，任意二叉树T都满足关系<span class="math inline">\(n_0=n_2+1\)</span></p>
<p>##2.7 ###(1) 证明<span class="math inline">\(O\)</span>传递性:</p>
<p><span class="math inline">\(f(n)=O(g(n)),g(n)=O(h(n))\)</span></p>
<p><span class="math inline">\(\Rightarrow \lim \limits_{n \rightarrow
\infty }\frac{f(n)}{h(n)}=\lim \limits_{n \rightarrow \infty
}\frac{f(n)}{g(n)}\frac{g(n)}{h(n)}=\lim \limits_{n \rightarrow \infty
}\frac{f(n)}{g(n)}\times\lim \limits_{n \rightarrow \infty
}\frac{g(n)}{h(n)}=c_1\times c_2&lt;\infty\)</span></p>
<p><span class="math inline">\(\Rightarrow f(n)=O(h(n))\)</span></p>
<p>证明<span class="math inline">\(\Omega\)</span>传递性:</p>
<p><span class="math inline">\(f(n)=\Omega(g(n)),g(n)=\Omega(h(n))\)</span></p>
<p><span class="math inline">\(\Rightarrow \lim \limits_{n \rightarrow
\infty }\frac{f(n)}{h(n)}=\lim \limits_{n \rightarrow \infty
}\frac{f(n)}{g(n)}\frac{g(n)}{h(n)}=\lim \limits_{n \rightarrow \infty
}\frac{f(n)}{g(n)}\times\lim \limits_{n \rightarrow \infty
}\frac{g(n)}{h(n)}=c_1\times c_2&gt;0\)</span></p>
<p><span class="math inline">\(\Rightarrow
f(n)=\Omega(h(n))\)</span></p>
<p>证明<span class="math inline">\(\Theta\)</span>传递性:</p>
<p><span class="math inline">\(f(n)=\Theta(g(n)),g(n)=\Theta(h(n))\)</span></p>
<p><span class="math inline">\(\Rightarrow \lim \limits_{n \rightarrow
\infty }\frac{f(n)}{h(n)}=\lim \limits_{n \rightarrow \infty
}\frac{f(n)}{g(n)}\frac{g(n)}{h(n)}=\lim \limits_{n \rightarrow \infty
}\frac{f(n)}{g(n)}\times\lim \limits_{n \rightarrow \infty
}\frac{g(n)}{h(n)}=c_1\times c_2\in (0,\infty)\)</span></p>
<p><span class="math inline">\(\Rightarrow
f(n)=\Theta(h(n))\)</span></p>
<p>证明<span class="math inline">\(o\)</span>传递性:</p>
<p><span class="math inline">\(f(n)=o(g(n)),g(n)=o(h(n))\)</span></p>
<p><span class="math inline">\(\Rightarrow \lim \limits_{n \rightarrow
\infty }\frac{f(n)}{h(n)}=\lim \limits_{n \rightarrow \infty
}\frac{f(n)}{g(n)}\frac{g(n)}{h(n)}=\lim \limits_{n \rightarrow \infty
}\frac{f(n)}{g(n)}\times\lim \limits_{n \rightarrow \infty
}\frac{g(n)}{h(n)}=c_1\times c_2=0\)</span></p>
<p><span class="math inline">\(\Rightarrow f(n)=o(h(n))\)</span></p>
<p>证明<span class="math inline">\(\omega\)</span>传递性:</p>
<p><span class="math inline">\(f(n)=\omega(g(n)),g(n)=\omega(h(n))\)</span></p>
<p><span class="math inline">\(\Rightarrow \lim \limits_{n \rightarrow
\infty }\frac{f(n)}{h(n)}=\lim \limits_{n \rightarrow \infty
}\frac{f(n)}{g(n)}\frac{g(n)}{h(n)}=\lim \limits_{n \rightarrow \infty
}\frac{f(n)}{g(n)}\times\lim \limits_{n \rightarrow \infty
}\frac{g(n)}{h(n)}=c_1\times c_2=\infty\)</span></p>
<p><span class="math inline">\(\Rightarrow
f(n)=\omega(h(n))\)</span></p>
<p>###(2) <span class="math inline">\(\lim \limits_{n \rightarrow \infty
}\frac{f(n)}{f(n)}=1\in (0,\infty)\)</span></p>
<p>故<span class="math inline">\(O,\Omega,\Theta\)</span>满足自反性</p>
<p>###(3) 证明<span class="math inline">\(\Theta\)</span>对称性:</p>
<p><span class="math inline">\(f(n)=\Theta(g(n))\)</span></p>
<p><span class="math inline">\(\Rightarrow \lim \limits_{n \rightarrow
\infty }\frac{g(n)}{f(n)}=\lim \limits_{n \rightarrow \infty
}\frac{1}{\frac{f(n)}{g(n)}}=\frac{1}{\lim \limits_{n \rightarrow \infty
}\frac{f(n)}{g(n)}}=\frac{1}{c} \in (0,\infty)\)</span></p>
<p><span class="math inline">\(\Rightarrow
g(n)=\Theta(f(n))\)</span></p>
<p>故<span class="math inline">\(\Theta\)</span>同时满足自反、对称、传递关系，因此是等价关系。</p>
<p>###(4) <span class="math inline">\(f(n)=\Theta(g(n))\)</span></p>
<p><span class="math inline">\(\Leftrightarrow \lim \limits_{n
\rightarrow \infty }\frac{f(n)}{g(n)}=c\in (0,\infty)\)</span></p>
<p><span class="math inline">\(\Leftrightarrow \lim \limits_{n
\rightarrow \infty }\frac{f(n)}{g(n)}=c&gt;0\)</span>且<span class="math inline">\(\lim \limits_{n \rightarrow \infty
}\frac{f(n)}{g(n)}=c&lt; \infty\)</span></p>
<p><span class="math inline">\(\Leftrightarrow
f(n)=\Omega(g(n))\)</span>且<span class="math inline">\(f(n)=O(g(n))\)</span></p>
<p>###(5) <span class="math inline">\(O\)</span>和<span class="math inline">\(\Omega\)</span>的对偶证明:</p>
<p><span class="math inline">\(f=O(g)\)</span></p>
<p><span class="math inline">\(\Leftrightarrow \lim \limits_{n
\rightarrow \infty }\frac{f(n)}{g(n)}=c&lt;\infty\)</span></p>
<p><span class="math inline">\(\Leftrightarrow \lim \limits_{n
\rightarrow \infty }\frac{g(n)}{f(n)}=\frac{1}{c}&gt;0\)</span></p>
<p><span class="math inline">\(\Leftrightarrow g=\Omega(f)\)</span></p>
<p><span class="math inline">\(o\)</span>和<span class="math inline">\(\omega\)</span>的对偶证明:</p>
<p><span class="math inline">\(f=o(g)\)</span></p>
<p><span class="math inline">\(\Leftrightarrow \lim \limits_{n
\rightarrow \infty }\frac{f(n)}{g(n)}=0\)</span></p>
<p><span class="math inline">\(\Leftrightarrow \lim \limits_{n
\rightarrow \infty }\frac{g(n)}{f(n)}=\frac{1}{0}=\infty\)</span></p>
<p><span class="math inline">\(\Leftrightarrow g=\omega(f)\)</span></p>
<p>###(6) 要证明这三个集合是空集，可以考虑反证。</p>
<p>假设第一个集合不是空集，则集合中存在一个<span class="math inline">\(f(n)\)</span>，使得<span class="math inline">\(f(n)=o(g(n))\)</span>且<span class="math inline">\(f(n)=\omega(g(n))\)</span></p>
<p>则<span class="math inline">\(0=\lim \limits_{n \rightarrow \infty
}\frac{f(n)}{g(n)}=\infty\)</span></p>
<p>故矛盾。其他两个集合是空集同理，用<strong>反证法</strong>结合<strong>极限定义</strong>证明是空集，详略。</p>
<p>##2.8 <em>本题对渐进增长率从小到大排序，并用<span class="math inline">\(&lt;,=\)</span>表示偏序关系</em> ###(1) <span class="math inline">\(log\ n&lt;n&lt;nlog\ n&lt;n^2=n^2+log\
n&lt;n^3&lt;n-n^3+7n^5&lt;2^n\)</span></p>
<p>###(2) <span class="math inline">\(log\ log\ n&lt;log\ n=ln\
n&lt;(log\ n)^2&lt;\sqrt{n}&lt;n&lt;nlog\
n&lt;n^{1+\epsilon}&lt;n^2\)</span></p>
<p><span class="math inline">\(=n^2+log\
n&lt;n^3&lt;n-n^3+7n^5&lt;2^{n-1}=2^n&lt;e^n&lt;n!\)</span></p>
<p>##2.16 ###(1) 由<span class="math inline">\(f(n)=1=O(n^{log_3{2}-\epsilon})\)</span></p>
<p>故<span class="math inline">\(T(n)=\Theta(n^{log_3{2}})\)</span></p>
<p>###(2) 比较<span class="math inline">\(f(n)=c\ log\ n \neq
\Omega(n^{\epsilon})\)</span>,
<strong>无法使用主定理，要么考虑用递归树结合直接计算，要么考虑用替换法结合数学归纳法证明</strong>。</p>
<p>例如本题可以直接计算。</p>
<p><span class="math inline">\(T(n)=T(n/2)+c\ log\ n=T(n/4)+c\ log\
(n/2)+c\ log\ n\)</span></p>
<p><span class="math inline">\(=c+\cdots+c\ log\ (n/4)+c\ log\ (n/2)+c\
log\ n\)</span></p>
<p><span class="math inline">\(=c\ log\ \frac{n^{log\ n}}{2^{log\
(n+1)}-1}=c\ log\ n^{(log\ n-1)}=\Theta((log\ n)^2)\)</span></p>
<p>注：中间用到了等比数列求和<span class="math inline">\(1\times 2\times
4\cdots n=2^{log\ n+1}-1\)</span>。</p>
<p>###(3) <span class="math inline">\(f(n)=cn=\Omega(n^{log_2{1}+\epsilon})=\Omega(n^{0+\epsilon})\)</span></p>
<p>任意取常数<span class="math inline">\(k\in
[0.5,1)\)</span>，显然都有<span class="math inline">\(f(n/2)=cn/2\leq k\
f(n)=kcn\)</span></p>
<p>故<span class="math inline">\(T(n)=\Theta(n)\)</span></p>
<p>###(4) <span class="math inline">\(f(n)=cn=\Theta(n^{log_2{2}})=\Theta(n)\)</span></p>
<p>故<span class="math inline">\(T(n)=\Theta(n\ log\ n)\)</span></p>
<p>###(5) <span class="math inline">\(f(n)=cn\ log\ n\neq
\Omega(n^{log_2{2}+\epsilon})=\Omega(n^{1+\epsilon})\)</span>,
无法用主定理，则考虑直接计算：</p>
<p><span class="math inline">\(T(n)=2T(n/2)+cn\ log\ n \Rightarrow
\frac{T(n)}{n}=\frac{T(n/2)}{n/2}+c\ log\ n\)</span></p>
<p>把<span class="math inline">\(T(n)/n\)</span>看成整体，结合(2)得:
<span class="math inline">\(T(n)/n=\Theta((log\ n)^2)\)</span></p>
<p>故<span class="math inline">\(T(n)=\Theta(n(log\ n)^2)\)</span></p>
<p><strong>注：可以发现，能用主定理解决的问题，本质上都可以直接计算，传统的换元、数列求和等数学手段都是可以的；一旦使用主定理，必须要满足主定理的种种条件的限制。</strong></p>
<p>###(6) <span class="math inline">\(f(n)=n\ {log}^{3}\ n\neq
\Omega(n^{log_3{3}+\epsilon})=\Omega(n^{1+\epsilon})\)</span>,
无法用主定理，则考虑直接计算：</p>
<p><span class="math inline">\(T(n)=3T(n/3)+cn\ {log}^3\ n \Rightarrow
\frac{T(n)}{n}=\frac{T(n/3)}{n/3}+\ {log}^3\ n\)</span></p>
<p>令<span class="math inline">\(G(n)=T(n)/n\)</span>，得:</p>
<p><span class="math inline">\(G(n)=G(n/3)+{log}^3\
n=\sum\limits_{i=0}^{log_3\
n}{log}^3\frac{n}{3^i}=\sum\limits_{i=0}^{log_3\ n}(log\ n-i\ log\
3)^3\)</span></p>
<p><span class="math inline">\(=\sum\limits_{i=0}^{log_3\
n}({log}^3n-3i\ log3\ {log}^2n+3i^2{log}^23\ log\
n-i^3{log}^33)\)</span></p>
<p><span class="math inline">\(=({log}^3n)({log}_3n+1)-\frac{(3\ log3\
{log}^2n)({log}_3n)({log}_3n+1)}{2}+\frac{(3{log}^23\ log\
n)(log_3n)(log_3n+1)(2log_3n+1)}{6}\)</span></p>
<p><span class="math inline">\(-\frac{({log}^33)(log_3n)^2(log_3n+1)^2}{4}=(1-\frac{3}{2}+1-\frac{1}{4})\frac{(log\
n)^4}{log\ 3}+o(\frac{(log\ n)^4}{log\ 3})=\Theta((log\
n)^4)\)</span></p>
<p>故<span class="math inline">\(T(n)=\Theta(n(log\ n)^4)\)</span></p>
<p>###(7) <span class="math inline">\(f(n)=cn^2 =
\Omega(n^{log_2{2}+\epsilon})=\Omega(n^{1+\epsilon})\)</span>,</p>
<p>任意取常数<span class="math inline">\(k\in
[0.5,1)\)</span>，显然都有<span class="math inline">\(2f(n/2)=cn^2/2\leq
k\ f(n)=kcn^2\)</span></p>
<p>故<span class="math inline">\(T(n)=\Theta(n^2)\)</span></p>
<p>###(8) 由<span class="math inline">\(1.5&gt;log_{25}{49}\)</span>得
<span class="math inline">\(f(n)=n^{3/2}log\ n =
\Omega(n^{log_{25}{49}+\epsilon})\)</span>,</p>
<p>任意取常数<span class="math inline">\(k\in
[\frac{49}{125},1)\)</span>，显然都有</p>
<p><span class="math inline">\(49f(n/25)=49(n/25)^{1.5}\ log\
(n/25)=\frac{49}{125}n^{1.5}\ log\ (\frac{n}{25})\leq kn^{1.5}\ log\
n\)</span></p>
<p>故<span class="math inline">\(T(n)=\Theta(n^{3/2}log\ n)\)</span></p>
<p>###(9)
这种加型的递推公式，显然不是用主定理。直接计算这个等差数列得：</p>
<p><span class="math inline">\(T(n)=T(n-1)+2=T(n-2)+2\times2=\cdots=T(n-(n-1))+(n-1)\times2=\Theta(n)\)</span></p>
<p>###(10) 对于等幂求和，显然<span class="math inline">\(T(n)=1^c+2^c+\cdots+n^c=\Theta(n^{c+1})\)</span></p>
<p>###(11) 先对递推公式变形，得：</p>
<p><span class="math inline">\(\frac{T(n)}{c^n}=\frac{1}{c}\frac{T(n-1)}{c^{n-1}}+1\)</span></p>
<p><span class="math inline">\(\Leftrightarrow
\frac{T(n)}{c^n}-\frac{c}{c-1}=\frac{1}{c}(\frac{T(n-1)}{c^{n-1}}-\frac{c}{c-1})\)</span></p>
<p><span class="math inline">\(\Leftrightarrow
\frac{T(n)}{c^n}-\frac{c}{c-1}=\frac{1}{c^{n-1}}\times(\frac{T(1)}{c}-\frac{c}{c-1})\)</span></p>
<p><span class="math inline">\(\Leftrightarrow T(n)=\frac{c}{c-1}\times
c^n+\frac{1}{c^{n-1}}\times(\frac{T(1)}{c}-\frac{c}{c-1})\times
c^n=\frac{c}{c-1}\times c^n+(T(1)-\frac{c^2}{c-1})\)</span></p>
<p>由<span class="math inline">\(c&gt;1\)</span>，故 <span class="math inline">\(T(n)=\Theta(c^n)\)</span></p>
<p>###(12) (i) 对于偶数下标情况</p>
<p><span class="math inline">\(T(2n)\)</span></p>
<p><span class="math inline">\(=T(2n-2)+2(2n)^3-3(2n)^2+3(2n)-1=T(2(n-1))+\Theta(n^3)\)</span></p>
<p>由等幂求和，<span class="math inline">\(T(2n)=\Theta(n^4)\)</span></p>
<ol start="2" type="i">
<li>对于奇数下标情况</li>
</ol>
<p><span class="math inline">\(T(2n-1)\)</span></p>
<p><span class="math inline">\(=T(2n-1-2)+2(2n-1)^3-3(2n-1)^2+3(2n-1)-1=T(2(n-1)-1)+\Theta(n^3)\)</span></p>
<p>由等幂求和，<span class="math inline">\(T(2n-1)=\Theta(n^4)\)</span></p>
<p>综上，<span class="math inline">\(T(n)=\Theta(n^4)\)</span></p>
<p>###(13) 首先<span class="math inline">\(T(n)=8n\)</span>，符合题干递推公式，下面用数学归纳法证明<span class="math inline">\(T(n)=\Theta(n)\)</span>。</p>
<p>设<span class="math inline">\(c=\max\{\frac{T(i)}{i},8\},i=1,2,\cdots,7\)</span></p>
<p>基础情况：对于<span class="math inline">\(0&lt;n&lt;8,\
T(n)/n\in(0,c]\)</span>成立</p>
<p>归纳情况：假设对于<span class="math inline">\(n&lt;k(k\in Z),\ T(n)/n
\in(0,c]\)</span>成立</p>
<p>则<span class="math inline">\(0&lt;\frac{T(k)}{k}=\frac{T(k/2)+T(k/4)+T(k/8)+k}{k}\leq\frac{(ck/2)+(ck/4)+(ck/8)+k}{k}=\frac{7c}{8}+1=c+\frac{8-c}{8}\leq
c\)</span>成立</p>
<p>故极限情况，<span class="math inline">\(\lim\limits_{n\rightarrow
\infty}\frac{T(n)}{n}\in (0,c]\)</span></p>
<p>因此证得<span class="math inline">\(T(n)=\Theta(n)\)</span></p>
<p><strong>注：本题的思想是替换法加数学归纳法证明，其中常数c的选取和放缩的技巧，很有微积分极限证明题内味儿了</strong></p>
<p>##2.18 由<span class="math inline">\(T(n)=\sqrt{n}\
T(\sqrt{n})+O(n)\)</span></p>
<p>故<span class="math inline">\(\frac{T(n)}{n}=\frac{T(\sqrt{n})}{\sqrt{n}}+O(1)\)</span></p>
<p>假设<span class="math inline">\(n\)</span>进行<span class="math inline">\(k\)</span>次根号操作变成<span class="math inline">\(1\)</span>(我们认为根号后取到下整数)，即解<span class="math inline">\(\min\limits_{(\sqrt{n})^k&lt;2}k\)</span>。</p>
<p>即<span class="math inline">\(\min\limits_{\frac{1}{2^k}&lt;\frac{log2}{log\
n}}k=log(log\ n)\)</span></p>
<p>故<span class="math inline">\(\frac{T(n)}{n}=\Theta(log(log\
n))\Rightarrow T(n)=\Theta(n\ log(log\ n))\)</span></p>
<p>##2.19
例如取2.15题的(2)和(5)中的取值，仔细体会master定理的情况(3)不能覆盖一些例子的原因。</p>
<p>##2.22 ###(1) 算法的输出是找到输入数组中最小的元素</p>
<p>###(2) 对于算法1，复杂度<span class="math inline">\(T(n)=T(n-1)+1\)</span>，故<span class="math inline">\(T(n)=\Theta(n)\)</span>。</p>
<p>对于算法2，复杂度<span class="math inline">\(T(n)=2T(n/2)+1\)</span>，由<span class="math inline">\(1=O(n^{log_2{2}-\epsilon})\)</span>，故<span class="math inline">\(T(n)=\Theta(n)\)</span>。</p>
<p>##2.24 ### MYSTERY <span class="math inline">\(r=\sum\limits_{i=1}^{n-1}\sum\limits_{j=i+1}^n\sum\limits_{k=1}^j
1=\frac{n(n-1)(n+1)}{3}\)</span></p>
<p>最坏情况时间复杂度<span class="math inline">\(O(n^3)\)</span></p>
<h3 id="persky">PERSKY</h3>
<p><span class="math inline">\(r=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^i\sum\limits_{k=j}^{i+j}
1=\sum\limits_{i=1}^n(i^2+i)=\frac{n(n+1)(2n+1)}{6}+\frac{n(1+n)}{2}=\frac{n^3}{3}+n^2+\frac{2n}{3}\)</span></p>
<p>最坏情况时间复杂度<span class="math inline">\(O(n^3)\)</span></p>
<h3 id="prestiferous">PRESTIFEROUS</h3>
<p><span class="math inline">\(r=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^i\sum\limits_{k=j}^{i+j}\sum\limits_{l=1}^{i+j-k}
1=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^i\sum\limits_{k=j}^{i+j}(i+j-k)=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^i(\frac{i^2+i}{2})\)</span></p>
<p><span class="math inline">\(=\sum\limits_{i=1}^{n}(\frac{i^3+i^2}{2})=\frac{n^2(n+1)^2}{8}+\frac{n(n+1)(2n+1)}{12}=\frac{n^4}{8}+\frac{5}{12}n^3+\frac{3}{8}n^2+\frac{n}{12}\)</span></p>
<p>最坏情况时间复杂度<span class="math inline">\(O(n^4)\)</span></p>
<h3 id="conundrum">CONUNDRUM</h3>
<p><span class="math inline">\(r=\sum\limits_{i=1}^{n}\sum\limits_{j=i+1}^n\sum\limits_{k=i+j-1}^{n}
1=\sum\limits_{i=1}^{n}\sum\limits_{j=i+1}^n(n+2-i-j)=\sum\limits_{i=1}^{n}\frac{(n-i)(n+3-3i)}{2}=\frac{n(n-1)}{2}\)</span></p>
<p>最坏情况时间复杂度<span class="math inline">\(O(n^2)\)</span></p>
<p><strong>注：根据评论区反馈，上面答案有误，正确答案更新如下，更新时间2022.4.17</strong></p>
<p><span class="math inline">\(r=\sum\limits_{i=1}^{n}\sum\limits_{j=i+1}^n\sum\limits_{k=i+j-1}^{n}
1\)</span></p>
<p>根据<span class="math inline">\(i+j-1\leq n \Rightarrow j\leq
n+1-i\)</span>,则因为<span class="math inline">\(n+1-i\leq
n\)</span>，需要修改<span class="math inline">\(j\)</span>的上限，</p>
<p>即<span class="math inline">\(r=\sum\limits_{i=1}^{n}\sum\limits_{j=i+1}^{n+1-i}\sum\limits_{k=i+j-1}^{n}
1\)</span></p>
<p>又根据<span class="math inline">\(i+1\leq n+1-i\Rightarrow i\leq
\lfloor\frac{n}{2}\rfloor\)</span>，同理需要修改<span class="math inline">\(i\)</span>的上限</p>
<p>即<span class="math inline">\(r=\sum\limits_{i=1}^{\lfloor\frac{n}{2}\rfloor}\sum\limits_{j=i+1}^{n+1-i}\sum\limits_{k=i+j-1}^{n}
1=\sum\limits_{i=1}^{\lfloor\frac{n}{2}\rfloor}\sum\limits_{j=i+1}^{n+1-i}(n+2-i-j)=\sum\limits_{i=1}^{\lfloor\frac{n}{2}\rfloor}\frac{(n+2-2i)(n+1-2i)}{2}\)</span></p>
<p><span class="math inline">\(=\sum\limits_{i=1}^{\lfloor\frac{n}{2}\rfloor}
[\frac{(n+1)(n+2)}{2}+2i^2-(2n+3)i]\)</span></p>
<p><span class="math inline">\(=\frac{(n+1)(n+2)\lfloor\frac{n}{2}\rfloor}{2}+\frac{\lfloor\frac{n}{2}\rfloor(\lfloor\frac{n}{2}\rfloor+1)(2\lfloor\frac{n}{2}\rfloor+1)}{3}-\frac{\lfloor\frac{n}{2}\rfloor(1+\lfloor\frac{n}{2}\rfloor)(2n+3)}{2}\)</span></p>
<p>最坏情况时间复杂度<span class="math inline">\(O(n^3)\)</span></p>
<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>
]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Problem Set Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>【习题解答】 NP完全性理论初步</title>
    <url>/2021/06/11/algorithms21-hw/</url>
    <content><![CDATA[<h2 id="section">21.1</h2>
<h3 id="section-1">(1)</h3>
<p>如果任意一个NP完全问题可以在多项式时间内解决，则所有NP问题都可以在多项式时间内规约到NP完全问题，从而在多项式时间内解决。</p>
<h3 id="section-2">(2)</h3>
<p>即证逆否命题，若存在一个NP完全问题能在多项式时间内解决，则所有的NP完全问题都存在多项式时间的解。（因为NPC问题就是NP问题，又根据第一问的结论，显然可证出）</p>
<h2 id="section-3">21.3</h2>
<h3 id="section-4">(1)</h3>
<ul>
<li>从n个点中选k个点，多项式代价。<span class="math inline">\(c_n^k=\frac{n!}{k!(n-k)!}=O(n^k)\)</span></li>
<li>每种情况都可以在多项式时间验证。</li>
</ul>
<h3 id="section-5">(2)</h3>
<ul>
<li>为什么叫伪最大团问题呢，在于k的区别</li>
<li>最大团问题的k是参数，可以依赖于n，比如k=n，此时并不容易在多项式时间内解决判定问题，否则九证明了P=NP</li>
<li>伪最大团问题的k是常数，不能依赖于n，k就是一个常数。</li>
<li>所以本题提出的多项式算法并不能证明P=NP</li>
</ul>
<h2 id="section-6">21.4</h2>
<h3 id="section-7">(1)</h3>
<ul>
<li>对于一个析取范式<span class="math inline">\(C_1\vee
C_2\vee\cdots\vee C_k\)</span>，只要一个项<span class="math inline">\(C_i\)</span>为真即可。</li>
<li><span class="math inline">\(C_i\)</span>为真当且仅当<span class="math inline">\(\forall l\in C_i,\neg l\notin C_i\)</span></li>
<li>多项式时间内可以检查一个项是否为真，即平方级别代价遍历即可，从而多项式时间内可以解决DNF-SAT问题。</li>
<li>DNP-SAT是一个p问题。</li>
</ul>
<h3 id="section-8">(2)</h3>
<ul>
<li>CNF-SAT的输入转化为DNF-SAT的输入，这一步暂时没有发现多项式级别的算法</li>
<li>换句话说，截止到今天，还没有把CNF-SAT问题多项式代价规约为DNF-SAT问题的方法。</li>
</ul>
<h2 id="section-9">21.5</h2>
<h3 id="section-10">(1)</h3>
<p>首先证明背包问题是NP问题，20.1已经证明过了，关键是证明多项式时间内可验证一个解是否满足判定问题的要求。</p>
<p>然后证明子集和问题可以规约到背包问题。 + 子集和问题给定自然数<span class="math inline">\(S\)</span>和集合<span class="math inline">\(A={s_1,s_2,\cdots,s_n}\)</span>。 +
令背包大小是<span class="math inline">\(S\)</span>，且<span class="math inline">\(k=S\)</span>。物品大小和价值都是<span class="math inline">\(A={s_1,s_2,\cdots,s_n}\)</span>。使用背包问题的算法，输出是否存在大小和不超过<span class="math inline">\(S\)</span>，且价值和不低于<span class="math inline">\(k=S\)</span>的放法。 +
该输出的结果就是子集和问题的结果。</p>
<p>由此证明背包问题是NPC问题。</p>
<h3 id="section-11">(2)</h3>
<ul>
<li>假设背包容量是<span class="math inline">\(W\)</span>，<span class="math inline">\(n\)</span>个物品，且已知物品大小是<span class="math inline">\(wt[1...n]\)</span>，价值是<span class="math inline">\(val[1...n]\)</span>求背包能装的最大价值。</li>
<li><span class="math inline">\(dp[i][w]\)</span>表示对于前i个物品，当前背包的容量为w，这种情况下可以装的最大价值是<span class="math inline">\(dp[i][w]\)</span>。</li>
<li>状态转移方程为<span class="math inline">\(dp[i][w] =
\max\{dp[i-1][w],\ dp[i-1][w - wt[i]] + val[i]\}\)</span></li>
<li>状态转移方程即考虑第i个物品是否要装进背包。</li>
<li>时间空间复杂度<span class="math inline">\(O(nW)\)</span></li>
</ul>
<h3 id="section-12">(3)</h3>
<ul>
<li>时间复杂度讲的是算法相对于输入规模的代价</li>
<li>输入规模指的是输入的二进制编码的长度，想想oj的while(cin)</li>
<li>动态规划找到了<span class="math inline">\(O(nW)\)</span>的算法，但这是不是多项式级别的呢？</li>
<li>我们计算输入规模，是<span class="math inline">\(log\
W+\sum\limits_{i=1}^n log\ wt_i+\sum\limits_{i=1}^n log\ val_i=O(nlog\
W)\)</span>。</li>
<li>因此我们算法<span class="math inline">\(O(nW)\)</span>相对于输入规模是指数级别的。</li>
<li>因此不表明我们可以为NP完全问题设计一个多项式时间的算法。</li>
</ul>
<h2 id="section-13">21.6</h2>
<ul>
<li>首先证明集合覆盖问题是NP问题
<ul>
<li>即可以在多项式时间内验证一个解满不满足判定问题。</li>
<li>显然可以，对于一个给定解，判定其大小是否为k，再检查全集中每个元素是否都在这个解中即可，多项式时间的代价。</li>
</ul></li>
<li>然后证明可以把支配集问题多项式代价规约到集合覆盖问题
<ul>
<li>对于支配集问题，给定无向图G，我们令全集U为顶点集合V，对于每个顶点<span class="math inline">\(v_1,\cdots,v_n\)</span>，将其和其所有邻居作为子集，也就是<span class="math inline">\(S_1,S_2,\cdots,S_n\)</span>。调用集合覆盖算法，判定是否存在大小为k的集合覆盖。</li>
<li>集合覆盖算法的判定结果就是支配集问题的判定结果。即是否存在大小为k的支配集。</li>
</ul></li>
<li>所以集合覆盖问题是一个NP完全问题。</li>
</ul>
<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>
]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Problem Set Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>【习题解答】 问题与规约</title>
    <url>/2021/06/11/algorithms20-hw/</url>
    <content><![CDATA[<h2 id="section">20.1</h2>
<h3 id="section-1">(1)</h3>
<ul>
<li>CLIQUE
<ul>
<li>优化问题：输入无向图；输出最大团大小</li>
<li>判定问题：输入无向图和k；输出图中是否有大小为k的团</li>
</ul></li>
<li>KNAPSACK
<ul>
<li>优化问题：输入n个物品、每个物品大小和价值、背包大小；输出背包能装物品的最大价值</li>
<li>判定问题：输入n个物品、每个物品大小和价值、背包大小、价值k；输出背包能否装价值不小于k的物品</li>
</ul></li>
<li>INDENPENDENT-SET
<ul>
<li>优化问题：输入无向图；输出最大独立集</li>
<li>判定问题：输入无向图和k；输出图中是否存在大小为k的独立集</li>
</ul></li>
<li>VERTEX-COVER
<ul>
<li>优化问题：输入无向图；输出最小点覆盖</li>
<li>判定问题：输入无向图和k；输出图中是否存在大小为k的点覆盖</li>
</ul></li>
</ul>
<h3 id="section-2">(2)</h3>
<ul>
<li>CLIQUE
<ul>
<li>优化 <span class="math inline">\(\Rightarrow\)</span>
判定：多项式内解出优化问题，再把优化结果和k比较即可。</li>
<li>优化 <span class="math inline">\(\Leftarrow\)</span> 判定：
对k的所有取值进行判定，即可解决优化问题。因为k不超过|V|，故还是多项式时间。</li>
</ul></li>
<li>KNAPSACK
<ul>
<li>优化 <span class="math inline">\(\Rightarrow\)</span>
判定：多项式内解出优化问题，再把优化结果和k比较即可。</li>
<li>优化 <span class="math inline">\(\Leftarrow\)</span>
判定：对k的所有取值进行判定，即可解决优化问题。因为k不超过价值总和，故还是多项式时间。</li>
</ul></li>
<li>INDENPENDENT-SET
<ul>
<li>优化 <span class="math inline">\(\Rightarrow\)</span>
判定：多项式内解出优化问题，再把优化结果和k比较即可。</li>
<li>优化 <span class="math inline">\(\Leftarrow\)</span>
判定：对k的所有取值进行判定，即可解决优化问题。因为k不超过|E|，故还是多项式时间。</li>
</ul></li>
<li>VERTEX-COVER
<ul>
<li>优化 <span class="math inline">\(\Rightarrow\)</span>
判定：多项式内解出优化问题，再把优化结果和k比较即可。</li>
<li>优化 <span class="math inline">\(\Leftarrow\)</span>
判定：对k的所有取值进行判定，即可解决优化问题。因为k不超过|V|，故还是多项式时间。</li>
</ul></li>
</ul>
<h3 id="section-3">(3)</h3>
<ul>
<li>CLIQUE
<ul>
<li>即给定一个无向图和k，验证一个点集其是不是大小为k的团</li>
<li>验证完全图O(V^2)，验证节点数为k，O(V)</li>
<li>所以是np问题</li>
</ul></li>
<li>KNAPSACK
<ul>
<li>即n个物品、每个物品大小和价值、背包大小、价值k，验证一个物品集合是不是能放入背包且价值不小于k。</li>
<li>验证大小之和不大于背包容量O(n)，验证价值之和不小于k也是O(n)</li>
<li>所以是np问题</li>
</ul></li>
<li>INDENPENDENT-SET
<ul>
<li>即给定一个无向图和k，验证一个点集其是不是点独立集</li>
<li>验证点和点之间是否相邻O(V^2)</li>
<li>所以是np问题</li>
</ul></li>
<li>VERTEX-COVER
<ul>
<li>即给定一个无向图和k，验证一个点集其是不是点覆盖</li>
<li>验证每个边的两端点是不是至少有一个在点覆盖中O(EV)</li>
<li>所以是np问题</li>
</ul></li>
</ul>
<h2 id="section-4">20.2</h2>
<ul>
<li>设P1能在多项式时间内规约到P2，意味着存在多项式代价转换函数T1(x)，使得
<ul>
<li>对于P1的合法输入x，转换为T1(x)是P2的合法输入</li>
<li>且两者的输出相同。</li>
</ul></li>
<li>设P2能在多项式时间内规约到P3，意味着存在多项式代价转换函数T2(x)，使得
<ul>
<li>对于P2的合法输入x，转换为T2(x)是P3的合法输入</li>
<li>且两者的输出相同。</li>
</ul></li>
<li>下面证明传递性，即P1能在多项式时间内规约到P3。我们找到了多项式代价转换函数T2(T1(x))
<ul>
<li>对于P1的合法输入x，T1(x)是P2的合法输入，T2(T1(x))是P3的合法输入</li>
<li>三者的输出相同。</li>
</ul></li>
<li>这里有一个显然的细节，内函数和外函数都是多项式代价转换函数，则其复合函数也是多项式代价的转换函数。</li>
</ul>
<h2 id="section-5">20.3</h2>
<p>O(n^4)</p>
<h2 id="section-6">20.4</h2>
<ul>
<li>先泛化一下规约的定义，课本上说的是判定问题的规约。</li>
<li>如果P问题能在多项式时间内规约到Q问题，说明P问题可以通过多项式时间的计算以及多项式次黑盒的调用Q问题算法来解决。</li>
<li>排序问题多项式规约到选择问题，排序算法可以是，n次调用选择算法（联想到选择排序算法）。</li>
<li>选择问题多项式规约到排序问题，选择算法可以是，调用1次排序算法然后遍历一遍完成选择。</li>
</ul>
<h2 id="section-7">20.5</h2>
<ul>
<li>更一般的，我们把问题求阶为<span class="math inline">\(p\)</span>的数规约到求阶为<span class="math inline">\(q\)</span>的数。即用求阶为<span class="math inline">\(q\)</span>的算法（简称<span class="math inline">\(q\)</span>算法）解决求阶为<span class="math inline">\(p\)</span>的算法（简称<span class="math inline">\(p\)</span>算法）</li>
<li>第一步，调用一次<span class="math inline">\(q\)</span>算法，找到第<span class="math inline">\(q\)</span>小的数<span class="math inline">\(t\)</span></li>
<li>第二步，比较<span class="math inline">\(q\)</span>和<span class="math inline">\(p\)</span>的关系，再遍历一遍数组并和<span class="math inline">\(t\)</span>进行比较，删除不可能是阶为<span class="math inline">\(p\)</span>的数。当删到只剩一个数时算法停止，输出该数。否则继续第三步。</li>
<li>第三步，更新<span class="math inline">\(p\)</span>的值，返回第一步</li>
<li>分析：第二步至少删一个数，所以调用O(n)次<span class="math inline">\(q\)</span>算法即可实现<span class="math inline">\(p\)</span>算法。</li>
</ul>
<p>注： +
本题使用q算法解决p问题，注意到p随着调用的嵌套是一个变动的值；q是一个固定值，因为q是算法是已知算法
+
如果删除至还剩余k个元素，且k小于q时，此时q算法无法被调用。但此时还需要<span class="math inline">\(O(q^2)\)</span>的固定代价额外处理即可</p>
<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>
]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Problem Set Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>【习题解答】 蛮力算法设计</title>
    <url>/2021/03/29/algorithms3-hw/</url>
    <content><![CDATA[<p><strong><em>注：</em></strong>
<em>本题解为个人完成，难免有疏漏，请勿抄袭，仅供参考，同时欢迎留言指正。</em>
##3.2 ###(1)
<strong>大概说一下证明思路，用类似于数学归纳法的写法(基本情况+归纳推理)来证明循环不变量即可。</strong></p>
<ol type="i">
<li>对于内循环，循环不变量是：</li>
</ol>
<p>在循环结束时，<span class="math inline">\(A[j]\)</span>始终比<span class="math inline">\(A[1\cdots j-1]\)</span>中的元素大；</p>
<ol start="2" type="i">
<li>对于外循环，循环不变量是：</li>
</ol>
<p>在循环结束时，<span class="math inline">\(A[i\cdots
n]\)</span>部分按从小到大排好序了。</p>
<p>注意，本题解已经是一个清晰的思路，具体写法细节不再赘述。</p>
<p>###(2)
题干说明了以比较操作为关键操作，那么最坏情况时间复杂度和平均时间复杂度是一样的。</p>
<p>都是<span class="math inline">\(\sum\limits_{i=n}^{2}\sum\limits_{j=1}^{i-1}
1=\Theta(n^2)\)</span></p>
<p>###(3)
这个改进非常精巧，最后一次交换的位置如果为p，意味着p右侧的元素都已经排好序了(否则最后一次交换会发生在p的右边，从而矛盾)，且p左侧的元素一定都不比p位置的大(否则左侧该元素在当初的内循环中就会被冒泡到p右侧才对，矛盾)。</p>
<p>由于没告诉输入的概率分布，但是容易验证对于很多输入，时间复杂度都有改进，所以可以认为平均时间复杂度是有影响的；但如果假设数组中一个数比另一个数大的概率都是0.5，那么平均复杂度还是<span class="math inline">\(\Theta(n^2)\)</span>，从这个角度似乎也可以回答平均时间复杂度没有影响，但需给出合理解释；对于全逆序输入，最后一次交换始终发生在内循环的最后一次，因此最坏时间复杂度不会减小，还是<span class="math inline">\(\Theta(n^2)\)</span></p>
<p>##3.5 ### 算法设计 <img src="/2021/03/29/algorithms3-hw/3_5.png" class title="this is algorithms"></p>
<h3 id="正确性证明和复杂度分析">正确性证明和复杂度分析</h3>
<p>外循环是从<span class="math inline">\(i=1\)</span>开始，但我们可以把<span class="math inline">\(A[0]\)</span>当作是一个非常大的数，以保证输出的合法性。</p>
<p><strong>先如下证明两个循环不变量</strong>：</p>
<p>(i)每次外循环结束都得到<span class="math inline">\(P[i]=dst \in
[0,i)\)</span></p>
<p>其中<span class="math inline">\(dst\)</span>满足<span class="math inline">\(A[dst]&gt;A[i]\)</span>且<span class="math inline">\(\forall x \in A[dst+1,\cdots ,i-1],x\leq
A[i]\)</span>;</p>
<p>(ii)每次内循环进行条件判断时，<span class="math inline">\(A[j+1,\cdots,i-1]\)</span>中没有元素大于等于<span class="math inline">\(A[j]\)</span>且没有元素大于<span class="math inline">\(A[i]\)</span></p>
<p>我们发现这两个不变量的证明相互有联系，单独的用证明其中一个比较困难，因此考虑用<strong>强数学归纳法</strong>的思路来做：</p>
<p>(1)基本情况：</p>
<p>第一次外循环，显然找到了<span class="math inline">\(dst=0\)</span>，循环不变量满足;</p>
<p>每次外循环的第一次内循环也满足循环不变量，因为<span class="math inline">\(A[j]\)</span>和<span class="math inline">\(A[i]\)</span>之间没有元素。</p>
<p>(2)归纳推理：</p>
<ul>
<li>假设前<span class="math inline">\(i-1\)</span>次外循环都满足循环不变量，即<span class="math inline">\(P[1,\cdots,i-1]\)</span>都已经赋值正确的结果。</li>
<li>假设第<span class="math inline">\(i\)</span>次外循环的前<span class="math inline">\(k-1\)</span>次内循环都满足循环不变量</li>
</ul>
<p>那么对于第<span class="math inline">\(i\)</span>次外循环的第<span class="math inline">\(k\)</span>次内循环，反设其不满足内循环的不变量，即存在一个<span class="math inline">\(j &lt; q &lt; i\)</span>，使得<span class="math inline">\(A[q]\geq A[j]\)</span>或<span class="math inline">\(A[q]&gt;A[i]\)</span>，如果有多个满足的<span class="math inline">\(q\)</span>，我们取最靠近<span class="math inline">\(j\)</span>的。</p>
<ul>
<li>若<span class="math inline">\(q = i-1\)</span> 且<span class="math inline">\(A[q]&gt;A[i]\)</span>，则矛盾在于第i次外循环的内循环的第一次条件判断就不生效，<span class="math inline">\(A[j]\)</span>仍然不会被访问到</li>
<li>若<span class="math inline">\(q = i-1\)</span> 且<span class="math inline">\(A[i]\geq A[q]\geq A[j]\)</span>，则矛盾在于<span class="math inline">\(A[j+1,\cdots,q-1]\)</span>中没有比<span class="math inline">\(A[j]\)</span>大的元素，则<span class="math inline">\(P[q]&lt;j\)</span>，<span class="math inline">\(A[j]\)</span>不会被访问到</li>
<li>若<span class="math inline">\(q \neq i-1\)</span> 且<span class="math inline">\(A[q]&gt;A[i]\)</span>，则<span class="math inline">\(A[q]&gt;A[i]\geq A[i-1]\)</span>,则<span class="math inline">\(A[q]\)</span>一定比<span class="math inline">\(A[j]\)</span>先被跳转到，矛盾在于<span class="math inline">\(P[q]&lt;j\)</span>，则<span class="math inline">\(A[j]\)</span>不会被访问到</li>
<li>若<span class="math inline">\(q \neq i-1\)</span> 且<span class="math inline">\(A[i]\geq A[q]\geq A[j]\)</span>，则<span class="math inline">\(A[q]\geq A[j]\geq A[i-1]\)</span>，故<span class="math inline">\(A[q]\)</span>一定比<span class="math inline">\(A[j]\)</span>先在内循环访问到，则<span class="math inline">\(P[q]&lt;j\)</span>，则<span class="math inline">\(A[j]\)</span>不会被访问到</li>
</ul>
<p>因此第<span class="math inline">\(i\)</span>次外循环的第<span class="math inline">\(k\)</span>次内循环必然满足循环不变量。而最后一次内循环条件判断不生效后，也就找到了<span class="math inline">\(A[i]\)</span>左边比其大且最靠近的元素的下标。这样第<span class="math inline">\(i\)</span>次外循环结束时，外循环不变量也得到了满足。</p>
<p><em>两个循环不变量的证明就完成了，但题目还没解答完成。</em></p>
<p>因为<strong>外循环最后一次的不变量满足，所以获得正确结果<span class="math inline">\(P[1,\cdots,n]\)</span>，算法正确</strong>。</p>
<p>把<span class="math inline">\(P[1,\cdots,n]\)</span>是用于跳转下标的，如果第i次外循环在位置<span class="math inline">\(jp\)</span>对应的内循环中发生了跳转，则说明<span class="math inline">\(A[i]\geq
A[jp]\)</span>，由已经证明的内循环不变量，<span class="math inline">\(A[jp+1,\cdots,i-1]\)</span>中元素都比<span class="math inline">\(A[jp]\)</span>小，因此在第<span class="math inline">\(jp+1,\cdots,i-1\)</span>次外循环中都不可能使用跳转<span class="math inline">\(P[jp]\)</span>;而第w次外循环(<span class="math inline">\(\forall w&gt;i\)</span>)也不可能使用跳转<span class="math inline">\(P[jp]\)</span>，否则找到<span class="math inline">\(i\in (jp,w)\)</span>，使得<span class="math inline">\(A[i]\geq
A[jp]\)</span>，不满足内循环的不变量。<strong>因此在整个程序运行过程中，跳转数组<span class="math inline">\(P\)</span>的每个元素最多被使用1次，内循环是线性代价，而外循环也是线性的，故算法复杂度是<span class="math inline">\(\Theta(n)\)</span></strong></p>
<p>##3.6
<em>本题算法较直观，只给出大概思路，而不是算法格式的答案。此外注意，一般空间开销都是指除了保存输入数据以为额外引入的空间开销。</em>
###(1) 时间复杂度<span class="math inline">\(O(n^2)\)</span>，空间复杂度<span class="math inline">\(O(1)\)</span>的算法</p>
<p>用冒泡排序的思想，外循环是对于1到k的部分，内循环是将其移动到数组的倒数对应位置。</p>
<p>###(2) 时间复杂度<span class="math inline">\(O(n)\)</span>，空间复杂度<span class="math inline">\(O(n)\)</span>的算法</p>
<p>引入额外空间开销，保存数组的两个分解子数组，然后合并即可</p>
<p>###(3) 时间复杂度<span class="math inline">\(O(n)\)</span>，空间复杂度<span class="math inline">\(O(1)\)</span>的算法</p>
<p>对于一个数组<span class="math inline">\(A[n]\)</span>，将其整体翻转的复杂度是线性的：只需要一次循环，从两侧往中间遍历，两边交换位置，重合时结束循环。</p>
<p>那么符合题目要求的算法可以是：对于数组的左右两个子数组，分布进行一次翻转，然后再对整个大数组作一个翻转。这样三次翻转，复杂度是<span class="math inline">\(O(n)\)</span>，并且引入O(1)的额外空间即可(每次交换元素位置的时候使用)。</p>
<p>##3.7
答：本题思路和3.6的第(3)问解法一样，即子串分别翻转、总串再整体翻转一次，时间复杂度<span class="math inline">\(O(n)\)</span>,空间复杂度<span class="math inline">\(O(1)\)</span>。</p>
<p>##3.8 (1) +
0个名人的情况，比如大家谁都不关注的情况，因为名人是需要被其他人关注的。
+ 1个名人的情况，比如大家都关注甲，甲不关注任何其他人 +
超过1个名人的情况，比如名人有甲和乙，因为甲是名人，故甲不关注乙；因为乙是名人，所以甲关注乙，矛盾。</p>
<p>所以要么0个名人，要么有1个名人。</p>
<ol start="2" type="1">
<li>简单的思路就是两层遍历，第i层外循环的任务是判断第i个是不是名人，而内循环就是问其他人有没有关注第i个人。</li>
</ol>
<p>而改进的思路是这样的，随便抽两个人A和B，问A是否关注了B。 +
A关注了B，则A不是名人，删除A + A没关注B，则B不是名人，删除B</p>
<p>一直删到只剩下一个人的时候，该人就是候选名人，一次循环判断该唯一的候选名人是不是名人即可，复杂度<span class="math inline">\(\Theta(n)\)</span>。</p>
<p>##3.9 <em>只给思路，具体算法细节略去</em> ###(1)
两层外循环确定子序列首尾的下标，最内循环计算加和，然后三层循环找到最大的子序列和即可。</p>
<p>复杂度<span class="math inline">\(O(n^3)\)</span></p>
<p>###(2)
前一问给出的算法的最内层循环是很多余的，可以在第二层循环，即移动子序列尾部下标的同时，以O(1)的时间代价更新子序列的和。</p>
<p>复杂度<span class="math inline">\(O(n^2)\)</span></p>
<p>###(3) 每次把数组分成左右两半，最大连续子序列只可能出现在以下的情况：
(i) 左半边和右半边的单侧，这种情况递归求解即可 (ii)
跨越左右两侧，这种情况用线性时间代价求得“以左边最后一个元素结尾的最大连续子序列”、“以右边第一个元素开始的最大连续子序列”，然后相加即可</p>
<p>然后在上述的情况中选最大的连续子序列即可。</p>
<p>时间复杂度由master定理：<span class="math inline">\(T(n)=2T(n/2)+O(n)\)</span>，复杂度是<span class="math inline">\(O(n\ log\ n)\)</span></p>
<p>###(4)
一次遍历即可，第i次循环，求得以第i个元素结尾的最大连续子序列的和。</p>
<p>基本情况：第1次循环显然O(1)获得以第1个元素结尾的最大连续子序列的和是<span class="math inline">\(S[1]\)</span>。</p>
<p>归纳推理：加入已经知道了以第i-1个元素结尾的最大连续子序列的和是<span class="math inline">\(tmp\)</span></p>
<ul>
<li>若tmp大于0，则以第i个元素结尾的最大连续子序列的和是<span class="math inline">\(tmp+S[i]\)</span></li>
<li>若tmp小于等于0，则以第i个元素结尾的最大连续子序列的和是<span class="math inline">\(S[i]\)</span></li>
</ul>
<p>我们发现循环体内的时间开销是常数级O(1)，所以整个算法是线性的时间复杂度<span class="math inline">\(O(n)\)</span>。</p>
<p>###(5)
<em>动态规划直观的思想就是保存中间有用的结果，并通过调整计算的顺序，来消除冗余的步骤。</em></p>
<p>先考虑子问题：<strong>求解以第i个元素结尾的最大子序列的和</strong>，i从1到n。</p>
<p>求这些子问题得到的中间结果是值得保存的，假设保存在数组<span class="math inline">\(MaxSum[1,...,n]\)</span>中</p>
<p>状态转移方程是<span class="math inline">\(MaxSum[i] = \max\{
MaxSum[i-1] + A[i], A[i]\}\)</span></p>
<p>这样每次状态转移都是<span class="math inline">\(O(1)\)</span>的代价，MaxSum填满需要<span class="math inline">\(O(n)\)</span>代价，那么在MaxSum中遍历一遍找到最大值即是最大连续子序列的和。</p>
<p>用动态规划时间复杂度是<span class="math inline">\(O(n)\)</span>。</p>
<p><strong>注：其实(4)的方法本质就是动态规划的思想：保存中间的有用结果，以及讲究计算的顺序；同时由(4)的思路可以把(5)的方法在空间复杂度上改进到O(1)</strong></p>
<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>
]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Problem Set Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>【习题解答】 分治排序</title>
    <url>/2021/04/10/algorithms4-hw/</url>
    <content><![CDATA[<p><strong><em>注：</em></strong>
<em>本题解为个人完成，难免有疏漏，请勿抄袭，仅供参考，同时欢迎留言指正。</em>
## 4.1
<em>利用数学归纳法即可，本题的归纳推理除了个人推荐的自顶向下的方式，也可以自底向上。</em>
+ <span class="math inline">\(h=0\)</span>的情况，只有一个根节点，<span class="math inline">\(L=1\leq 2^0 =2^h\)</span> + 假设<span class="math inline">\(h=k\)</span>的情况，k是非负整数，有命题成立，则对于任意<span class="math inline">\(h=k+1\)</span>的情况，可以把这个树分解为根节点和左右子树，这里有左右子树的树高不超过k显然成立
，则叶子总数量<span class="math inline">\(L=L_{left}+L_{right}\leq
2^k+2^k=2^{k+1}\)</span>。 + 故命题成立</p>
<h2 id="section">4.4</h2>
<p><em>注意体会这两道题的区别，和解答思路的区别</em>
1）只需要给出一个满足条件的算法，最坏情况用5次比较对4个元素排序，我们知道可以花3次比较来确定其中三个数的序关系，即<span class="math inline">\(\dbinom{3}{2}=3\)</span>。记排序后的三个数为<span class="math inline">\(a,b,c\)</span>，则对于最后一个数<span class="math inline">\(d\)</span>的序，我们第4次比较把它和中位数<span class="math inline">\(b\)</span>进行比较，无论比较结果如何，至少能确定<span class="math inline">\(d\)</span>和<span class="math inline">\(a,b,c\)</span>其中的2个的序关系，然后第5次比较留给最后一个不确定的序关系即可。</p>
<p>具体算法的规范书写从略。</p>
<ol start="2" type="1">
<li>本题不光要找到一个算法，对5个元素进行排序，并且要证明在最坏情况下这个方法是最优的。那么理论上就需要穷尽所有的比较方法，然后找到其中最优的方法。个人尝试了一下决策树和穷举的思路，过于复杂，这里推荐另一种思路：<strong>先放缩得到算法比较次数的下界，再给出最坏情况下能取到下界比较次数的算法。</strong></li>
</ol>
<p>我们考虑5个元素所有可能的序关系的集合，一开始没进行任何比较，集合大小是全排列5!=120。
对于一次比较，可以把集合<strong>划分</strong>为两个子集合，设其大小为<span class="math inline">\(size_1,size_2\)</span>。最坏情况下最多只能消除<span class="math inline">\(\min\{size_1,size_2\}\leq\frac{size_1+size_2}{2}\)</span>的元素,故对于大小为120的集合，比较次数的下界是<span class="math inline">\(\lceil
log{120}\rceil=7\)</span>。下面再给出一个具体的算法，最坏情况比7次即可，下面只给出思路：
+ 第一次比较，1和2比 + 第二次比较，3和4比 + 第三次比较，<span class="math inline">\(\max\{1,2\}\)</span>和<span class="math inline">\(\max\{3,4\}\)</span>比，得到<span class="math inline">\(max\{1,2,3,4\}\)</span> + 第四次比较，<span class="math inline">\(\min\{1,2\}\)</span>和<span class="math inline">\(\min\{3,4\}\)</span>比，得到<span class="math inline">\(min\{1,2,3,4\}\)</span> +
第五、六、七次比较，把5个数中除去最大值和最小值剩下的三个数排序</p>
<p>按这个思路表达成算法形式即可，详略。</p>
<h2 id="section-1">4.8</h2>
<p>这个题目需要结合线性时间选择算法，后面的章节中是有详细讲解的。那不妨假设已经知道了，可以以<span class="math inline">\(O(n)\)</span>的复杂度找到<span class="math inline">\(n\)</span>个数的中位数，那么由中位数把原数组一分为二，则可以用分治思想，先解决原问题(<span class="math inline">\(n\)</span>个数排成<span class="math inline">\(k-sorted\)</span>)分解后两个子问题(<span class="math inline">\(\frac{n}{2}\)</span>个数排成<span class="math inline">\(\frac{k}{2}-sorted\)</span>)。</p>
<p>因为不适合用<span class="math inline">\(master\)</span>定理，我们直接求和计算即可，<span class="math inline">\(n+2\times(\frac{n}{2})+4\times(\frac{n}{4})+\cdots+\frac{k}{2}\times\frac{n}{\frac{k}{2}}\)</span>，项数为<span class="math inline">\(log\ k\)</span></p>
<p>故最后的复杂度是<span class="math inline">\(O(nlog\
k)\)</span>，详细的算法书写从略。</p>
<p>注：本题还有一个基于堆的实现方法，复杂度也是<span class="math inline">\(nlog\
k\)</span>。大概方法就是以每个子数组的首元素进行堆排序，<span class="math inline">\(n\)</span>次<span class="math inline">\(log\
k\)</span>的调整，总复杂度<span class="math inline">\(k+nlog\ k=O(nlog\
k)\)</span>。</p>
<h2 id="section-2">4.9</h2>
<p>只给思路，假设螺钉的数组是<span class="math inline">\(A[1\cdots
n]\)</span>,螺母的数组是<span class="math inline">\(B[1\cdots
n]\)</span>,则在<span class="math inline">\(A\)</span>中随便取一个元素<span class="math inline">\(a\)</span>，可以把<span class="math inline">\(B\)</span>分解为三个部分<span class="math inline">\(B_l,{b},B_r\)</span>，其中螺钉<span class="math inline">\(a\)</span>螺母<span class="math inline">\(b\)</span>是吻合的。然后再用<span class="math inline">\(B\)</span>中的<span class="math inline">\(b\)</span>把<span class="math inline">\(A\)</span>数组分为三个部分<span class="math inline">\(A_l,{a},A_r\)</span>，这样以<span class="math inline">\(O(n)\)</span>的复杂度就把问题分解了，并且子问题有两个(<span class="math inline">\(B_l,A_l\)</span>和<span class="math inline">\(B_r,A_r\)</span>)，规模都是原先的一半。</p>
<p>故由主定理可以知道，平均情况复杂度是<span class="math inline">\(O(nlog\ n)\)</span>，本质还是快排的思想。</p>
<h2 id="section-3">4.11</h2>
<p><strong>注：根据评论区留言，答案已修正，更新时间2022.4.17</strong>
### (1) 反证即可，设对于<span class="math inline">\(i\)</span>,<span class="math inline">\(j\)</span>之间的任意一个元素<span class="math inline">\(k\)</span>,如果<span class="math inline">\((i,k)\)</span>、<span class="math inline">\((k,j)\)</span>都不是逆序，则<span class="math inline">\((i,j)\)</span>不是逆序，矛盾。故<span class="math inline">\(k\)</span>必然对应一个逆序对，故<span class="math inline">\((i,j)\)</span>之间的<span class="math inline">\(j-i-1\)</span>个元素至少对应了<span class="math inline">\(j-i-1\)</span>个逆序对，加上<span class="math inline">\((i,j)\)</span>本身是逆序对，故逆序对个数<span class="math inline">\(n\geq j-i\)</span>，由已知逆序对至多有<span class="math inline">\(2\)</span>个，故<span class="math inline">\(2\geq
n \geq j-i\)</span>，命题得证。</p>
<h3 id="section-4">(2)</h3>
<p>本质就是要求不超过<span class="math inline">\(n\)</span>次比较，找到所有的逆序对 +
先把所有相邻的两个元素比较 *
此过程中每找到了逆序对(k,k+1)，都跳过下一次比较(k+1,k+2)，因为这一定不是逆序对，否则(k,k+2)也是逆序对，矛盾。
+ 若共发现<span class="math inline">\(0\)</span>对逆序对，无逆序对，比较<span class="math inline">\(n-1\)</span>次 + 若共发现<span class="math inline">\(2\)</span>对逆序对，则无其他逆序对，比较<span class="math inline">\(n-1-2=n-3\)</span>次 + 若发现<span class="math inline">\(1\)</span>对逆序对，假设位置是<span class="math inline">\((k,k+1)\)</span>，则左边的部分(下标<span class="math inline">\(1\)</span>到<span class="math inline">\(k\)</span>)已经排好序，右边的部分(下标<span class="math inline">\(k+1\)</span>到<span class="math inline">\(n\)</span>)也已经排好序，若存在另一个逆序对，可设为<span class="math inline">\((l,r)\)</span>，此时<span class="math inline">\(l\)</span>一定在左部分，<span class="math inline">\(r\)</span>一定在右部分。且根据第一题，我们知道<span class="math inline">\(l\)</span>和<span class="math inline">\(r\)</span>之间恰隔了一个元素。故另一个逆序对若存在，则只可能是<span class="math inline">\((k-1,k+1)\)</span>或<span class="math inline">\((k,k+2)\)</span>两者中的一个。所以再检查这两对即可。比较<span class="math inline">\(n-1-1+2=n\)</span>次</p>
<p>因此最坏情况下，比较次数不超过<span class="math inline">\(n\)</span>。</p>
<p>##4.14 两次排序即可： + 先把每个词自身排个序，作为每个词的属性 +
然后词之间按属性排序</p>
<p>最后判断相邻的词属性是不是一样即可，因此所有易位词都相邻了。</p>
<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>
]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Problem Set Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>【习题解答】 线性时间选择</title>
    <url>/2021/04/14/algorithms5-hw/</url>
    <content><![CDATA[<p><strong><em>注：</em></strong>
<em>本题解为个人完成，难免有疏漏，请勿抄袭，仅供参考，同时欢迎留言指正。</em>
## 5.2 假设5个数分别为<span class="math inline">\(a1,a2,a3,a4,a5\)</span>。找中位数就是找第3小的数。</p>
<ul>
<li><p><span class="math inline">\(a1:a2\)</span>，若<span class="math inline">\(a1&gt;a2\)</span>则<span class="math inline">\(swap(a1,a2)\)</span>，使得<span class="math inline">\(a1&lt;a2\)</span></p></li>
<li><p><span class="math inline">\(a3:a4\)</span>，若<span class="math inline">\(a3&gt;a4\)</span>则<span class="math inline">\(swap(a3,a4)\)</span>，使得<span class="math inline">\(a3&lt;a4\)</span></p></li>
<li><p><span class="math inline">\(a1:a3\)</span>，若<span class="math inline">\(a1&gt;a3\)</span>则<span class="math inline">\(swap(a1,a3),swap(a2,a4)\)</span>，使得<span class="math inline">\(a1&lt;a3\)</span>，且不影响<span class="math inline">\(a1&lt;a2,a3&lt;a4\)</span>，此时<span class="math inline">\(a1\)</span>比至少3个数小，故不可能是第3小的数，于是接下来考虑<span class="math inline">\(a2,a3,a4,a5\)</span>中第2小的数</p></li>
<li><p><span class="math inline">\(a2:a5\)</span>，若<span class="math inline">\(a2&gt;a5\)</span>则<span class="math inline">\(swap(a2,a5)\)</span>，使得<span class="math inline">\(a2&lt;a5\)</span></p></li>
<li><p><span class="math inline">\(a2:a3\)</span>，若<span class="math inline">\(a2&gt;a3\)</span>则<span class="math inline">\(swap(a2,a3),swap(a5,a4)\)</span>，使得<span class="math inline">\(a2&lt;a3\)</span>，且不影响<span class="math inline">\(a2&lt;a5,a3&lt;a4\)</span>。故此时<span class="math inline">\(a2\)</span>是四个数中的最小值，不可能是第2小；又<span class="math inline">\(a4\)</span>比<span class="math inline">\(a2,a3\)</span>都大，故也不可能是第2小。故接下来考虑<span class="math inline">\(a3,a5\)</span>中较小的那个即可</p></li>
<li><p><span class="math inline">\(a3:a5\)</span>，较小的那个是中位数</p></li>
</ul>
<p>如果用决策树表示这个算法，每个非叶节点给出哪两个数之间比较，两个不同的比较结果分别导向左右子树。</p>
<img src="/2021/04/14/algorithms5-hw/5_2.png" class title="this is decisionTree">
<p>最后一层比较得到的较小者就是中位数，由于画的太密集，叶子节点没有画出来。</p>
<h2 id="section">5.4</h2>
<p>基于比较的算法来找阶为<span class="math inline">\(k\)</span>的数，我们可以用图的角度理解： + <span class="math inline">\(n\)</span>个元素对应<span class="math inline">\(n\)</span>个点 +
给定一个比较，确定一个有向边，那么边的方向是从大元素到小元素的 +
那么算法结束时，找到了阶为<span class="math inline">\(k\)</span>的数<span class="math inline">\(m\)</span>，同时也构造了一个图<span class="math inline">\(G\)</span> + 对于<span class="math inline">\(m\)</span>节点在<span class="math inline">\(G\)</span>中可以到达的所有节点的集合记为<span class="math inline">\(D\)</span>，所有可以到达<span class="math inline">\(m\)</span>节点的集合记为<span class="math inline">\(S\)</span>，其他的节点集合记为<span class="math inline">\(N\)</span>。</p>
<p>接下来以问答的形式进行深入思考： + <span class="math inline">\(G\)</span>一定满足什么条件？ + <span class="math inline">\(N\)</span>中的元素可以存在哪些边？ + 如果把<span class="math inline">\(N\)</span>中的每个节点都添加一条指向<span class="math inline">\(m\)</span>节点的边，会不会违背刚刚的条件？为什么？
+ <span class="math inline">\(||D||\)</span>的大小和<span class="math inline">\(i-1\)</span>的关系？ + <span class="math inline">\(||S||\)</span>的大小和<span class="math inline">\(n-i\)</span>的关系？</p>
<p>想通上面的过程，原命题显然得证。</p>
<h2 id="section-1">5.5</h2>
<p>经典找中位数后二分，每次规模减半。</p>
<p><span class="math inline">\(f(n)=f(\frac{n}{2})+O(n)\)</span></p>
<p>由主定理最坏情况复杂度还是<span class="math inline">\(O(n)\)</span></p>
<h2 id="section-2">5.6</h2>
<h3 id="section-3">(1)</h3>
<p>全部元素排序即可，如堆排、归并排序等，注意快排不行。</p>
<h3 id="section-4">(2)</h3>
<p>由<span class="math inline">\(klog\ n\)</span>自然想到用堆。</p>
<p>建堆<span class="math inline">\(O(n)\)</span>，<span class="math inline">\(k\)</span>次pop是<span class="math inline">\(O(klog\ n)\)</span></p>
<h3 id="section-5">(3)</h3>
<p>由<span class="math inline">\(k^2\)</span>自然想到对前<span class="math inline">\(k\)</span>大的数进行冒泡排序(或选择排序)。</p>
<p>找第<span class="math inline">\(k\)</span>大数，并以此找到未排序的前<span class="math inline">\(k\)</span>大数<span class="math inline">\(O(n)\)</span></p>
<p>对<span class="math inline">\(k\)</span>个数冒泡排序<span class="math inline">\(k^2\)</span>。</p>
<h3 id="section-6">(4)</h3>
<p>由<span class="math inline">\(klog\ k\)</span>自然想到对前<span class="math inline">\(k\)</span>大的数进行堆排序。</p>
<p>找第<span class="math inline">\(k\)</span>大数，并以此找到未排序的前<span class="math inline">\(k\)</span>大数<span class="math inline">\(O(n)\)</span></p>
<p>对<span class="math inline">\(k\)</span>个数堆排序<span class="math inline">\(klog\ k\)</span>。</p>
<h2 id="section-7">5.7</h2>
<h3 id="section-8">(1)</h3>
<ul>
<li>对n个数进行排序，<span class="math inline">\(O(nlog\
n)\)</span></li>
<li>k次循环，每次选取中位数前后数中较近的那个数，<span class="math inline">\(k\times O(1)\)</span></li>
</ul>
<h3 id="section-9">(2)</h3>
<ul>
<li>先找到中位数、以及第<span class="math inline">\(\frac{n}{2}-k\)</span>大的数、第<span class="math inline">\(\frac{n}{2}+k\)</span>大的数，<span class="math inline">\(O(n)\)</span></li>
<li>找到比中位数小，且最接近中位数的k个数，并排序，<span class="math inline">\(O(n+klog\ k)\)</span></li>
<li>找到比中位数大，且最接近中位数的k个数，并排序，<span class="math inline">\(O(n+klog\ k)\)</span></li>
<li>k次循环，每次选取中位数前后数中较近的那个数，<span class="math inline">\(k\times O(1)\)</span></li>
</ul>
<h2 id="section-10">5.9</h2>
<h3 id="section-11">(1)</h3>
<ul>
<li>先找到A,B数组各自的第<span class="math inline">\(\lfloor\frac{k}{2}\rfloor\)</span>小的数a和b</li>
<li>若a小于b，则a的阶比k小，删除A的前<span class="math inline">\(\lfloor\frac{k}{2}\rfloor\)</span>个元素，反之删除B的前<span class="math inline">\(\lfloor\frac{k}{2}\rfloor\)</span>个元素</li>
<li>令<span class="math inline">\(k=k-\lfloor\frac{k}{2}\rfloor\)</span></li>
<li>重复直至<span class="math inline">\(k=1\)</span>，思考为什么一定会到1？</li>
<li>A,B表头中较小的那个就是结果</li>
</ul>
<p>复杂度是<span class="math inline">\(O(log\ k)\)</span></p>
<h3 id="section-12">(2)</h3>
<ul>
<li>先找到A,B数组各自的第<span class="math inline">\(\lfloor\frac{k}{3}\rfloor\)</span>小的数a,b,c</li>
<li>找到a,b,c中最小者，比如是a，则a的阶比k小，删除A的前<span class="math inline">\(\lfloor\frac{k}{3}\rfloor\)</span>个元素，反之删除B或C的前<span class="math inline">\(\lfloor\frac{k}{3}\rfloor\)</span>个元素</li>
<li>令<span class="math inline">\(k=k-\lfloor\frac{k}{3}\rfloor\)</span></li>
<li>重复直至<span class="math inline">\(k\in
\[1,2\]\)</span>，思考为什么一定会落到这个范围？</li>
<li>重复取A,B,C表头中最小值<span class="math inline">\(k\)</span>次，注意此时<span class="math inline">\(k\leq 2\)</span></li>
</ul>
<p>复杂度是<span class="math inline">\(O(log\ k)\)</span></p>
<h3 id="section-13">(3)</h3>
<p><strong>注：根据评论区的留言，更新了复杂度的计算过程，算出了复杂度更紧的上界</strong></p>
<p>还是按照之前的思路即可: + 先找到每一行数组各自的第<span class="math inline">\(\lfloor\frac{k}{m}\rfloor\)</span>小的数<span class="math inline">\(x_1,x_2,\cdots,x_m\)</span> +
找到其中的最小者，比如是<span class="math inline">\(x_1\)</span>，则<span class="math inline">\(x_1\)</span>的阶比k小，删除第一行的前<span class="math inline">\(\lfloor\frac{k}{m}\rfloor\)</span>个元素，反之删除对应行的前<span class="math inline">\(\lfloor\frac{k}{m}\rfloor\)</span>个元素 + 令<span class="math inline">\(k=k-\lfloor\frac{k}{m}\rfloor\)</span> +
重复直至<span class="math inline">\(k\in
\[1,m\]\)</span>，思考为什么一定会落到这个范围？ +
重复取m行表头中最小值<span class="math inline">\(k\)</span>次，且<span class="math inline">\(k\leq m\)</span>，这里带来的开销是<span class="math inline">\(O(m^2)\)</span>，可以用堆优化为<span class="math inline">\(O(m\ log\ m)\)</span></p>
<p>我们分析一下总的复杂度：</p>
<p>每次<span class="math inline">\(k\)</span><strong>几乎</strong>是变成原本的<span class="math inline">\(1-\frac{1}{m}\)</span>，因为base case是<span class="math inline">\(k\in \[1,m\]\)</span>，则可以解停止条件<span class="math inline">\((1-\frac{1}{m})^t\times k \leq
m\)</span>，得比较次数<span class="math inline">\(t \geq \frac{log\
\frac{k}{m}}{log\ \frac{m}{m-1}}=t_m\)</span>，即比较次数大于<span class="math inline">\(t_m\)</span>，比如取<span class="math inline">\(t=t_m+1\)</span>即可达到base case。</p>
<p><strong>注意:这里之所以说几乎，是因为有取整操作，即<span class="math inline">\(k=k-\lfloor\frac{k}{m}\rfloor=\lceil\frac{m-1}{m}k\rceil\)</span>，但是这不影响<span class="math inline">\(k\)</span>的更新次数<span class="math inline">\(t\)</span>的量级，为什么？</strong></p>
<p>可以这样想： + 对于<span class="math inline">\(k\)</span>的第<span class="math inline">\(\lambda\)</span>次迭代，<span class="math inline">\(k^{(\lambda)}=k^{(\lambda-1)}-\lfloor\frac{k^{(\lambda-1)}}{m}\rfloor=k^{(\lambda-1)}-\frac{k^{(\lambda-1)}}{m}+\epsilon\)</span>，考虑取整(<span class="math inline">\(0\leq \epsilon\leq 1\)</span>)和不取整(<span class="math inline">\(\epsilon=0\)</span>)两个情况中<span class="math inline">\(-\frac{k^{(\lambda-1)}}{m}\)</span>的大小关系？<span class="math inline">\(\epsilon\)</span>的大小关系？ +
在不考虑取整时，之前分析过，<span class="math inline">\(k\)</span>最多迭代<span class="math inline">\(t_m\)</span>次，<span class="math inline">\(k\)</span>就会达到停止条件(即<span class="math inline">\(k\leq m\)</span>) + 那么考虑取整时，<span class="math inline">\(k\)</span>迭代<span class="math inline">\(t_m\)</span>次后，因为这个过程中存在取整的操作，此时<span class="math inline">\(k\)</span>可能还没达到停止条件(即<span class="math inline">\(k\leq m\)</span>)，但此时必然有<span class="math inline">\(k\leq m+t_m\)</span>，想一想为什么？故<span class="math inline">\(k\)</span>最多再迭代<span class="math inline">\(t_m\)</span>次就可以达到停止条件，想一想为什么？ +
因此，迭代次数的量级不受取整的影响，考虑取整时的迭代次数最多是没考虑取整时的迭代次数的两倍</p>
<p>继续分析原问题的复杂度，结合每次都要找m个数中的最小值，即O(m)，得到总的复杂度是<span class="math inline">\(O(m\ log\ m+\frac{log\
\frac{k}{m}}{log(1+\frac{1}{m-1})}\times m)\)</span></p>
<p>其中<span class="math inline">\(log(1+\frac{1}{m-1})\)</span>可以用泰勒展开改写成<span class="math inline">\(\frac{1}{m-1}\)</span>的形式，因此复杂度是<span class="math inline">\(O(m^2\times log\ \frac{k}{m})\)</span></p>
<h2 id="section-14">5.10</h2>
<h3 id="section-15">(1)</h3>
<p>按定义证明即可</p>
<p>设中位数为<span class="math inline">\(x_{m}\)</span>，则其满足<span class="math inline">\(\sum\limits_{x_i &lt;
x_m}1&lt;\frac{n}{2}\)</span> 且<span class="math inline">\(\sum\limits_{x_i &gt;
x_m}1\leq\frac{n}{2}\)</span></p>
<p>再证明此数满足加权中位数定义即可： <span class="math inline">\(\sum\limits_{x_i &lt; x_m}w_i=\sum\limits_{x_i
&lt; x_m}\frac{1}{n}&lt;\frac{1}{2}\)</span> 且<span class="math inline">\(\sum\limits_{x_i &gt; x_m}w_i=\sum\limits_{x_i
&gt; x_m}\frac{1}{n}\leq\frac{1}{2}\)</span></p>
<h3 id="section-16">(2)</h3>
<ul>
<li>使用最坏情况复杂度是<span class="math inline">\(O(nlog\
n)\)</span>的排序</li>
<li>遍历一遍，计算权重和，当不满足<span class="math inline">\(\sum\limits_{i\leq m}
w_i&lt;\frac{1}{2}\)</span>时停止，此时的<span class="math inline">\(x_i\)</span>即加权中位数</li>
<li>最好再证明一下正确性(是否满足定义的那两条)</li>
</ul>
<h3 id="section-17">(3)</h3>
<ul>
<li>线性时间选择找到中位数</li>
<li>若<span class="math inline">\(\sum\limits_{x_i&lt;x_k}w_i\geq\frac{1}{2}\)</span>，对左半部分递归</li>
<li>若<span class="math inline">\(\sum\limits_{x_i&gt;x_k}w_i&gt;\frac{1}{2}\)</span>，对右半部分递归</li>
<li>否则<span class="math inline">\(x_i\)</span>就是加权中位数</li>
<li>有一个实现上的细节：应该维护两个全局变量，分别保存子区间外以左和以右的权重和，每次调用递归前更新，<strong>这样做的目的是每次计算权重和的只需要考虑子区间的范围，避免冗余的计算</strong></li>
<li>用主定理分析复杂度为什么是<span class="math inline">\(O(n)\)</span></li>
</ul>
<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>
]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Problem Set Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>【习题解答】 对数时间查找</title>
    <url>/2021/04/15/algorithms6-hw/</url>
    <content><![CDATA[<p><strong><em>注：</em></strong>
<em>本题解为个人完成，难免有疏漏，请勿抄袭，仅供参考，同时欢迎留言指正。</em>
## 6.2 二分查找的区间范围设为<span class="math inline">\((a,b)\)</span>，并假定每轮开始时都已经知道以下四个变量的值：
+ <span class="math inline">\(v1=a^2\)</span> + <span class="math inline">\(v2=b^2\)</span> + <span class="math inline">\(v3=ab\)</span> + <span class="math inline">\(v4=(\frac{a+b}{2})^2\)</span></p>
<p>则比较<span class="math inline">\(v4\)</span>和<span class="math inline">\(N\)</span>的大小以后，可以以<span class="math inline">\(O(1)\)</span>的代价更新上面的变量，以进入左半边子区间为例
+ <span class="math inline">\(v1=a^2=v1\)</span> + <span class="math inline">\(v2=(\frac{a+b}{2})^2=v4\)</span> + <span class="math inline">\(v3=\frac{a^2+ab}{2}=\frac{v1+v3}{2}\)</span> +
<span class="math inline">\(v4=(\frac{a+\frac{a+b}{2}}{2})^2=\frac{a^2+a(a+b)+(\frac{a+b}{2})^2}{4}=\frac{v1+2\times
v3+v2}{4}\)</span></p>
<p>这样把单次的开销降到常数，总的开销就是<span class="math inline">\(O(log\ N)=O(n)\)</span></p>
<h2 id="section">6.3</h2>
<p><strong>思路是对递归定义使用数学归纳法，以证明始终符合直接定义</strong>。</p>
<p>直接定义： + 根黑色，叶黑色 + 红色节点不连续出现 +
任意节点为根的子树，叶的黑色深度相等，该深度即红黑树的黑色高度</p>
<p>递归定义： + 基本情况，<span class="math inline">\(RB_0\)</span>，即一颗黑色根，显然满足直接定义，黑色高度是0
+ 归纳推理，若<span class="math inline">\(RB_{1},\cdots,RB_{h-1}\)</span>都是满足红黑树直接定义。由递归定义知<span class="math inline">\(ARB_h\)</span>的根是红色，左右子树都是<span class="math inline">\(RB_{h-1}\)</span>； <span class="math inline">\(RB_h\)</span>的根是黑色，左右子树是<span class="math inline">\(RB_{h-1}\)</span>或<span class="math inline">\(ARB_{h}\)</span>。<strong>然后验证<span class="math inline">\(RB_h\)</span>是否满足那三条直接定义即可</strong></p>
<h2 id="section-1">6.4</h2>
<p>分为<strong>内部黑色节点、内部节点、高度</strong>三个部分来证明，每次用数学归纳法同时证明<span class="math inline">\(RB_h\)</span>和<span class="math inline">\(ARB_h\)</span>的情况。</p>
<ol type="1">
<li>首先证<span class="math inline">\(RB_h\)</span>有不少于<span class="math inline">\(2^h-1\)</span>个内部黑色节点，<span class="math inline">\(ARB_h\)</span>有不少于<span class="math inline">\(2^h-2\)</span>个内部黑色节点</li>
</ol>
<ul>
<li>基本情况：<span class="math inline">\(h=0\)</span>，<span class="math inline">\(RB_h\)</span>有0个内部黑色节点；<span class="math inline">\(h=1\)</span>，<span class="math inline">\(ARB_h\)</span>有0个内部节点，<span class="math inline">\(RB_h\)</span>有1个内部黑色节点</li>
<li>归纳推理：假设<span class="math inline">\(h=k(k\in
N)\)</span>，<span class="math inline">\(RB_k\)</span>有至少<span class="math inline">\(2^k-1\)</span>个内部黑色节点，<span class="math inline">\(ARB_k\)</span>有至少<span class="math inline">\(2^k-2\)</span>个内部黑色节点，则<span class="math inline">\(h=k+1\)</span>时，<span class="math inline">\(ARB_{k+1}\)</span>有至少<span class="math inline">\(2^k-1+2^k-1=2^{k+1}-2\)</span>内部黑色节点，<span class="math inline">\(RB_{k+1}\)</span>有至少<span class="math inline">\(1+2\min\{2^k-1,2^{k+1}-2\}=2^{k+1}-1\)</span>内部黑色节点</li>
<li>故对于任意非负整数<span class="math inline">\(h\)</span>，<span class="math inline">\(RB_h\)</span>有至少<span class="math inline">\(2^h-1\)</span>个内部黑色节点，<span class="math inline">\(ARB_h\)</span>有至少<span class="math inline">\(2^h-2\)</span>个内部黑色节点。</li>
</ul>
<ol start="2" type="1">
<li>然后证<span class="math inline">\(RB_h\)</span>有不超过<span class="math inline">\(4^h-1\)</span>个内部节点，<span class="math inline">\(ARB_h\)</span>有不超过<span class="math inline">\(\frac{1}{2}4^h-1\)</span>个内部节点</li>
</ol>
<ul>
<li>基本情况：<span class="math inline">\(h=0\)</span>，<span class="math inline">\(RB_h\)</span>有0个内部节点；<span class="math inline">\(h=1\)</span>，<span class="math inline">\(ARB_h\)</span>有1个内部节点，<span class="math inline">\(RB_h\)</span>最多有3个内部节点</li>
<li>归纳推理：假设<span class="math inline">\(h=k(k\in
N)\)</span>，<span class="math inline">\(RB_k\)</span>有不超过<span class="math inline">\(4^k-1\)</span>个内部节点，<span class="math inline">\(ARB_k\)</span>有不超过<span class="math inline">\(\frac{1}{2}4^k-1\)</span>个内部节点，则<span class="math inline">\(h=k+1\)</span>时，<span class="math inline">\(ARB_{k+1}\)</span>有最多<span class="math inline">\(1+4^k-1+4^k-1=\frac{1}{2}4^{k+1}-1\)</span>内部节点，<span class="math inline">\(RB_{k+1}\)</span>有最多<span class="math inline">\(1+2\max\{4^k-1,\frac{1}{2}4^{k+1}-1\}=4^{k+1}-1\)</span>内部节点</li>
<li>故对于任意非负整数<span class="math inline">\(h\)</span>，<span class="math inline">\(RB_h\)</span>有不超过<span class="math inline">\(4^h-1\)</span>个内部节点，<span class="math inline">\(ARB_h\)</span>有不超过<span class="math inline">\(\frac{1}{2}4^h-1\)</span>个内部节点</li>
</ul>
<ol start="3" type="1">
<li>最后证明<span class="math inline">\(RB_h\)</span>任意黑色节点的普通高度至多是该节点黑色高度的2倍，<span class="math inline">\(ARB_h\)</span>任意黑色节点的普通高度至多是该节点黑色高度的2倍</li>
</ol>
<ul>
<li>先用数学归纳法，证<span class="math inline">\(RB_h\)</span>的根的黑色高度是<span class="math inline">\(h\)</span>且<span class="math inline">\(ARB_h\)</span>的根的叶子的黑色高度是<span class="math inline">\(h-1\)</span></li>
<li>然后再用数学归纳法，证<span class="math inline">\(RB_h\)</span>的根的普通高度最多是<span class="math inline">\(2h\)</span>，<span class="math inline">\(ARB_h\)</span>的根的普通高度最多是<span class="math inline">\(2h-1\)</span></li>
<li>由此可知，无论是<span class="math inline">\(RB_h\)</span>还是<span class="math inline">\(ARB_h\)</span>，其中任何黑色节点的普通高度至多是黑色高度的2倍。</li>
</ul>
<h2 id="section-2">6.5</h2>
<ul>
<li>考虑到<span class="math inline">\(a_i-i\)</span>是非严格单调增的</li>
<li>检查<span class="math inline">\(a_1-1\)</span>和<span class="math inline">\(a_n-n\)</span>是不是0，以及是否满足零点存在性定理，<span class="math inline">\(O(1)\)</span>复杂度可判断是否存在</li>
<li>如果存在解，二分查找，<span class="math inline">\(O(log\
n)\)</span>复杂度找到具体下标</li>
</ul>
<h2 id="section-3">6.8</h2>
<h3 id="section-4">(1)</h3>
<p>遍历一次，找到最大值和最小值，复杂度<span class="math inline">\(O(n)\)</span></p>
<h3 id="section-5">(2)</h3>
<p>有序数组，直接取两端即可，复杂度<span class="math inline">\(O(1)\)</span></p>
<h3 id="section-6">(3)</h3>
<p>看到要求复杂度是<span class="math inline">\(O(nlog\
n)\)</span>，自然想到进行排序，然后遍历相邻两个元素的差的绝对值，找到最小的且非0的即可。</p>
<h3 id="section-7">(4)</h3>
<p>相当于第(3)问的一个部分，进行一层遍历，即计算相邻两个元素的差的绝对值，找到最小的且非0的即可。</p>
<h2 id="section-8">6.14</h2>
<h3 id="section-9">(1)</h3>
<p>假设不存在，由<span class="math inline">\(A[1]\geq A[2] \Rightarrow
A[n-1]&gt;A[n]\)</span>，矛盾。</p>
<h3 id="section-10">(2)</h3>
<ul>
<li>二分查找，每次找区间<span class="math inline">\((L,R)\)</span>的中间的两个数进行比较，假设是<span class="math inline">\(A[i],A[i+1]\)</span></li>
<li>如果<span class="math inline">\(A[i]\leq
A[i+1]\)</span>，则以子区间(L,i+1)继续查找</li>
<li>如果<span class="math inline">\(A[i]&gt;
A[i+1]\)</span>，则以子区间(i,R)继续查找</li>
<li>可以证明算法的正确性，用数学归纳法</li>
<li>二分查找，每次排除一半区间，复杂度<span class="math inline">\(O(log\
n)\)</span></li>
</ul>
<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>
]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Problem Set Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>【习题解答】 分治算法设计要素</title>
    <url>/2021/04/11/algorithms7-hw/</url>
    <content><![CDATA[<p><strong><em>注：</em></strong>
<em>本题解为个人完成，难免有疏漏，请勿抄袭，仅供参考，同时欢迎留言指正。</em>
## 7.1
用朴素的两层遍历当然可以，也可以基于归并排序或堆排序进行改进。</p>
<h2 id="section">7.4</h2>
<h3 id="section-1">(1)</h3>
<p>一般不作说明的要求分析复杂度，考虑最坏情况即可： <span class="math inline">\(2n+3n+\cdots+kn=O(nk^2)\)</span></p>
<h3 id="section-2">(2)</h3>
<p>分治的思想，原数组分为左右两个部分，相当于可以先解决两个子问题，然后合并两个排序好的部分即可。</p>
<p>复杂度即<span class="math inline">\(f(n,k)=2\times
f(n,\frac{k}{2})+O(kn)\)</span></p>
<p>即复杂度为<span class="math inline">\(\sum\limits_{i=1}^{log\
k}nk=nklog\ k\)</span></p>
<h2 id="section-3">7.5</h2>
<h3 id="section-4">(1)</h3>
<ul>
<li>计算左右子树的高度<span class="math inline">\(h_l,h_r\)</span></li>
<li>树高就是<span class="math inline">\(\max\{h_l,h_r\}+1\)</span></li>
</ul>
<p>复杂度 <span class="math inline">\(f(n)=2f(n/2)+1=O(n)\)</span></p>
<h2 id="section-5">(2)</h2>
<p>首先按照上一问的思想，我们可以用O(n)的复杂度，给树的每个节点标注高度。然后直径用分治来解决就很容易：</p>
<ul>
<li>首先计算左子树、右子树两个子问题的直径<span class="math inline">\(d_l,d_r\)</span></li>
<li>然后原树直径<span class="math inline">\(d=\max\{d_l,d_r,h_l+h_r+2\}\)</span></li>
</ul>
<p>空间复杂度和时间复杂度都是<span class="math inline">\(O(n)\)</span>，但其实本质上，以每个节点为根的树的高度和直径的计算可以放在一起进行，这样额外空间开销就只需要<span class="math inline">\(O(1)\)</span>。即：</p>
<ul>
<li>首先计算左子树、右子树两个子问题的直径<span class="math inline">\(d_l,d_r\)</span>和树高<span class="math inline">\(h_l,h_r\)</span></li>
<li>然后原树直径<span class="math inline">\(d=\max\{d_l,d_r,h_l+h_r+2\}\)</span>，原树高<span class="math inline">\(\max\{h_l,h_r\}+1\)</span>，同时返回原树的高和直径即可。</li>
</ul>
<p>注：有的同学利用两次dfs来找直径，也是可以的。即从根出发dfs，找到最远的节点，该节点一定是直径的端点；然后以该端点再做一次dfs，找到最远的另一个端点，就可以找到直径。</p>
<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>
]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Problem Set Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>【习题解答】 图的深度优先遍历</title>
    <url>/2021/05/24/algorithms8-hw/</url>
    <content><![CDATA[<p><strong><em>注：</em></strong>
<em>本题解为个人完成，难免有疏漏，请勿抄袭，仅供参考，同时欢迎留言指正。</em>‘
## 8.2 + 所有点染成白色 + 对于每一个调用如图算法</p>
<img src="/2021/05/24/algorithms8-hw/8-2.png" class title="this is figure">
<p>本题要注意顶点出栈的时机，以保证染色的行为和递归实现是一致的。染色行为如下：
+ 顶点白色表示之前未访问过 + 顶点灰色表示访问到了，但是子节点还未访问完
+ 顶点黑色表示以该顶点出发的深度遍历子树都已经访问完了</p>
<h2 id="section">8.5</h2>
<p><span class="math inline">\((\Rightarrow)\)</span> +
v为割点，即连通图G去掉v点后变得不连通，记为G' +
则G'中必然存在两个点w和x，使得w和x没有路径 +
假设G中，存在w到x的路径，该路径上没出现v，则w和x在G'中必连通，矛盾 +
则G中，v必出现在w和x的所有路径上</p>
<p><span class="math inline">\((\Leftarrow)\)</span> +
假设w和x的所有路径上都有点v + 则删去点v后，w和x不连通 +
即删去点v后图变得不连通，故v为割点</p>
<h2 id="section-1">8.7</h2>
<ul>
<li>强连通片是<strong>极大</strong>的强连通子图（不是任何强连通片的真子图）</li>
<li>假设收缩图有环，则环上的任意两个强连通片之间的任意两个顶点相互可达</li>
<li>则环上所有的强连通片构成了一个更大的强连通片，矛盾</li>
<li>故有向图的收缩图是无环的</li>
</ul>
<h2 id="section-2">8.8</h2>
<ul>
<li>先复习并理解好SCC算法</li>
<li>收缩图是无环的</li>
<li>强连通算法的本质是希望找到收缩图的最下游，从最下游出发，按任意规则，遍历到的就是一个强连通片</li>
<li>DFS算法，当完成节点的遍历时把节点压入栈，此时栈顶节点一定在收缩图中最上游的强连通片中（反证法，思考为什么）</li>
<li>对于转置图，栈顶节点一定在转置图的收缩图的最下游的强连通片中！</li>
</ul>
<p>因此本题答案如下： +
第一次DFS不能换成BFS，因为需要找到收缩图的最上游或者最下游。DFS是在顶点所在子树全部遍历完成后再进栈，此时栈顶自然是栈中最上游的；BFS是在顶点的孩子进队列后就可以进栈，此时该顶点的孩子还没有进栈，栈顶可能是栈中其他某个顶点的孩子，故栈顶不是最上游（而且也不一定是最下游，比如先对下游的顶点BFS，再对上游的顶点BFS）。
+
第二次DFS可以换成BFS，因为只确定能遍历到的顶点即可，任何遍历规则都可以。</p>
<h2 id="section-3">8.9</h2>
<p>v是割点的充要条件是v的深度优先遍历树有至少两个子节点a,b +
充分性：已知v的dfs树有至少两个子节点，则删除v后,a和b之间没路径。反设a和b存在不经过v的路径，则dfs建树时a和b将在v的同一个子树中，矛盾。故v是割点。
+
必要性：已知v是割点，显然v的深度优先遍历树不可能没有子节点，否则v不是割点。那么反设v的深度优先遍历树只有一个子节点，删去v之后剩下的图还是连通图，矛盾。故v的深度优先遍历树至少有两个子节点。</p>
<h2 id="section-4">8.10</h2>
<ul>
<li>仍然正确。</li>
<li>原算法是课本的96页的算法27。</li>
<li>证明方法还是按95页的定理8.5的证明</li>
</ul>
<h2 id="section-5">8.11</h2>
<h3 id="引理8.9证明">引理8.9证明</h3>
<ul>
<li><span class="math inline">\(\Rightarrow\)</span>:
已知uv是桥，则删去该边，图中存在两个点a,b不连通。现在要证以v为根的子树中没有BE指向v的祖先（包括u）。反设存在BE指向v的祖先。则断开uv以后，图上任意点都和root有路径。则a和b连通，故矛盾。</li>
<li><span class="math inline">\(\Leftarrow\)</span>:
已知以v为根的子树中没有BE指向v的祖先，则删去uv边之后，uv不再连通。故uv是桥</li>
</ul>
<h3 id="定理8.6证明">定理8.6证明</h3>
<p>根据引理8.9，即证明从TE
uv回退时，如果v.back&gt;u.discoverTime，则以v为根的子树中没有BE指向v的祖先（包括u）。反证法证明：根据back值的更新方法，反设以v为根的子树中存在BE指向v的祖先，则v的祖先的discoverTime会被赋值给以v为子树的某个节点的back值，并且随着遍历结束的回退过程，这一discoverTime会以back变量的方式传递到v.back。由于祖先节点具有更小的discoverTime，所以这样一条BE存在，则v.back一定小于v.discoverTime（即v.back小于等于u.discoverTime），矛盾。</p>
<p>补充说明： +
课本的关于割点的证明（95页），实际上是逆否证法，证明其逆否问题，这里我们用反证法
+
把97页的算法28的第9行，v.back&gt;u.discoverTime替换为v.back&gt;=v.discoverTime，再和算法27的第8行进行比较，发现了什么。</p>
<h2 id="section-6">8.14</h2>
<ul>
<li>最外层for循环，遍历每个白色的顶点</li>
<li>循环体中第一次dfs找BE，若找不到则算法返回无解；若找到则以BE的任意端点作为顶点进行第二次dfs，遍历边时进行定向。</li>
<li>每个顶点最多访问2次，复杂度线性。</li>
</ul>
<p>算法正确性 +
若没有BE，则边数小于点数，入度必然小于点数，不可能定向成功 +
若有BE，则非根节点的入边来自于父亲，根节点的入边来自于BE</p>
<h2 id="section-7">8.15</h2>
<h3 id="section-8">(1)</h3>
<p>因为G中存在桥，则桥去掉后图中产生两个连通分支，桥这个边只能进行一种定向，故无论怎么定向，两个连通分支都不可能相互能到达。</p>
<h3 id="section-9">(2)</h3>
<p>从任意节点开始进行DFS即可，DFS访问边的方向即为边的定向，复杂度线性。</p>
<p>证明没有桥的图，按上述方法可以得到一个SCC定向，即定向图强连通。 +
对于原无向图的DFS树，只有TE和BE。对于定向后的图中任何一个顶点，都有BE直连到根，否则根连向这个顶点所在子树的边，在无向图中是割边。
+ 故定向图任意顶点能到达根节点，故定向图强连通。</p>
<h2 id="section-10">8.19</h2>
<ul>
<li>找入度为0的顶点，即找源点，也就是最上游的顶点。</li>
<li>回忆找强连通片的SCC算法，可以用一遍DFS，在节点遍历完成时入栈，则在压缩图中，栈顶的节点一定不在栈中任何其他节点的下游。</li>
<li>对于有向无环图，压缩图就是本身，为什么。</li>
<li>故该方法，找度为0的点来拓扑排序，本质上和书上的一遍DFS加栈结构进行拓扑排序有着相同的原理。</li>
<li>对于书上dfs的方法，若图中有回路，则DFS时会发现BE。</li>
<li>对于该方法，若图中有回路，算法结束后会出现非空的无法继续删除的子图。</li>
<li>复杂度线性</li>
</ul>
<h2 id="section-11">8.20</h2>
<h3 id="section-12">(1)</h3>
<p>以该点为根进行深度优先搜索即可，搜索结束时若有没搜到的节点，则不能到达其他所有节点，反之可以。</p>
<h3 id="section-13">(2)</h3>
<ul>
<li>dfs和栈结构，找到一个最上游的节点，即该节点在压缩图中的入度为0。</li>
<li>对该点调用第一问的方法。</li>
<li>复杂度线性。</li>
</ul>
<h2 id="section-14">8.22</h2>
<ul>
<li>两次dfs计算压缩图</li>
<li>压缩图中每个点的权重为该点所对应原图的强连通片的顶点数</li>
<li>压缩图中每个点的影响力为该点在压缩图中能到达的顶点的权重之和（包括自己），用dfs框架计算</li>
<li>压缩图中影响力最小的点对应原图的强连通片，该强连通片中都是影响力最小的点</li>
<li>压缩图中影响力最大的点对应原图的强连通片，该强连通片中都是影响力最大的点</li>
</ul>
<h2 id="section-15">8.24</h2>
<ul>
<li>遍历一遍图中的边，找到入度为0的点，加入到第一个学期的课程集合</li>
<li>如果已知当前学期的课程，下学期的课程按如下方式确定
<ul>
<li>对于当前学期的所有点，遍历其邻居，删除对应的边（一定是出边，因为已经没有入边了），并把该邻居的入度减1</li>
<li>若某邻居的入度减为0，则将其加入到下学期的课程集合中</li>
</ul></li>
<li>算法复杂度为线性，因为找第一个学期的课程需要O(V)，后续操作中每个边会且只会被删一次，即O(E)</li>
</ul>
<p>此外也有同学使用了关键路径的方法，也是可以的。</p>
<h2 id="section-16">8.26</h2>
<h3 id="section-17">(1)</h3>
<ul>
<li>如果a恨b，则a要放在b前面；如果a是b的先修课则a要放在b前面。我们发现本小问思路类似于8.24</li>
<li>遍历一遍图中的边，找到入度为0的点，加入到候选队首集合中（集合中的元素都可以作为队首，因为不被人恨）。</li>
<li>接下来进行循环，循环的每次任意从候选队首集合中确定一个队首，并且需要删除该点的所有边（一定是出边），并更新这些出边对应的端点的入度
<ul>
<li>如果某个顶点的入度更新为0，则加入候选队首集合中。</li>
<li>如果候选队首集合为空集，而还有顶点未排入队伍，则输出不存在符合条件的排队方法</li>
<li>如果候选队首集合为空集，且所有顶点都入了队伍，则输出排队结果。</li>
<li>如果候选队首集合不为空集，则继续下了一轮循环</li>
</ul></li>
<li>复杂度O(V+E)，理由同8.24。</li>
</ul>
<h3 id="section-18">(2)</h3>
<ul>
<li>遍历一遍图中的边，找到入度为0的点，加入到候选队首集合中（集合中的元素都可以放在第一行，因为不被人恨）。</li>
<li>接下来进行循环，循环的每次<strong>将候选队首集合中所有顶点放在第一排</strong>，并且需要删除各个点的所有边（一定是出边），并更新这些出边对应的端点的入度
<ul>
<li>如果某个顶点的入度更新为0，则加入候选队首集合中。</li>
<li>如果候选队首集合为空集，而还有顶点未排入队伍，则输出不存在符合条件的排队方法</li>
<li>如果候选队首集合为空集，且所有顶点都入了队伍，则输出排队结果。</li>
<li>如果候选队首集合不为空集，则继续下了一轮循环</li>
</ul></li>
<li>复杂度O(V+E)，理由同8.24。</li>
</ul>
<h2 id="section-19">8.28</h2>
<h3 id="section-20">(1)</h3>
<p><span class="math inline">\(x_1=True\)</span>，<span class="math inline">\(x_2=True\)</span>，<span class="math inline">\(x_3=False\)</span>，<span class="math inline">\(x_4=True\)</span></p>
<h3 id="section-21">(2)</h3>
<p>答案不唯一，例如： <span class="math inline">\((x_1\vee
x_2)\wedge(x_1\vee \overline{x_2})\wedge(\overline{x_1}\vee
x_3)\wedge(\overline{x_1}\vee\overline{x_3})\wedge(x_3\vee
x_4)\)</span></p>
<h3 id="section-22">(3)</h3>
<p>按定义画图即可</p>
<h3 id="section-23">(4)</h3>
<p>图中的边表示着布尔变量间的蕴涵关系，有传递性。假设有一个强连通片同时包含<span class="math inline">\(x\)</span>和<span class="math inline">\(\overline{x}\)</span>，则</p>
<ul>
<li>若<span class="math inline">\(x\)</span>为真，则可以按从<span class="math inline">\(x\)</span>到<span class="math inline">\(\overline{x}\)</span>的路径，推出<span class="math inline">\(\overline{x}\)</span>为真，矛盾</li>
<li>若<span class="math inline">\(\overline{x}\)</span>为真，则可以按从<span class="math inline">\(\overline{x}\)</span>到<span class="math inline">\(x\)</span>的路径，推出<span class="math inline">\(x\)</span>为真，矛盾</li>
</ul>
<p>故无论<span class="math inline">\(x\)</span>怎么设置真假都无法找到满足条件的子句。</p>
<h3 id="section-24">(5)</h3>
<p>要证明实例I是可满足的，就是要找到一种对每个布尔变量的真假状态的设置，即在图中标记n个顶点（对应于n个变量的真假状态），使得图中每个顶点，其能到达的顶点都是被标记了的。具体算法和正确性的证明见下一问。</p>
<h3 id="section-25">(6)</h3>
<p>算法：</p>
<ul>
<li>线性时间确定原图的压缩图，SCC算法，得到的是有向无环图</li>
<li>设置该图的逆拓扑序，具体来说，在压缩图中，如果a到b有边，则b的逆拓扑序较大。复杂度线性。</li>
<li>原图中每个点的序号即其所在强连通片的逆拓扑序</li>
<li>最后遍历一遍每个布尔变量，确定其真假状态
<ul>
<li>如果该布尔变量的真和假对应的点的序号相同，代表其真假状态出现在了同一个强连通片中，此时输出无解。</li>
<li>否则把该布尔变量真和假对应的点的序号中较大的那个点进行标记。</li>
</ul></li>
</ul>
<p>复杂度和正确性：</p>
<ul>
<li>复杂度是线性的显然</li>
<li>对于每个布尔变量，在最后遍历的时候都确定其要么为真要么为假，现在就是要证明该实例就是满足条件的。</li>
<li>即证明对于图中每个标记的顶点，其能到达的顶点都是标记的</li>
<li>不失一般性的，反设存在点<span class="math inline">\(x_1\)</span>和<span class="math inline">\(x_2\)</span>被标记，而<span class="math inline">\(\overline{x_1}\)</span>和<span class="math inline">\(\overline{x_2}\)</span>没有被标记，且<span class="math inline">\(x_1\)</span>可到达<span class="math inline">\(\overline{x_2}\)</span>，由逆否性质，<span class="math inline">\(x_2\)</span>必然到达<span class="math inline">\(\overline{x_1}\)</span>。
<ul>
<li>因为被标记的点的序号较大，故<span class="math inline">\(x_1\)</span>的序号大于<span class="math inline">\(\overline{x_1}\)</span>。</li>
<li>因为<span class="math inline">\(\overline{x_1}\)</span>可由<span class="math inline">\(x_2\)</span>到达，故<span class="math inline">\(\overline{x_1}\)</span>序号大于等于<span class="math inline">\(x_2\)</span></li>
<li>因为被标记的点的序号较大，故<span class="math inline">\(x_2\)</span>的序号大于<span class="math inline">\(\overline{x_2}\)</span>。</li>
<li>因为<span class="math inline">\(\overline{x_2}\)</span>可由<span class="math inline">\(x_1\)</span>到达，故<span class="math inline">\(\overline{x_2}\)</span>序号大于等于<span class="math inline">\(x_1\)</span></li>
<li><span class="math inline">\(x_1\)</span>序号大于<span class="math inline">\(x_1\)</span>序号，故矛盾</li>
</ul></li>
<li>由此证明按该算法，能在线性时间能对每个布尔变量设置真假，并且是没有冲突的合法设置。</li>
</ul>
<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>
]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Problem Set Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>【习题解答】 图的广度优先遍历</title>
    <url>/2021/05/25/algorithms9-hw/</url>
    <content><![CDATA[<h2 id="section">9.1</h2>
<ul>
<li>反设在遍历v点时发现BE，连向黑色的节点w，则之前在bfs中，队列弹出w时，会发现v为w的未访问过的邻居，则之前的BE实际上是TE的二次遍历，矛盾。</li>
<li>反设在遍历v点时发现DE，连向遍历树中v的后继节点w，但v的后继节点在v刚出队列时必然都是白色节点，即未被访问过。此时该DE实际上还是TE，在遍历树中，w是v的孩子，矛盾。</li>
</ul>
<h2 id="section-1">9.2</h2>
<p>不成立，反例：五边形。不唯一。</p>
<h2 id="section-2">9.3</h2>
<p>DFS可以判断是否为二部图。
优劣分析的答案比较开放，有理即可，参考回答如下： +
dfs不需要队列的空间开销；更适合深度大，节点度数小的图。 +
bfs不需要进行递归；更适合深度小，节点度数大的图。</p>
<h2 id="section-3">9.4</h2>
<ul>
<li>DFS
<ul>
<li>有向图，遇到灰色节点（BE）</li>
<li>无向图，遇到灰色节点（BE）</li>
</ul></li>
<li>BFS
<ul>
<li>有向图，发现黑色的祖先（BE），但注意发现邻居是黑色节点不一定代表遇到BE，也可能是CE，还要额外检查是不是祖先。</li>
<li>无向图，遇到灰色节点（CE）</li>
</ul></li>
</ul>
<p>答案中只需要给出：DFS检测有向图的环、BFS检测无向图的环即可。</p>
<h2 id="section-4">9.5</h2>
<p>判断是否能去掉一条边，使得图还连通，本质就是无向图找环。 +
DFS发现灰色邻居，即BE，则返回True；找不到则返回False +
BFS发现灰色邻居，即CE，则返回True；找不到则返回False</p>
<p>复杂度都是O(V)，但怎么证明？ + 无向图的DFS只有TE和BE，BFS只有TE和CE +
算法没停止，说明遍历的点都是白色的邻居，边都是TE。 +
O(V+E)=O(2V)=O(V)</p>
<p>也有同学在课本找桥的算法基础上修改，也是可以的。注意说明复杂度。</p>
<h2 id="section-5">9.8</h2>
<h3 id="section-6">(1)</h3>
<p>深度优先遍历树或宽度优先遍历树就是最小生成树</p>
<h3 id="section-7">(2)</h3>
<ul>
<li>BFS找无向图的圈，9.5问已经说明过，线性代价</li>
<li>删除圈上权重最大的边，此时不改变图的连通性，线性代价</li>
<li>将上述两个步骤重复11次，即删除11条边，剩下的边数m是点数减1，此连通图即最小生成树</li>
<li>复杂度线性</li>
</ul>
<h3 id="section-8">(3)</h3>
<ul>
<li>首先只考虑权重为1的边，用BFS框架进行遍历，得到宽度优先遍历森林。如果森林中只有一颗树，则该树就是原图的最小生成树，开销线性。</li>
<li>否则构造一个新图，对森林的每棵树初始化一个顶点。遍历权重为2的边，如果边的两端点不在森林的同一颗树上，则把这两颗树所对应的新图的两个顶点之间连上权重为1的边，并记录该边对应哪一条权重为2的边（如果对应多条，只需要记录其中一条）。开销线性。</li>
<li>用BFS框架遍历该新图，得到新图的最小生成树。开销线性。</li>
<li>宽度优先遍历森林的所有边（权重为1）在最小生成树上。</li>
<li>新图的最小生成树上的边所对应的（权重为2）边在最小生成树上。</li>
<li>总时间开销是线性的。</li>
</ul>
<h2 id="section-9">9.11</h2>
<ul>
<li>根据相识关系构造无向图，顶点表示候选的被邀请人，边表示两者相识</li>
<li>修改109页的求5度子图的算法5-DEGGREE-SUBGRAPH（简称5DS），原本删除点方式是，该点度小于5则删去，现在删除方式是，该点在原图的度小于5或在补图的度小于5都需要删去。</li>
<li>在第7-10行关于邻点的处理完成后还要再进行非邻点的处理。</li>
<li>算法复杂度是O(V^2)的。</li>
<li>注意，有同学串行的进行对原图和补图求五度子图是不对的，因为对补图删点后，原图可能不一定还满足五度子图的条件。</li>
</ul>
<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>
]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Problem Set Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第一章-函数、极限和连续</title>
    <url>/2021/12/06/calculus1/</url>
    <content><![CDATA[<ul>
<li>本知识总结不提供完整的理论体系汇总，旨在给出<em>概念的理解</em>以及<em>各类问题的思考框架</em>。</li>
<li>笔记为个人整理，禁止商业用途</li>
<li>如有疏漏，欢迎留言</li>
</ul>
<h2 id="函数">函数</h2>
<ul>
<li>sgn函数
<ul>
<li>正数取1</li>
<li>负数取-1</li>
<li>0取0</li>
</ul></li>
<li>有界性
<ul>
<li>可以从最值出发得到有界性
<ul>
<li>有最值一定有界，有界不一定有最值</li>
</ul></li>
<li>可以从极限定义出发得到有界性</li>
<li>可以从连续性出发得到有界性</li>
<li>有限区间上，导函数有界，则原函数有界</li>
</ul></li>
</ul>
<h2 id="极限">极限</h2>
<ul>
<li>数列的极限
<ul>
<li><span class="math inline">\(\forall \epsilon&gt;0,\exists N\in
N^\star, n&gt;N \Rightarrow |A_n-A|&lt;\epsilon\)</span></li>
</ul></li>
<li>函数的极限
<ul>
<li>6个收敛位置
<ul>
<li>点左，点，点右，无穷大，正无穷大，负无穷大</li>
</ul></li>
<li>形式
<ul>
<li><span class="math inline">\(\forall \epsilon&gt;0,\exists
[condition1] , [condition2] \Rightarrow
|f(x)-A|&lt;\epsilon\)</span></li>
<li>点、无穷大对应<span class="math inline">\([condition1]\)</span>，左、右对应<span class="math inline">\([condition2]\)</span></li>
</ul></li>
</ul></li>
<li>无穷大
<ul>
<li>定义：按前面极限的定义</li>
<li>注意无穷大属于极限不存在的情况</li>
</ul></li>
<li>无穷小
<ul>
<li>定义：按前面极限的定义，且<span class="math inline">\(A=0\)</span></li>
<li>比较
<ul>
<li>同阶：比的极限为常数</li>
<li>等价：比的极限为1</li>
<li>高阶：比的极限为0</li>
<li>低阶：比的极限为无穷大</li>
</ul></li>
</ul></li>
<li>极限存在定义：左右极限相等</li>
<li>保号性：函数的极限存在，存在去心邻域使得函数和极限同号</li>
<li>两个极限存在法则
<ul>
<li>夹逼定理</li>
<li>单调有界定理</li>
</ul></li>
<li>两个基本极限
<ul>
<li><span class="math inline">\(\lim\limits_{x\rightarrow
0}\frac{sinx}{x}=1\)</span></li>
<li><span class="math inline">\(\lim\limits_{x\rightarrow
0}(1+x)^{\frac{1}{x}}=e\)</span></li>
</ul></li>
<li>等价无穷小替换的原理
<ul>
<li><span class="math inline">\(A\sim C\Rightarrow
\lim\frac{A}{B}=\lim\frac{AC}{BC}=\lim\frac{A}{C}\lim\frac{C}{B}=\lim\frac{C}{B}\)</span></li>
</ul></li>
<li>洛必达法则
<ul>
<li>适用条件
<ul>
<li>0比0型</li>
<li>分子分母去心领域内可导且分母导数非0</li>
<li>导数比值的极限存在或无穷</li>
</ul></li>
<li>除非有变限积分函数，不推荐使用该法则
<ul>
<li>该法则算不出结果不代表一定没有结果</li>
<li>该法则的每一次求导，都要验证使用条件</li>
</ul></li>
</ul></li>
<li>带佩亚诺余项的泰勒公式
<ul>
<li>求极限时推荐使用</li>
</ul></li>
<li>极限计算的思路
<ul>
<li>尽量化简、提取极限非0的因式</li>
<li>等价无穷小、洛必达、泰勒</li>
<li>导数定义、积分和式定义</li>
<li>夹逼定理、单调有界定理</li>
</ul></li>
<li>递推形式的数列极限
<ul>
<li>先假设存在，求出唯一可能的极限</li>
<li>再证明存在性，一般用夹逼、单调有界等</li>
</ul></li>
<li>复合函数的极限
<ul>
<li>内函数在<span class="math inline">\(a\)</span>处有极限<span class="math inline">\(b\)</span>，在某个<span class="math inline">\(a\)</span>的去心领域内不等于<span class="math inline">\(b\)</span></li>
<li>外函数在<span class="math inline">\(b\)</span>处有极限<span class="math inline">\(c\)</span></li>
<li>则复合函数在<span class="math inline">\(a\)</span>处有极限<span class="math inline">\(c\)</span></li>
</ul></li>
</ul>
<h2 id="连续">连续</h2>
<ul>
<li>左连续
<ul>
<li>左极限等于函数值</li>
</ul></li>
<li>右连续
<ul>
<li>右极限等于函数值</li>
</ul></li>
<li>连续
<ul>
<li>极限等于函数值</li>
</ul></li>
<li>间断
<ul>
<li>第一类
<ul>
<li>可去间断：极限存在，但不等于函数值</li>
<li>跳跃间断：左右极限存在，但不等</li>
</ul></li>
<li>第二类
<ul>
<li>无穷间断：极限不存在，无穷的情况</li>
<li>振荡间断：极限不存在，非无穷的情况</li>
</ul></li>
</ul></li>
<li>复合函数连续性
<ul>
<li>内函数在<span class="math inline">\(a\)</span>连续，函数值<span class="math inline">\(b\)</span></li>
<li>外函数在<span class="math inline">\(b\)</span>连续</li>
<li>则复合函数在<span class="math inline">\(a\)</span>连续</li>
</ul></li>
<li>闭区间上连续函数的性质
<ul>
<li>有界、有最值</li>
<li>介值存在性定理、零点存在性定理</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第二章-一元函数微分学</title>
    <url>/2021/12/06/calculus2/</url>
    <content><![CDATA[<ul>
<li>本知识总结不提供完整的理论体系汇总，旨在给出<em>概念的理解</em>以及<em>各类问题的思考框架</em>。</li>
<li>笔记为个人整理，禁止商业用途</li>
<li>如有疏漏，欢迎留言</li>
</ul>
<h2 id="微分">微分</h2>
<ul>
<li><span class="math inline">\(\Delta y=A\Delta x+o(\Delta x)\)</span>
<ul>
<li><span class="math inline">\(f&#39;(x_0)=A\)</span></li>
<li><span class="math inline">\(dx=\Delta x\)</span></li>
<li><span class="math inline">\(dy=A\Delta x=f&#39;(x_0)dx\)</span></li>
<li><span class="math inline">\(o(\Delta
x)=\frac{1}{2}f&#39;&#39;(\xi)(\Delta x)^2,\xi\in(x_0,x_0+\Delta
x)\)</span></li>
</ul></li>
<li>可微<span class="math inline">\(\Leftrightarrow\)</span>可导<span class="math inline">\(\Rightarrow\)</span>连续</li>
<li>反函数的导数
<ul>
<li><span class="math inline">\(arcsinx&#39;=\frac{1}{\sqrt{1-x^2}}\)</span></li>
<li><span class="math inline">\(arccosx&#39;=\frac{-1}{\sqrt{1-x^2}}\)</span></li>
<li><span class="math inline">\(arctanx&#39;=\frac{1}{1+x^2}\)</span></li>
<li><span class="math inline">\(arccotx&#39;=\frac{-1}{1+x^2}\)</span></li>
</ul></li>
<li>变限积分求导
<ul>
<li><span class="math inline">\((\int_{\phi_1(x)}^{\phi_2(x)}f(t)dt)&#39;=f(\phi_2(x))\phi_2&#39;(x)-f(\phi_1(x))\phi_1&#39;(x)\)</span></li>
</ul></li>
<li>参数式求导
<ul>
<li><span class="math inline">\(\frac{dy}{dx}=\frac{\frac{dy}{dt}}{\frac{dx}{dt}}\)</span></li>
</ul></li>
<li>隐函数求导
<ul>
<li>两边同时微分再除以<span class="math inline">\(dx\)</span></li>
</ul></li>
<li>反函数求导
<ul>
<li>一阶：<span class="math inline">\(\frac{dx}{dy}=\frac{1}{\frac{dy}{dx}}\)</span></li>
<li>二阶：按导数定义，用微分计算法则求解即可</li>
</ul></li>
</ul>
<h2 id="导数的应用">导数的应用</h2>
<ul>
<li>单调性
<ul>
<li>严格单调：没有常数区间的单调</li>
<li>单调：在常数区间外，单调</li>
</ul></li>
<li>极值
<ul>
<li>必要条件：若可导，则导数为0</li>
<li>充分条件一：极值点处连续、去心邻域内可导、左右侧导数异号</li>
<li>充分条件二：极值点处二阶可导，且一阶导为0，二阶导不为0</li>
</ul></li>
<li>可疑极值（所有可能是极值的点）
<ul>
<li>驻点</li>
<li>不可导点</li>
</ul></li>
<li>凹凸性
<ul>
<li>定义：弦在弧上方是凹，弦在弧下方是凸
<ul>
<li>数分的定义刚好反过来</li>
</ul></li>
<li>判断：要求一阶导没有常数区间，此时二阶导非正为凸、非负为凹</li>
</ul></li>
<li>拐点
<ul>
<li>定义：凹凸的分界点</li>
<li>必要条件：若可二阶导，则二阶导为0</li>
<li>充分条件一：拐点处连续、去心邻域内可二阶导、左右侧二阶导异号</li>
<li>充分条件二：拐点处三阶可导，且二阶导为0，三阶导不为0</li>
</ul></li>
<li>驻点
<ul>
<li>导数为0的点</li>
</ul></li>
<li>最值
<ul>
<li>闭区间问题
<ul>
<li>求内部的可疑极值点的函数值</li>
<li>求两端点的函数值</li>
<li>取其中最大者为最大值，最小者为最小值</li>
</ul></li>
<li>应用问题
<ul>
<li>建模求解即可</li>
</ul></li>
</ul></li>
<li>渐近线
<ul>
<li>水平渐近线
<ul>
<li>正无穷或负无穷处的渐近线<span class="math inline">\(y=c_1,y=c_2\)</span>，若重合只能算一条</li>
</ul></li>
<li>铅直渐近线
<ul>
<li>某个极限为无穷的点<span class="math inline">\(x_0\)</span>的渐近线<span class="math inline">\(x=x_0\)</span></li>
</ul></li>
<li>斜渐近线
<ul>
<li><span class="math inline">\(\lim\limits_{x\rightarrow
+\infty}\frac{f(x)}{x}=a,\lim\limits_{x\rightarrow
+\infty}(f(x)-ax)=b\)</span>，则有斜渐近线<span class="math inline">\(y=ax+b\)</span></li>
</ul></li>
</ul></li>
<li>曲率
<ul>
<li><span class="math inline">\(k=\frac{|d\theta|}{ds}\stackrel{y&#39;=tan\theta}=\frac{|d(y&#39;)|cos^2\theta}{\sqrt{1+(y&#39;)^2}dx}=\frac{|y&#39;&#39;|}{(1+(y&#39;)^2)^{\frac{3}{2}}}\)</span></li>
</ul></li>
<li>曲率半径
<ul>
<li>曲率的倒数</li>
</ul></li>
<li>曲率圆中心
<ul>
<li>按<strong>递增</strong>的<strong>凹函数</strong>的情况推导，用曲率半径表达出通用公式
<ul>
<li>曲率圆中心相对于函数点的位置，横坐标<strong>减</strong>，纵坐标<strong>加</strong>，且二阶导为<strong>正</strong></li>
</ul></li>
</ul></li>
</ul>
<h2 id="中值定理体系">中值定理体系</h2>
<ul>
<li>费马定理
<ul>
<li>内容：极值点处，若可导，则导数为0</li>
<li>证明：以极大值为例，左导数大于等于0，右导数小于等于0，故导数等于0</li>
</ul></li>
<li>罗尔定理
<ul>
<li>内容：闭区间连续，开区间可导，两端相等，则开区间内有驻点</li>
<li>证明
<ul>
<li>若开区间内为常数，则有驻点</li>
<li>否则根据闭区间连续，得出开区间内有最值点，显然是极值点；又开区间内可导，根据费马定理，极值点为驻点</li>
</ul></li>
</ul></li>
<li>拉格朗日中值定理
<ul>
<li>内容：闭区间连续，开区间可导，开区间内存在一个点的斜率，等于两端连线的斜率
<ul>
<li><span class="math inline">\(\exists \xi\in
(a,b),f&#39;(\xi)=\frac{f(b)-f(a)}{b-a}\)</span></li>
</ul></li>
<li>证明
<ul>
<li>构造函数<span class="math inline">\(g(x)=f(x)-\frac{f(b)-f(a)}{b-a}x\)</span>，构造思路是对<span class="math inline">\(f&#39;(x)=\frac{f(b)-f(a)}{b-a}\)</span>积分</li>
<li>验证构造函数在两端相等，结合罗尔定理即可</li>
</ul></li>
</ul></li>
<li>柯西中值定理
<ul>
<li>内容：两个函数都闭区间连续，开区间可导，<span class="math inline">\(\forall x\in (a,b),g&#39;(x)\neq
0\)</span>，则<span class="math inline">\(\exists \xi\in
(a,b),\frac{f&#39;(\xi)}{g&#39;(\xi)}=\frac{f(b)-f(a)}{g(b)-g(a)}\)</span></li>
<li>证明
<ul>
<li>构造函数<span class="math inline">\(h(x)=f(x)-\frac{f(b)-f(a)}{g(b)-g(a)}g(x)\)</span>，构造思路是对<span class="math inline">\(f&#39;(\xi)-\frac{f(b)-f(a)}{g(b)-g(a)}g&#39;(\xi)\)</span>积分</li>
<li>验证构造函数在两端相等，结合罗尔定理即可</li>
</ul></li>
</ul></li>
<li>洛必达法则
<ul>
<li>内容：当分子分母极限为0、去心邻域内分子分母导数存在且分母导数不为0、导数比值的极限存在或无穷，则<span class="math inline">\(\lim\limits_{x\rightarrow
a}\frac{f(x)}{F(x)}=\lim\limits_{x\rightarrow
a}\frac{f&#39;(x)}{F&#39;(x)}\)</span></li>
<li>证明
<ul>
<li>令<span class="math inline">\(f(a)=g(a)=0\)</span>，使得<span class="math inline">\([a,x]\)</span>连续，又<span class="math inline">\((a,x)\)</span>可导，则<span class="math inline">\(\exists \xi\in
(a,x),\frac{f&#39;(\xi)}{g&#39;(\xi)}=\frac{f(x)-0}{g(x)-0}\)</span></li>
<li>两边取极限<span class="math inline">\(\lim\limits_{x\rightarrow
a}\frac{f(x)}{g(x)}=\lim\limits_{x\rightarrow
a}\frac{f&#39;(\xi)}{g&#39;(\xi)}=\lim\limits_{\xi\rightarrow
a}\frac{f&#39;(\xi)}{g&#39;(\xi)}=\lim\limits_{x\rightarrow
a}\frac{f&#39;(x)}{g&#39;(x)}\)</span></li>
</ul></li>
</ul></li>
<li>泰勒中值
<ul>
<li>佩亚诺余项：若在<span class="math inline">\(x_0\)</span>处n阶可导，则可在邻域内展开为
<ul>
<li><span class="math inline">\(f(x)=f(x_0)+f&#39;(x_0)(x-x_0)+\cdots+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+R_n(x)\)</span></li>
<li><span class="math inline">\(R_n(x)=o((x-x_0)^n)\)</span></li>
</ul></li>
<li>拉格朗日余项：若在<span class="math inline">\(x_0\)</span>某邻域n+1阶可导，则在可在邻域内展开为
<ul>
<li><span class="math inline">\(f(x)=f(x_0)+f&#39;(x_0)(x-x_0)+\cdots+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+R_n(x)\)</span></li>
<li><span class="math inline">\(R_n(x)=\frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1}\)</span></li>
</ul></li>
<li>注：前者一般用于极限计算，后者一般用于不等式证明</li>
</ul></li>
<li>积分中值定理
<ul>
<li>内容：闭区间连续，则
<ul>
<li><span class="math inline">\(\exists \xi\in
(a,b),f(\xi)=\frac{\int_a^bf(x)dx}{b-a}\)</span></li>
</ul></li>
<li>证明1
<ul>
<li>闭区间连续，则原函数存在，可以使用牛顿莱布尼兹定理（参考第三章）</li>
<li>即证明<span class="math inline">\(f(\xi)=\frac{F(a)-F(b)}{b-a}=F&#39;(\xi)\)</span></li>
<li><span class="math inline">\(F\)</span>闭区间连续，开区间可导，用拉格朗日中值定理即可</li>
</ul></li>
<li>证明2
<ul>
<li>设<span class="math inline">\(m=\min\limits_{a&lt;x&lt;b}
f(x),M=\max\limits_{a&lt;x&lt;b}f(x)\)</span></li>
<li>放缩分子的积分式，得到<span class="math inline">\(m&lt;\frac{\int_a^bf(x)dx}{b-a}&lt;M\)</span></li>
<li>因为<span class="math inline">\(f(x)\)</span>闭区间连续，再用介值定理即可</li>
</ul></li>
</ul></li>
<li>广义积分中值定理
<ul>
<li>内容：<span class="math inline">\(f(x)\)</span>闭区间连续，<span class="math inline">\(g(x)\)</span>闭区间可积且不变号
<ul>
<li><span class="math inline">\(\exists \xi\in
(a,b),f(\xi)=\frac{\int_a^bf(x)g(x)dx}{\int_a^bg(x)dx}\)</span></li>
</ul></li>
<li>证明1（不严谨的证明，提供一种理解）
<ul>
<li><span class="math inline">\(f(x)g(x)\)</span>和<span class="math inline">\(g(x)\)</span>闭区间不一定连续，这里<strong>不严谨的假设</strong>原函数存在，使用牛顿莱布尼兹定理</li>
<li><span class="math inline">\(f(\xi)=\frac{FG(a)-FG(b)}{G(b)-G(a)}=\frac{f(\xi)g(\xi)}{g(\xi)}=\frac{FG&#39;(\xi)}{G&#39;(\xi)}\)</span></li>
<li>根据前面不严谨的假设，<span class="math inline">\(FG\)</span>和<span class="math inline">\(G\)</span>闭区间连续，开区间可导，用柯西中值定理即可</li>
</ul></li>
<li>证明2（严谨的证明）
<ul>
<li>设<span class="math inline">\(m=\min\limits_{a&lt;x&lt;b}
f(x),M=\max\limits_{a&lt;x&lt;b}f(x)\)</span></li>
<li>放缩分子的积分式，得到<span class="math inline">\(m&lt;\frac{\int_a^bf(x)g(x)dx}{\int_a^bg(x)dx}&lt;M\)</span></li>
<li>因为<span class="math inline">\(f(x)\)</span>闭区间连续，再用介值定理即可</li>
</ul></li>
</ul></li>
</ul>
<h2 id="不等式证明">不等式证明</h2>
<ul>
<li>单调性法</li>
<li>最值法</li>
<li>拉格朗日中值定理法</li>
<li>拉格朗日余项泰勒公式法</li>
<li>双拉格朗日中值定理法</li>
</ul>
<h2 id="零点存在问题">零点存在问题</h2>
<ul>
<li>连续函数的介值定理或零点定理</li>
<li>罗尔定理
<ul>
<li>仔细体会拉格朗日中值定理和柯西中值定理的构造过程，其他的零点存在问题也是此思路</li>
<li>构造时涉及积分，可以考虑补上<span class="math inline">\(e^x\)</span>等函数（求导后可以提取出公因式）</li>
</ul></li>
</ul>
<h2 id="高阶导数的零点界限">高阶导数的零点界限</h2>
<ul>
<li>结论1：函数至少<span class="math inline">\(k\)</span>个零点，则其导函数至少<span class="math inline">\(k-1\)</span>个零点
<ul>
<li>罗尔定理</li>
</ul></li>
<li>结论2：导函数至多<span class="math inline">\(k\)</span>个零点，则原函数至多<span class="math inline">\(k+1\)</span>个零点
<ul>
<li>结论1 + 反证法</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第三章-一元函数积分学</title>
    <url>/2021/12/07/calculus3/</url>
    <content><![CDATA[<ul>
<li>本知识总结不提供完整的理论体系汇总，旨在给出<em>概念的理解</em>以及<em>各类问题的思考框架</em>。</li>
<li>笔记为个人整理，禁止商业用途</li>
<li>如有疏漏，欢迎留言</li>
</ul>
<h2 id="原函数和不定积分">原函数和不定积分</h2>
<ul>
<li>原函数
<ul>
<li>若存在<span class="math inline">\(F(x)\)</span>，使得<span class="math inline">\(F&#39;(x)=f(x)\)</span>，则<span class="math inline">\(F(x)\)</span>是<span class="math inline">\(f(x)\)</span>的原函数</li>
<li><span class="math inline">\(F(x)+C\)</span>是<span class="math inline">\(f(x)\)</span>的原函数一般形式</li>
</ul></li>
<li>不定积分
<ul>
<li>原函数的一般形式即不定积分</li>
<li>记为<span class="math inline">\(\int f(x)dx=F(x)+C\)</span></li>
</ul></li>
<li>原函数存在性（不定积分存在性）
<ul>
<li>函数闭区间连续，则存在闭区间的原函数</li>
<li>函数闭区间，若间断点只有振荡间断点，则存在闭区间的原函数</li>
</ul></li>
</ul>
<h2 id="定积分">定积分</h2>
<ul>
<li>定积分
<ul>
<li>分割、乘积、求和、取极限，若极限存在，则该极限为定积分</li>
</ul></li>
<li>定积分存在性
<ul>
<li>函数闭区间连续，则存在该区间上的定积分</li>
<li>函数闭区间有界，间断点有限，则存在该区间上的定积分</li>
</ul></li>
<li>不定积分和定积分的关系
<ul>
<li>存在性互不相关</li>
<li>若函数闭区间连续，则不定积分和定积分都存在
<ul>
<li>定积分表示原函数（变上限积分）：<span class="math inline">\(F(x)=\int f(x)dx=\int_{a}^xf(t)dt+C\)</span></li>
<li>原函数表示定积分（牛顿-莱布尼兹定理）：<span class="math inline">\(\int_a^{b}f(x)dx=F(b)-F(a)\)</span></li>
</ul></li>
<li>若函数闭区间有一个跳跃间断点，其余位置连续，设<span class="math inline">\(F(x)=\int_{a}^xf(t)dt+C\)</span>
<ul>
<li>分析1：根据存在性判定，闭区间不存在原函数，但存在定积分，说明存在某些位置<span class="math inline">\(F(x)\)</span>不可导，或<span class="math inline">\(F&#39;(x)\neq f(x)\)</span></li>
<li>结论1：<span class="math inline">\(F(x)\)</span>闭区间连续</li>
<li>结论2：非间断位置，<span class="math inline">\(F&#39;(x)=f(x)\)</span></li>
<li>结论3：间断位置，<span class="math inline">\(F&#39;_-(x)=f(x^-),F&#39;_+(x)=f(x^+)\)</span></li>
<li>分析2：间断点<span class="math inline">\(x_0\)</span>是跳跃间断点，则<span class="math inline">\(F&#39;_-(x_0)\neq F&#39;_+(x_0)\Rightarrow
F(x_0)\)</span>不可导</li>
<li>分析3：间断点<span class="math inline">\(x_0\)</span>如果改成可去间断点，则<span class="math inline">\(F&#39;(x_0)=\lim\limits_{x\rightarrow x_0}
f(x)\neq
f(x_0)\)</span>（不一定严谨，因为不清楚前面结论是否还成立）</li>
</ul></li>
</ul></li>
<li>定积分的性质
<ul>
<li><span class="math inline">\(\forall x\in [a,b],f(x)\leq
g(x)\Rightarrow \int_a^bf(x)dx\leq \int_a^b g(x)dx\)</span></li>
<li>在上面性质基础上，若闭区间连续且<span class="math inline">\(\exists
x_0,f(x_0)&lt;g(x_0)\Rightarrow \int_a^bf(x)dx&lt; \int_a^b
g(x)dx\)</span></li>
<li>积分中值定理
<ul>
<li>见第二章的中值定理体系</li>
</ul></li>
</ul></li>
</ul>
<h2 id="积分方法">积分方法</h2>
<ul>
<li>建议记忆的积分公式
<ul>
<li><span class="math inline">\(\int
secxdx=ln|secx+tanx|+C\)</span></li>
<li><span class="math inline">\(\int cscdx=ln|cscx-cotx|+C\)</span></li>
<li><span class="math inline">\(\int\frac{1}{a^2-x^2}dx=\frac{1}{2a}ln|\frac{a+x}{a-x}|+C\)</span>
<ul>
<li>对比记忆法：<span class="math inline">\(arctan&#39;x=\frac{1}{1+x^2}\)</span></li>
</ul></li>
<li><span class="math inline">\(\int\frac{dx}{\sqrt{x^2\pm
a^2}}=ln|x+\sqrt{x^2\pm a^2}|+C\)</span>
<ul>
<li>对比记忆法：<span class="math inline">\(arcsin&#39;x=\frac{1}{\sqrt{1-x^2}}\)</span></li>
</ul></li>
</ul></li>
<li>第一类换元积分法
<ul>
<li><span class="math inline">\(u=\phi(x)\)</span></li>
</ul></li>
<li>第二类换元积分法
<ul>
<li><span class="math inline">\(x=\phi(t)\)</span></li>
<li>比如带根式的积分，可以换元为三角函数积分，或直接换元为<span class="math inline">\(t\)</span>形成有理函数积分</li>
</ul></li>
<li>定积分与不定积分的换元积分的注意事项
<ul>
<li>定积分的换元法的上下限要调整对应的值</li>
<li>不定积分的换元法的结果表示要换元回原字母</li>
</ul></li>
<li>分部积分法
<ul>
<li><span class="math inline">\(\int f(x)d(g(x))=f(x)g(x)-\int
g(x)d(f(x))\)</span></li>
</ul></li>
<li>有理函数积分（分子和分母都是多项式形式）
<ul>
<li>思想：把分母因式分解，然后拆项</li>
<li>步骤
<ul>
<li>解分母等于<span class="math inline">\(0\)</span>的方程，从而把分母因式分解为若干项，但只有两种形式，一种实根对应项<span class="math inline">\((ax+b)^i\)</span>，另一种是复根对应项<span class="math inline">\((ax^2+bx+c)^i\)</span></li>
<li><span class="math inline">\((ax+b)^i\)</span>拆项后待定系数为<span class="math inline">\(\sum\limits_{k=1}^{i}\frac{C_k}{(ax+b)^k}\)</span></li>
<li><span class="math inline">\((ax^2+bx+c)^i\)</span>拆项后待定系数为<span class="math inline">\(\sum\limits_{k=1}^{i}\frac{A_kx+B_k}{(ax^2+bx+c)^k}\)</span></li>
</ul></li>
<li>举例
<ul>
<li><span class="math inline">\(\frac{2x^2-3}{x^2(x+2)^2(x^2+x+1)(x^2-2x+2)^2}\)</span></li>
<li><span class="math inline">\(=\frac{A_1}{x}+\frac{A_2}{x^2}+\frac{B_1}{x+2}+\frac{B_2}{(x+2)^2}\)</span></li>
<li><span class="math inline">\(+\frac{Cx+D}{x^2+x+1}+\frac{E_1x+F_1}{x^2-2x+2}+\frac{E_2x+F_2}{(x^2-2x+2)^2}\)</span></li>
</ul></li>
</ul></li>
<li>用于定积分计算的结论
<ul>
<li>偶函数对称区间的定积分为2倍单侧区间的定积分</li>
<li>奇函数对称区间的定积分为0</li>
<li>周期函数每个周期的定积分相等</li>
<li>华里士公式<span class="math inline">\(\int_0^\frac{\pi}{2}sin^nxdx=\int_0^\frac{\pi}{2}cos^nxdx\)</span>
<ul>
<li><span class="math inline">\(=\frac{n-1}{n}\times\frac{n-3}{n-2}\times\cdots\times
\frac{1}{2}\times\frac{\pi}{2},n=2,4,6,\cdots\)</span></li>
<li><span class="math inline">\(=\frac{n-1}{n}\times\frac{n-3}{n-2}\times\cdots\times
\frac{2}{3}\times 1,n=3,5,7,\cdots\)</span></li>
</ul></li>
<li>万能代换
<ul>
<li>令<span class="math inline">\(tan\frac{x}{2}=t\)</span></li>
<li>一般不建议使用</li>
</ul></li>
</ul></li>
<li>带绝对值的积分
<ul>
<li>建议分段去掉绝对值符号，哪怕要分无穷段（比如三角函数带绝对值）</li>
</ul></li>
</ul>
<h2 id="反常积分的计算和判敛">反常积分的计算和判敛</h2>
<ul>
<li>无穷区间的反常积分
<ul>
<li>上限和下限都为无穷时，需要拆成两项</li>
<li>根据极限定义判定各项是否收敛（无穷处的极限）</li>
<li>只有各项全部收敛，原极限收敛</li>
</ul></li>
<li>无界函数的反常积分（瑕积分）
<ul>
<li>有多个瑕点（即无界的间断点，例如无穷间断点），需要拆成多项，使得每个积分项的上下限中只有一个瑕点</li>
<li>根据极限定义判定各项是否收敛（瑕点某单侧的极限）</li>
<li>只有各项全部收敛，原极限收敛</li>
</ul></li>
<li>建议记忆的反常积分
<ul>
<li><span class="math inline">\(\int_0^{+\infty}e^{-x^2}dx=\frac{\sqrt{\pi}}{2}\)</span>
<ul>
<li>用二重积分开根号计算出</li>
</ul></li>
<li><span class="math inline">\(a&gt;1,\int_{a}^\infty \frac{dx}{xln^p
x}\)</span>，则<span class="math inline">\(p&gt;1\)</span>，收敛
<ul>
<li>分类讨论再用第一类换元积分法即可</li>
</ul></li>
<li><span class="math inline">\(\Gamma(n+1)=\int_0^{+\infty}x^ne^{-x}dx=n!\)</span>
<ul>
<li><span class="math inline">\(\Gamma(x)\)</span>本质上是阶乘的插值函数，这里只用到其自然数定义域的部分</li>
</ul></li>
</ul></li>
<li>收敛判定方法
<ul>
<li>通过计算出结果判敛</li>
<li>通过单调有界收敛定理</li>
<li>通过判敛定理（都是收敛或发散的充分条件，建议记忆）
<ul>
<li>要求：定义区间内连续，<span class="math inline">\(f(x)\geq
0\)</span></li>
<li>区间右端点为瑕点：<span class="math inline">\(\lim\limits_{x\rightarrow
b-}(b-x)^pf(x)=A\)</span></li>
<li>区间左端点为瑕点：<span class="math inline">\(\lim\limits_{x\rightarrow
a+}(x-a)^pf(x)=A\)</span></li>
<li>右侧为无穷区间：<span class="math inline">\(\lim\limits_{x\rightarrow
+\infty}(x)^pf(x)=A\)</span></li>
<li>左侧为无穷区间：<span class="math inline">\(\lim\limits_{x\rightarrow
-\infty}(x)^pf(x)=A\)</span></li>
<li>收敛情况记忆：<span class="math inline">\(0\leq
A&lt;+\infty\)</span>，瑕积分对应<span class="math inline">\(p&lt;1\)</span>，无穷区间积分对应<span class="math inline">\(p&gt;1\)</span></li>
<li>发散情况记忆：<span class="math inline">\(0&lt; A\leq
+\infty\)</span>，瑕积分对应<span class="math inline">\(p\geq
1\)</span>，无穷区间积分对应<span class="math inline">\(p\leq
1\)</span></li>
</ul></li>
</ul></li>
</ul>
<h2 id="定积分的应用">定积分的应用</h2>
<ul>
<li>平面图面积、平面曲线弧长、旋转体体积、旋转面面积，一律按微元法列方程，然后积分即可</li>
</ul>
<h2 id="定积分的有关证明">定积分的有关证明</h2>
<ul>
<li>有绝对值时，一般要划分区间，去掉绝对值
<ul>
<li>各种证明适用</li>
</ul></li>
<li>积分中值定理（包括广义积分中值定理）
<ul>
<li>各种证明都适用，但求极限时注意<span class="math inline">\(\xi\)</span>是否是固定的数</li>
</ul></li>
<li>积分的不等式相关问题
<ul>
<li>积分保号性</li>
<li>放缩和夹逼准则</li>
<li>引入变量转化为变限积分</li>
<li>利用柯西不等式积分形式的证明原理
<ul>
<li>形式：方和积<span class="math inline">\(\geq\)</span>积和方</li>
<li>证明：引入变量转化为变限函数，再利用完全平方公式和保号性</li>
</ul></li>
</ul></li>
<li>变限积分函数有关问题
<ul>
<li>换元、求导，从而转化为普通函数</li>
</ul></li>
<li>零点问题
<ul>
<li>结合第二章的中值体系求解</li>
<li>零点存在性定理</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第五章-多元函数微分学</title>
    <url>/2021/12/09/calculus5/</url>
    <content><![CDATA[<ul>
<li>本知识总结不提供完整的理论体系汇总，旨在给出<em>概念的理解</em>以及<em>各类问题的思考框架</em>。</li>
<li>笔记为个人整理，禁止商业用途</li>
<li>如有疏漏，欢迎留言</li>
</ul>
<h2 id="基本概念">基本概念</h2>
<ul>
<li>重极限
<ul>
<li>含义：以在平面上任何路径趋近某个点时，都有相同极限</li>
<li>证明极限不存在：找到某个路径，其极限不存在，或某两个路径极限不相等</li>
<li>证明极限存在：证明所有路径都有极限，且极限都相等</li>
<li>求解：运算化简、转化为一元函数、用等价无穷小代换、夹逼准则等</li>
</ul></li>
<li>连续性
<ul>
<li>极限值等于函数值</li>
</ul></li>
<li>偏导数求解
<ul>
<li>一般分段函数需要按定义求解</li>
<li>用导数公式法求解出的实际上是偏导数的极限</li>
</ul></li>
<li>微分
<ul>
<li>充要条件
<ul>
<li><span class="math inline">\(\Delta z=dz+o(\sqrt{(\Delta x)^2+(\Delta
y)^2})=\frac{\partial z}{\partial x}dx+\frac{\partial z}{\partial
y}dy+o(\sqrt{(\Delta x)^2+(\Delta y)^2})\)</span></li>
<li>体现了微分<span class="math inline">\(dz\)</span>形式的不变性</li>
</ul></li>
<li>必要条件
<ul>
<li>某点处两个偏导数存在（只考虑了部分的方向）</li>
<li>某点处连续</li>
</ul></li>
<li>充分条件
<ul>
<li>某点处两个偏导数连续</li>
</ul></li>
</ul></li>
</ul>
<h2 id="多元微分法则">多元微分法则</h2>
<ul>
<li>复合函数偏导数
<ul>
<li>绘制树形图
<ul>
<li>对变量求偏导，结果是多个项的和</li>
<li>每个项都是多个导数的乘积，对应一条从根到叶的路径</li>
<li>路径上的结点有多个孩子，则求偏导，有一个孩子则求导</li>
</ul></li>
</ul></li>
<li>高阶偏导数
<ul>
<li>把偏导数看出多元函数，继续求解即可</li>
</ul></li>
<li>混合偏导数次序无关条件
<ul>
<li>当两个混合偏导数在某点连续，则在该点两个混合偏导数相等</li>
</ul></li>
<li>隐函数方程组的求导
<ul>
<li>首先绘制树形图，明确变量的对应关系，便于开展求导过程</li>
<li>方程式左右两边同时求偏导，解出即可</li>
</ul></li>
<li>求带参数的全微分的原函数
<ul>
<li>偏积分：分别用两个偏导数直接计算出原函数，再令其相等</li>
<li>利用<span class="math inline">\(\frac{\partial P}{\partial
y}=\frac{\partial Q}{\partial x}\)</span>
<ul>
<li>首先使用微分充要条件，即<span class="math inline">\(P,Q\)</span>是偏导数</li>
<li>然后使用混合偏导数次序无关条件，需要检查<span class="math inline">\(P,Q\)</span>的连续性</li>
</ul></li>
</ul></li>
</ul>
<h2 id="极值和最值">极值和最值</h2>
<ul>
<li>驻点
<ul>
<li>两个偏导数为0的点</li>
</ul></li>
<li>无条件极值
<ul>
<li>本质：局部最值
<ul>
<li>局部指的是某个邻域</li>
</ul></li>
<li>必要条件：若可偏导则为0（驻点）</li>
<li>可疑极值点的求解
<ul>
<li>可能是极值的点，包括驻点和不可偏导点</li>
</ul></li>
<li>二元函数极值点的求解：设二阶偏导数为<span class="math inline">\(A,B,C\)</span>
<ul>
<li><span class="math inline">\(B^2-AC&lt;0\)</span>有极值，<span class="math inline">\(A&gt;0\)</span>为极小值，<span class="math inline">\(A&lt;0\)</span>有极大值</li>
<li><span class="math inline">\(B^2-AC&gt;0\)</span>没有极值</li>
<li><span class="math inline">\(B^2=AC\)</span>不确定极值情况</li>
</ul></li>
<li>极值点的求解
<ul>
<li>只能用定义法<span class="math inline">\(\epsilon-\delta\)</span>语言</li>
</ul></li>
</ul></li>
<li>条件极值
<ul>
<li>本质：给定曲线上的局部最值</li>
<li>可疑极值点的求解
<ul>
<li>拉格朗日乘子法，转化为无条件可疑极值的求解</li>
</ul></li>
<li>二元函数极值点的求解：用条件消元，转化为无条件二元函数的极值
<ul>
<li>条件消元不一定能成功</li>
</ul></li>
<li>极值点的求解
<ul>
<li>只能用定义法<span class="math inline">\(\epsilon-\delta\)</span>语言</li>
</ul></li>
</ul></li>
<li>闭区域最值
<ul>
<li>求内部的最值
<ul>
<li>求可疑极值（驻点、不可偏导点）</li>
</ul></li>
<li>求边界曲线的最值
<ul>
<li>求可疑极值（驻点）。因为是条件极值，所以用拉格朗日乘子法</li>
<li>多个边界，要考虑边界的端点</li>
</ul></li>
</ul></li>
<li>问题形式
<ul>
<li>因为极值只能用定义法求，所以问题一般是求二元函数的极值、多元函数的最值</li>
</ul></li>
</ul>
<h2 id="方向导数和梯度">方向导数和梯度</h2>
<ul>
<li>方向导数
<ul>
<li>本质：沿着某个方向的导数，比如偏导数是沿着坐标轴方向的导数</li>
<li>求解：若可微，则方向导数存在，可以借助两个偏导数进求方向导数
<ul>
<li>两个偏导数在方向上的投影的代数和</li>
<li>两个偏导数对应向量的合成（即梯度），再投影到目标方向上</li>
</ul></li>
</ul></li>
<li>梯度
<ul>
<li>本质：方向导数的最大值对应的方向向量</li>
<li>求解：各偏导数对应向量的合成
<ul>
<li>比如<span class="math inline">\(\pmb{grad}\
u(x,y)=(u&#39;_x,0)+(0,u&#39;_y)=(u&#39;_x,u&#39;_y)\)</span></li>
</ul></li>
</ul></li>
<li>曲面切平面和法线
<ul>
<li>先求曲面<span class="math inline">\(F(x,y,z)=0\)</span>的法向量，即函数<span class="math inline">\(F(x,y,z)\)</span>的梯度方向（也可以是梯度反向）</li>
<li>再根据法向量，求出切平面和法线方程</li>
</ul></li>
<li>曲线切线和法平面
<ul>
<li>先曲线的方向向量</li>
<li>再根据方向向量，求出法平面和切线方程</li>
</ul></li>
<li>二元函数泰勒定理
<ul>
<li>佩亚诺余项：若在<span class="math inline">\((x_0,y_0)\)</span>某邻域有二阶连续偏导，则在可在邻域内展开为
<ul>
<li><span class="math inline">\(f(x)=f(x_0,y_0)+f&#39;_x(x_0,y_0)(x-x_0)+f&#39;_y(x_0,y_0)(y-y_0)\)</span></li>
<li><span class="math inline">\(+\frac{f&#39;&#39;_{xx}(x_0,y_0)(x-x_0)^2+2f&#39;&#39;_{xy}(x_0,y_0)(x-x_0)(y-y_0)+f&#39;&#39;_{yy}(x_0,y_0)(y-y_0)^2}{2!}+R_n(x)\)</span></li>
<li><span class="math inline">\(R_n(x)=o(\rho^2)\)</span></li>
</ul></li>
<li>拉格朗日余项：若在<span class="math inline">\((x_0,y_0)\)</span>某邻域有二阶连续偏导，则在可在邻域内展开为
<ul>
<li><span class="math inline">\(f(x)=f(x_0,y_0)+f&#39;_x(x_0,y_0)(x-x_0)+f&#39;_y(x_0,y_0)(y-y_0)+R_n(x)\)</span></li>
<li><span class="math inline">\(R_n(x)=\frac{f&#39;&#39;_{xx}(x_\xi,y_\xi)(x-x_0)^2+2f&#39;&#39;_{xy}(x_\xi,y_\xi)(x-x_0)(y-y_0)+f&#39;&#39;_{yy}(x_\xi,y_\xi)(y-y_0)^2}{2!}\)</span></li>
<li><span class="math inline">\((x_\xi,y_\xi)\)</span>在<span class="math inline">\((x_0,y_0)\)</span>和<span class="math inline">\((x,y)\)</span>的线段不包括两端点的内部</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第四章-向量代数和空间解析几何</title>
    <url>/2021/12/09/calculus4/</url>
    <content><![CDATA[<ul>
<li>本知识总结不提供完整的理论体系汇总，旨在给出<em>概念的理解</em>以及<em>各类问题的思考框架</em>。</li>
<li>笔记为个人整理，禁止商业用途</li>
<li>如有疏漏，欢迎留言</li>
</ul>
<h2 id="叉乘和混合积">叉乘和混合积</h2>
<ul>
<li><span class="math inline">\(\pmb{a}\times \pmb{b}=\left |
\begin{matrix}\pmb{i}&amp; \pmb{j}&amp;
\pmb{k}\\a_x&amp;a_y&amp;a_z\\b_x&amp;b_y&amp;b_z \end{matrix} \right
|\)</span>
<ul>
<li>大小对应两个向量合成的平行四边形的面积</li>
</ul></li>
<li><span class="math inline">\((\pmb{a}\pmb{b}\pmb{c})=(\pmb{a}\times
\pmb{b})\cdot \pmb{c}=\left |
\begin{matrix}a_x&amp;a_y&amp;a_z\\b_x&amp;b_y&amp;b_z
\\c_x&amp;c_y&amp;c_z\end{matrix} \right |\)</span>
<ul>
<li>大小对应三个向量合成的平行六面体的体积</li>
</ul></li>
</ul>
<h2 id="平面和直线">平面和直线</h2>
<ul>
<li>平面
<ul>
<li><span class="math inline">\(Ax+By+Cz+D=0\)</span></li>
<li>通过梯度计算，得到<span class="math inline">\((A,B,C)\)</span>是法向量</li>
</ul></li>
<li>直线
<ul>
<li><span class="math inline">\(\frac{x-x_0}{a}=\frac{y-y_0}{b}=\frac{z-z_0}{c}\)</span></li>
<li>通过定义法，得到<span class="math inline">\((a,b,c)\)</span>是方向向量，要求不是零向量</li>
</ul></li>
<li>平面间位置关系
<ul>
<li>利用法向量</li>
</ul></li>
<li>直线间位置关系
<ul>
<li>利用方向向量</li>
</ul></li>
<li>平面和直线的位置关系
<ul>
<li>利用法向量和方向向量</li>
</ul></li>
<li>点到平面的距离
<ul>
<li><span class="math inline">\(d=\frac{|Ax_0+By_0+Cz_0+D|}{\sqrt{A^2+B^2+C^2}}\)</span></li>
<li>本质是把点和平面上某点相连，利用数量积求出连成的向量在法向量上的投影</li>
</ul></li>
<li>点到直线的距离
<ul>
<li>把点和直线上某点相连，利用向量积求出连成的向量在垂直于方向向量上的投影</li>
</ul></li>
<li>平面直线的距离
<ul>
<li>用点到直线的距离来求</li>
</ul></li>
<li>异面直线的距离
<ul>
<li>在两个直线上分别取点连成向量，把<strong>混合积</strong>（两个方向向量和连成的向量）的大小除以两个方向向量<strong>叉乘</strong>的大小</li>
<li>本质上平行六面体体积除以底面的面积，就是高度，即异面直线的距离</li>
</ul></li>
</ul>
<h2 id="曲面和曲线">曲面和曲线</h2>
<ul>
<li>变量数比方程数多<span class="math inline">\(2\)</span>，则为曲面，变量数比方程数多<span class="math inline">\(1\)</span>，则为曲线</li>
<li>旋转面方程
<ul>
<li>利用点到转轴的距离不变性</li>
</ul></li>
<li>柱面方程
<ul>
<li>准线上取一点<span class="math inline">\((x_0,y_0,z_0)\)</span>，写出过该点母线的参数直线方程<span class="math inline">\(\frac{x-x_0}{a}=\frac{y-y_0}{b}=\frac{z-z_0}{c}=t\)</span></li>
<li>把<span class="math inline">\(x_0,y_0,z_0\)</span>用<span class="math inline">\(x,y,z,t\)</span>表示出，再带回准线方程，即可达到曲线参数式方程</li>
</ul></li>
<li>曲线在某个坐标平面的投影
<ul>
<li>曲线一般有两个方程表示三个未知量，即两个曲面的交线</li>
<li>比如在<span class="math inline">\(x-y\)</span>平面的投影，只需要把两个方程的<span class="math inline">\(z\)</span>消掉即可</li>
<li>注意变量的取值范围</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第六章-多元函数积分学</title>
    <url>/2021/12/11/calculus6/</url>
    <content><![CDATA[<ul>
<li>本知识总结不提供完整的理论体系汇总，旨在给出<em>概念的理解</em>以及<em>各类问题的思考框架</em>。</li>
<li>笔记为个人整理，禁止商业用途</li>
<li>如有疏漏，欢迎留言</li>
</ul>
<h2 id="重积分">重积分</h2>
<h3 id="二重积分">二重积分</h3>
<ul>
<li>性质：和一元积分类似，有保号性和中值定理</li>
<li>计算：直角坐标、极坐标，注意用合适的积分次序计算累次积分
<ul>
<li><span class="math inline">\(ds=dx\cdot dy=dr\cdot
rd\theta\)</span></li>
</ul></li>
<li>技巧1：根据积分域的对称性和被积函数的奇偶性简化计算
<ul>
<li>情况一：积分域关于坐标轴对称，被积函数有奇偶性
<ul>
<li>积分等于<span class="math inline">\(0\)</span>或两倍的半积分域上的积分</li>
</ul></li>
<li>情况二：积分域关于<span class="math inline">\(y=x\)</span>对称（即积分域表达式调换<span class="math inline">\(x,y\)</span>不改变积分域）
<ul>
<li>被积函数调换<span class="math inline">\(x,y\)</span>不改变积分结果</li>
</ul></li>
<li>其他情况：对称性也可以不是关于坐标轴，而是平行于坐标轴的直线</li>
</ul></li>
<li>技巧2：极坐标的极点也可以不选在原点</li>
<li>技巧3：利用形心
<ul>
<li>本质还是利用对称性</li>
</ul></li>
</ul>
<h3 id="三重积分">三重积分</h3>
<ul>
<li>性质：保号性、中值定理</li>
<li>计算：直角坐标、柱坐标、球坐标，注意用合适的积分次序计算累次积分
<ul>
<li><span class="math inline">\(ds=dx\cdot dy\cdot dz=dr\cdot rd\theta
\cdot dz=rsin\varphi d\theta \cdot rd\varphi\cdot dr\)</span></li>
</ul></li>
<li>技巧：和二重积分同理</li>
</ul>
<h3 id="交换累次积分">交换累次积分</h3>
<ul>
<li>二重积分：根据积分上下限确定积分域、绘制草图、按另一种次序确定积分上下限</li>
<li>三重积分：相邻的俩个变量调换积分次序，转化为多遍二重积分的次序调换</li>
</ul>
<h2 id="曲线积分">曲线积分</h2>
<h3 id="第一类曲线积分">第一类曲线积分</h3>
<ul>
<li>先考虑几种情况的奇偶性和对称性，简化计算
<ul>
<li>情况一：积分曲线关于坐标轴对称，被积函数有奇偶性</li>
<li>情况二：积分曲线关于<span class="math inline">\(y=x\)</span>或<span class="math inline">\(x=z\)</span>或<span class="math inline">\(y=z\)</span>对称</li>
</ul></li>
<li>直接计算步骤（核心思路是<span class="math inline">\(dl=\sqrt{d^2x+d^2y+d^2z}\)</span>）
<ul>
<li>设曲线的方程<span class="math inline">\(y=y(x),z=z(x)\)</span>
<ul>
<li>说明每个<span class="math inline">\(x\)</span>唯一对应着<span class="math inline">\(y\)</span>和<span class="math inline">\(z\)</span>，如果是参数式也要注意该点</li>
<li>不唯一对应时，需要拆分曲线为多个段</li>
</ul></li>
<li><span class="math inline">\(\int\limits_{L}f(x,y,z)dl=\int\limits_{L}f(x,y,z)\sqrt{d^2x+d^2y+d^2z}\)</span></li>
<li>最后结果为<span class="math inline">\(\int_{a}^bf(x,y,z)\sqrt{1+(y&#39;(x))^2+(z&#39;(x))^2}dx,a\leq
x\leq b\)</span></li>
</ul></li>
</ul>
<h3 id="第二类曲线积分">第二类曲线积分</h3>
<ul>
<li>直接计算步骤（核心思路是计算<span class="math inline">\((P,Q,R)\)</span>到方向向量的投影）
<ul>
<li>根据积分路径的方向，确定曲线的方向向量为<span class="math inline">\((i,j,k)\)</span>
<ul>
<li>方向向量也可以用其方向余弦表示为<span class="math inline">\((cos\alpha,cos\beta,cos\gamma)\)</span></li>
</ul></li>
<li><span class="math inline">\(\int\limits_LPdx+Qdy+Rdz=\int\limits_L(\frac{(P,Q,R)\cdot(i,j,k)}{|(i,j,k)|})dl\)</span>
<ul>
<li>投影即数量积除以模</li>
<li>转化为第一类曲线积分</li>
</ul></li>
<li>教材的形式是<span class="math inline">\(\int\limits_L(Pcos\alpha+Qcos\beta+Rcos\gamma)dl\)</span>
<ul>
<li>本质一样的，但是不引入余弦，防止思路紊乱</li>
</ul></li>
</ul></li>
<li>斯托克斯公式
<ul>
<li><span class="math inline">\(L\)</span>是空间光滑有向曲线，<span class="math inline">\(\Sigma\)</span>是有向曲面，两者方向满足右手法则，且<span class="math inline">\(P,Q,R\)</span>在<span class="math inline">\(\Sigma\)</span>上有一阶连续偏导数</li>
<li><span class="math inline">\(\oint\limits_LPdx+Qdy+Rdz=\iint\limits_\Sigma(\frac{\partial
R}{\partial y}-\frac{\partial Q}{\partial z})dydz+(\frac{\partial
P}{\partial z}-\frac{\partial R}{\partial x})dzdx+(\frac{\partial
Q}{\partial x}-\frac{\partial P}{\partial y})dxdy\)</span>
<ul>
<li>转化为第二类曲面积分</li>
</ul></li>
</ul></li>
<li>格林公式
<ul>
<li>斯托克斯公式的特殊情况，记忆即可，推导的思路顺序如下</li>
<li>第二类曲线积分<span class="math inline">\(\rightarrow\)</span>第二类曲面积分<span class="math inline">\(\rightarrow\)</span>第一类曲面积分<span class="math inline">\(\rightarrow\)</span>二重积分</li>
</ul></li>
<li><span class="math inline">\(P,Q\)</span>在单连通域的上一阶连续可偏导，则下面是等价条件
<ul>
<li><span class="math inline">\(\int Pdx+Qdy\)</span>和路径无关</li>
<li>沿着封闭光滑曲线的第二类积分为<span class="math inline">\(0\)</span></li>
<li><span class="math inline">\(\frac{\partial Q}{\partial
y}-\frac{\partial P}{\partial x}=0\)</span></li>
<li>存在可微函数<span class="math inline">\(F(x,y)\)</span>使得<span class="math inline">\(dF(x,y)=Pdx+Qdy\)</span></li>
</ul></li>
<li>补形法结合格林公式（斯托克斯公式）
<ul>
<li>当不是封闭曲线时，可以补成封闭曲线
<ul>
<li>补后的整体用格林公式计算，补的形状用直接法计算</li>
</ul></li>
<li>当封闭曲线内有点不存在一阶连续偏导数，则可以补一个小的封闭曲线，把该点挖去
<ul>
<li>补后的整体用格林公式计算，补的形状用直接法计算</li>
</ul></li>
</ul></li>
</ul>
<h2 id="曲面积分">曲面积分</h2>
<h3 id="第一类曲面积分">第一类曲面积分</h3>
<ul>
<li>先考虑几种情况的奇偶性和对称性，简化计算
<ul>
<li>情况一：积分曲面关于坐标轴对称，被积函数有奇偶性</li>
<li>情况二：积分曲面关于<span class="math inline">\(y=x\)</span>或<span class="math inline">\(x=z\)</span>或<span class="math inline">\(y=z\)</span>对称</li>
</ul></li>
<li>直接计算步骤（核心思路是<span class="math inline">\(dS=\frac{dxdy}{|cos\gamma|}\)</span>或<span class="math inline">\(dS=\sqrt{(dxdy)^2+(dydz)^2+(dzdx)^2}\)</span>）
<ul>
<li>设曲面的方程<span class="math inline">\(z=z(x,y)\)</span>，法向量为<span class="math inline">\((cos\alpha,cos\beta,cos\gamma)=\pm\frac{(-z&#39;_x,-z&#39;_y,1)}{\sqrt{(z&#39;_x)^2+(z&#39;_y)^2+1}}\)</span>
<ul>
<li>说明每个<span class="math inline">\((x,y)\)</span>唯一对应着<span class="math inline">\(z\)</span>，如果是参数式也要注意该点</li>
<li>不唯一对应时，需要拆分曲面为多个部分</li>
</ul></li>
<li>利用<span class="math inline">\(\iint\limits_{\Sigma}f(x,y,z)dS=\iint\limits_{\Sigma}f(x,y,z)\frac{dxdy}{|cos\gamma|}\)</span></li>
<li>或<span class="math inline">\(\iint\limits_{\Sigma}f(x,y,z)dS=\iint\limits_{\Sigma}f(x,y,z)\sqrt{1+(\frac{dzdy}{dxdy})^2+(\frac{dzdx}{dydx})^2}dxdy\)</span>
<ul>
<li>注意这里<span class="math inline">\(\frac{dzdy}{dxdy}=\frac{\partial
z}{\partial x}\)</span>与<span class="math inline">\(\frac{dzdx}{dydx}=\frac{\partial z}{\partial
y}\)</span>，不难记忆</li>
</ul></li>
<li>最后结果为<span class="math inline">\(\iint\limits_{\Sigma_{xy}}f(x,y,z)\sqrt{1+(z&#39;_x)^2+(z&#39;_y)^2}dxdy\)</span></li>
</ul></li>
</ul>
<h3 id="第二类曲面积分">第二类曲面积分</h3>
<ul>
<li>直接计算步骤（核心思路是计算<span class="math inline">\((P,Q,R)\)</span>到法向量的投影）
<ul>
<li>根据有向曲面的内外侧，确定曲面的法向量为<span class="math inline">\((i,j,k)\)</span>
<ul>
<li>法向量也可以用其方向余弦表示为<span class="math inline">\((cos\alpha,cos\beta,cos\gamma)\)</span></li>
</ul></li>
<li><span class="math inline">\(\iint\limits_\Sigma
Pdydz+Qdxdz+Rdxdy=\iint\limits_\Sigma
(\frac{(P,Q,R)\cdot(i,j,k)}{|(i,j,k)|})dS\)</span>
<ul>
<li>投影即数量积除以模</li>
<li>转化为第一类曲线积分</li>
</ul></li>
<li>教材的形式是<span class="math inline">\(\iint\limits_\Sigma(Pcos\alpha+Qcos\beta+Rcos\gamma)dS\)</span>
<ul>
<li>本质一样的，但是不引入余弦，防止思路紊乱</li>
</ul></li>
</ul></li>
<li>高斯公式
<ul>
<li><span class="math inline">\(\Sigma\)</span>是空间光滑有向曲面，<span class="math inline">\(\Omega\)</span>是空间闭区域，有向曲面取外侧，且<span class="math inline">\(P,Q,R\)</span>在<span class="math inline">\(\Omega\)</span>上有一阶连续偏导数</li>
<li><span class="math inline">\(\iint\limits_\Sigma
Pdydz+Qdxdz+Rdxdy=\iiint\limits_{\Omega}(\frac{\partial P}{\partial
x}+\frac{\partial Q}{\partial y}+\frac{\partial R}{\partial
z})dV\)</span>
<ul>
<li>转化为三重积分</li>
</ul></li>
</ul></li>
<li>补形法结合高斯公式
<ul>
<li>当不是封闭曲面时，可以补成封闭曲线
<ul>
<li>补后的整体用高斯公式计算，补的形状用直接法计算</li>
</ul></li>
<li>当封闭曲面内有点不存在一阶连续偏导数，则可以补一个小的封闭曲面，把该点挖去
<ul>
<li>补后的整体用高斯公式计算，补的形状用直接法计算</li>
</ul></li>
</ul></li>
</ul>
<h2 id="场论初步">场论初步</h2>
<p>设向量场是<span class="math inline">\(\pmb{A}=(P,Q,R)\)</span>,有向曲面为<span class="math inline">\(\Sigma\)</span></p>
<ul>
<li>通量
<ul>
<li>即第二类曲面积分求解</li>
<li><span class="math inline">\(\Phi=\iint\limits_{\Sigma}Pdydz+Qdzdx+Rdxdy\)</span></li>
</ul></li>
<li>散度
<ul>
<li>即高斯公式右侧的数值</li>
<li><span class="math inline">\(div\pmb{A}=\frac{\partial P}{\partial
x}+\frac{\partial Q}{\partial y}+\frac{\partial R}{\partial
z}\)</span></li>
</ul></li>
<li>旋度
<ul>
<li>即斯托克斯公式右侧的向量</li>
<li><span class="math inline">\(\pmb{rotA}=(\frac{\partial R}{\partial
y}-\frac{\partial Q}{\partial z},\frac{\partial P}{\partial
z}-\frac{\partial R}{\partial x},\frac{\partial Q}{\partial
x}-\frac{\partial P}{\partial y})\)</span></li>
</ul></li>
</ul>
<h2 id="多元积分的应用">多元积分的应用</h2>
<ul>
<li>质心
<ul>
<li><span class="math inline">\(\overline{x}=\frac{\sum xdm}{\sum
dm}\)</span></li>
</ul></li>
<li>转动惯量
<ul>
<li><span class="math inline">\(I=\sum r^2dm\)</span></li>
</ul></li>
<li>做功
<ul>
<li>设力场是<span class="math inline">\(\pmb{F}=(P,Q,R)\)</span>,有向曲线为<span class="math inline">\(L\)</span></li>
<li>做功为<span class="math inline">\(W=\int\limits_LPdx+Qdy+Rdz\)</span></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第七章-无穷级数</title>
    <url>/2021/12/11/calculus7/</url>
    <content><![CDATA[<ul>
<li>本知识总结不提供完整的理论体系汇总，旨在给出<em>概念的理解</em>以及<em>各类问题的思考框架</em>。</li>
<li>笔记为个人整理，禁止商业用途</li>
<li>如有疏漏，欢迎留言</li>
</ul>
<h2 id="理解铺垫">理解铺垫</h2>
<ul>
<li>无穷级数和数列的区别
<ul>
<li>无穷级数本质是<strong>一个</strong>数，这个数的表达形式是<strong>无穷个</strong>数的和（加号连接每一项）</li>
<li>数列本质是<strong>无穷个</strong>数，这无穷个数的表达形式是<strong>无穷个</strong>数的排列（逗号连接每一项）</li>
</ul></li>
<li>无穷级数和数列的联系
<ul>
<li>两者存在1对1的映射关系，级数和数列的第n项指的是同一个数</li>
<li>经常用数列中的理论解决无穷级数问题。比如：级数收敛等价于，级数所对应数列的前n项和（也是一个数列）在无穷处收敛</li>
<li><strong>后面在表述中，在没有歧义的情况下，把“级数所对应数列”表述为“数列”</strong></li>
</ul></li>
</ul>
<h2 id="常数项级数">常数项级数</h2>
<h3 id="正项级数敛散性">正项级数敛散性</h3>
<p>思考顺序和相关定理：</p>
<ul>
<li>收敛定义：适合任意级数
<ul>
<li>数列的和收敛，则级数收敛</li>
<li>若考虑正项级数，则数列的前n项和数列是单调增的，下一步可以考虑上界是否存在</li>
</ul></li>
<li>收敛必要条件：适合任意级数
<ul>
<li>数列不收敛，则级数不收敛</li>
</ul></li>
<li>比值判别法：适合正项级数，使用范围小，判定方便，优先考虑
<ul>
<li>若第n+1项比第n项的极限小于1，级数收敛</li>
<li>若第n+1项比第n项的极限大于1，级数发散</li>
<li>若第n+1项比第n项的极限等于1，不确定敛散性</li>
</ul></li>
<li>根植判别法：适合正项级数，使用范围小，判定方便，优先考虑
<ul>
<li>若第n项开n次根号的极限小于1，级数收敛</li>
<li>若第n项开n次根号的极限大于1，级数发散</li>
<li>若第n项开n次根号的极限等于1，不确定敛散性</li>
</ul></li>
<li>比较判别法：适合正项级数，使用范围大，判定不方便（需要构造新级数），次优考虑
<ul>
<li>已知每一项更大的正项级数收敛（如<span class="math inline">\(\sum_{n=1}^{\infty}
\frac{1}{n^2}\)</span>），则级数收敛</li>
<li>已知每一项更小的正项级数发散（如<span class="math inline">\(\sum_{n=1}^{\infty}
\frac{1}{n}\)</span>），则级数发散</li>
</ul></li>
<li>比较判别法极限形式：适合正项级数，使用范围大，判定不方便（需要构造新级数），次优考虑
<ul>
<li>若极限情况的项比值为常数，则同敛散性</li>
<li>若极限情况的项比值为无穷（即分子更大），分子级数收敛，则分母级数收敛</li>
<li>若极限情况的项比值为0（即分子更小），分子级数发散，则分母级数发散</li>
</ul></li>
<li>积分判别法：适合正项级数
<ul>
<li>找到数列所对应的函数</li>
<li>级数敛散性 = 数列和的敛散性 = 函数积分的敛散性</li>
<li>第一个等号的本质是收敛定义，第二个等号的本质是在定义法求积分的过程使用夹逼定理</li>
</ul></li>
</ul>
<h3 id="交错级数敛散性">交错级数敛散性</h3>
<ul>
<li>莱布尼兹判别准则法（收敛充分条件）：适合交错级数
<ul>
<li>数列项的绝对值递减，极限处等于0</li>
</ul></li>
<li>绝对收敛法（收敛充分条件）：适合任意级数
<ul>
<li>每一项取绝对值后的级数收敛（绝对收敛），则原级数收敛</li>
<li>之所以是充分条件，考虑到原级数收敛，不一定就绝对收敛，也可能条件收敛</li>
</ul></li>
<li>加括号法（收敛必要条件）：适合任意级数，但主要应用于交错级数
<ul>
<li>加括号后的级数发散，则原级数发散</li>
</ul></li>
<li>正项负项法：适合任意级数、交错级数
<ul>
<li>考虑把级数拆分为正项的和、负项的和两个子级数</li>
<li>两个都收敛，则原级数绝对收敛</li>
<li>两个都发散，则原级数条件收敛或发散</li>
<li>一个收敛，一个发散，则原级数发散</li>
</ul></li>
</ul>
<h3 id="任意项级数敛散性">任意项级数敛散性</h3>
<ul>
<li>前面分析的适合任意级数的方法都可以使用</li>
</ul>
<h3 id="证明题和综合题">证明题和综合题</h3>
<ul>
<li>基本思路：从定义出发分析，可以使用前面的级数敛散性判定方法</li>
<li>常用定理：数列的单调有界定理、夹逼定理</li>
<li>冷僻结论：数列的极限 = 数列前n项平均值的极限</li>
<li>常考题型：
<ul>
<li>问题：给出数列递推式，求收敛值</li>
<li>方法
<ul>
<li>首先证明收敛性，比如用数列单调有界定理</li>
<li>然后求收敛情况下可能的收敛值，一般是取极限、解方程</li>
</ul></li>
</ul></li>
</ul>
<h2 id="函数项级数">函数项级数</h2>
<h3 id="理解铺垫-1">理解铺垫</h3>
<ul>
<li>函数项级数的理解：
<ul>
<li>常数项级数可以理解为一个常数</li>
<li>函数项级数，也<strong>可以理解为</strong>一个函数（一个x映射到唯一的常数项级数）</li>
</ul></li>
<li>收敛域的理解
<ul>
<li>x取某值时，所映射的级数收敛，该值为收敛点</li>
<li>收敛域是所有收敛点的集合</li>
</ul></li>
<li>函数和函数项级数的关系
<ul>
<li>在收敛域上，x可以映射到唯一的一个数，此时函数项级数<strong>就是</strong>函数，叫做和函数，两者只是表达形式有所不同，值相同</li>
<li>函数项级数是和函数在收敛域上的展开</li>
<li>和函数是函数项级数在收敛域上的和值</li>
</ul></li>
</ul>
<h3 id="幂级数">幂级数</h3>
<ul>
<li>收敛半径R：x大于R，幂级数发散；x小于R幂级数绝对收敛；x等于R单独考虑敛散性</li>
<li>收敛区间
<ul>
<li>定义：(-R，R)，不包括收敛半径的端点，开区间</li>
<li>求法：幂级数取绝对值，用正项级数比较判别法或根值判别法进行分析</li>
<li>作用：幂级数<span class="math inline">\(\sum_{n=1}^\infty
a_nx^{n}\)</span>的和函数<span class="math inline">\(S(x)\)</span>在收敛区间上
<ul>
<li>连续</li>
<li>可导且可逐项求导，即<span class="math inline">\(S&#39;(x)=\sum_{n=1}^\infty
na_nx^{n-1}\)</span></li>
<li>可积分（从0到x）且可逐项积分，即<span class="math inline">\(\int_0^x
S(t)dt=\sum_{n=1}^\infty \frac{a_n}{n+1}x^{n+1}\)</span></li>
</ul></li>
<li>收敛区间是不包括端点的，如果要考虑幂级数的和函数从0到R是否可以逐项积分，则要求
<ul>
<li>和函数的原函数左连续性：和函数从0到R积分 =
和函数从0到极限接近R处的积分</li>
<li>幂级数逐项积分后的级数收敛性</li>
</ul></li>
</ul></li>
</ul>
<h3 id="泰勒级数">泰勒级数</h3>
<ul>
<li>泰勒级数泰勒中值定理的区别是
<ul>
<li>前者把函数展开为无穷项</li>
<li>后者把函数展开为有穷项+带<span class="math inline">\(\xi\)</span>余项的形式</li>
</ul></li>
<li>要记住常见麦克劳林级数
<ul>
<li><span class="math inline">\((1+x)^k=1+kx+\frac{k(k-1)}{2!}x^2+\cdots\)</span>
<ul>
<li>记忆方法：当k为正整数时就是二项式展开</li>
<li>收敛区间：建议记住为<span class="math inline">\((-1,1)\)</span>，收敛域取决于<span class="math inline">\(k\)</span></li>
</ul></li>
<li><span class="math inline">\(\frac{1}{1-x}=1+x+x^2+\cdots\)</span>
<ul>
<li>记忆方法：其实是<span class="math inline">\((1+x)^k=1+kx+\frac{k(k-1)}{2!}x^2+\cdots\)</span>一种特例</li>
<li>收敛域：<span class="math inline">\((-1,1)\)</span></li>
</ul></li>
<li><span class="math inline">\(\frac{1}{1+x}=1-x+x^2-\cdots\)</span>
<ul>
<li>记忆方法：其实是<span class="math inline">\((1+x)^k=1+kx+\frac{k(k-1)}{2!}x^2+\cdots\)</span>一种特例</li>
<li>收敛域：<span class="math inline">\((-1,1)\)</span></li>
</ul></li>
<li><span class="math inline">\(ln(1+x)=x-\frac{x^2}{2}+\frac{x^3}{3}-\cdots\)</span>
<ul>
<li>记忆方法：<span class="math inline">\(\frac{1}{1+x}=1-x+x^2-\cdots\)</span>进行逐项积分</li>
<li>收敛域：<span class="math inline">\((-1,1]\)</span></li>
</ul></li>
<li><span class="math inline">\(e^x=1+x+\frac{x^2}{2!}+\cdots\)</span>
<ul>
<li>记忆方法：本条开始全是<strong>带阶乘的形式</strong>且收敛域都是双无穷区间，可以通过<span class="math inline">\(e^x\)</span>和<span class="math inline">\(1+x\)</span>的等价无穷小关系联想</li>
<li>收敛域：<span class="math inline">\((-\infty,+\infty)\)</span></li>
</ul></li>
<li><span class="math inline">\(cosx=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\cdots\)</span>
<ul>
<li>记忆方法：通过<span class="math inline">\(cosx\)</span>和<span class="math inline">\(1-\frac{x}{2!}\)</span>等价无穷小联想</li>
<li>收敛域：<span class="math inline">\((-\infty,+\infty)\)</span></li>
</ul></li>
<li><span class="math inline">\(sinx=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\cdots\)</span>
<ul>
<li>记忆方法：记住了<span class="math inline">\(cosx\)</span>的展开，不难联想<span class="math inline">\(sinx\)</span>的展开</li>
<li>收敛域：<span class="math inline">\((-\infty,+\infty)\)</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="幂级数的收敛域">幂级数的收敛域</h3>
<ul>
<li>先求收敛区间（收敛半径），前面已经提到过</li>
<li>再考虑端点敛散性</li>
</ul>
<h3 id="幂级数展开">幂级数展开</h3>
<ul>
<li>不推荐用泰勒级数直接展开</li>
<li>用前面的7个常用麦克劳林级数进行配凑</li>
<li>配凑方法有
<ul>
<li>级数每一项同时提出一个x或凑出一个x</li>
<li>逐项求导或逐项积分，需要对导数表和积分表熟悉</li>
</ul></li>
<li>配凑的注意事项
<ul>
<li>注意各常用麦克劳林级数的首项，防止下标开始位置出错</li>
<li>注意考虑麦克劳林级数的收敛域<br>
</li>
<li>注意配凑时除以x，要讨论x为0的情况，否则定义域有问题</li>
<li>注意级数在和式中如果有<span class="math inline">\(x^0\)</span>的项，一律按<span class="math inline">\(x^0=1\)</span>处理，哪怕是<span class="math inline">\(x=0\)</span>的情况也按<span class="math inline">\(0^0=1\)</span>处理</li>
</ul></li>
<li>默认情况需要给出收敛域</li>
</ul>
<h3 id="函数在某点的高阶导数">函数在某点的高阶导数</h3>
<ul>
<li>使用幂级数展开</li>
<li>低阶项求导后为0</li>
<li>题目往往设置某点的值，恰好使得高阶项全部为0</li>
</ul>
<h3 id="级数求和">级数求和</h3>
<ul>
<li>常数项级数求和
<ul>
<li>数列求和直接计算</li>
<li>利用常用麦克劳林展开进行配凑（如级数每一项提出x、凑x、逐项积分、逐项求导等），需要思考哪个常数部分是x，要求常数在收敛域范围内</li>
</ul></li>
<li>函数项级数求和：核心还是配凑，如级数每一项提出x、凑x、逐项积分、逐项求导等</li>
</ul>
<h2 id="傅里叶级数">傅里叶级数</h2>
<h3 id="理解铺垫-2">理解铺垫</h3>
<ul>
<li>傅里叶级数指的是把周期函数展开为每一项为正余弦的三角级数</li>
<li>因为和函数是周期函数，展开的每一项也是周期函数，所以实际问题中往往只需要考虑一个周期的展开即可（很多教材没有指明这个点，很容易造成迷惑）</li>
<li>因为只需要考虑一个周期，一般选择关于原点对称的区间，方便计算。即使问题不是问原点对称区间的情况，也可以先计算原点对称区间的展开，然后补充一个利用函数周期性的步骤</li>
<li>一般考虑周期为<span class="math inline">\(2\pi\)</span>和<span class="math inline">\(2l\)</span>两个情况</li>
</ul>
<h3 id="傅里叶级数的收敛性">傅里叶级数的收敛性</h3>
<ul>
<li>课本的狄利克雷定理对周期函数一个周期上的连续情况进行讨论</li>
<li>实际上可以在实数域上考虑，定理等价精简为
<ul>
<li>如果周期函数一个周期内只有有限个第一类间断点（跳跃、可去）和有限个极值点，则函数的傅里叶级数收敛</li>
<li>在周期函数连续处，傅里叶级数收敛于周期函数</li>
<li>在周期函数间断处，傅里叶级数收敛于间断两侧的平均值</li>
</ul></li>
</ul>
<h3 id="周期函数的傅里叶展开">周期函数的傅里叶展开</h3>
<ul>
<li><span class="math inline">\(f(x)\sim \frac{a_0}{2}+\sum_{n=1}^\infty
[a_ncos(\frac{\pi nx}{l})+b_nsin(\frac{\pi nx}{l})]\)</span></li>
<li><span class="math inline">\(a_n=\frac{1}{l}\int_{-l}^{l}f(x)cos(\frac{\pi
nx}{l})dx\)</span></li>
<li><span class="math inline">\(b_n=\frac{1}{l}\int_{-l}^{l}f(x)sin(\frac{\pi
nx}{l})dx\)</span></li>
<li>这里之所以用<span class="math inline">\(\sim\)</span>而不是<span class="math inline">\(=\)</span>，因为周期函数在间断点不等于傅里叶级数</li>
<li>需要根据周期函数，分析傅里叶级数的收敛性，如果级数收敛且没有间断点，<span class="math inline">\(\sim\)</span>可以改写成<span class="math inline">\(=\)</span></li>
<li>利用奇偶展开来辅助理解和记忆
<ul>
<li>如果<span class="math inline">\(f(x)\)</span>是偶函数
<ul>
<li>则<span class="math inline">\(f(x)sin(\frac{\pi
nx}{l})\)</span>为奇函数</li>
<li>则<span class="math inline">\(b_n=0\)</span></li>
<li>则<span class="math inline">\(f(x)\sim
\frac{a_0}{2}+\sum_{n=1}^\infty a_ncos(\frac{\pi nx}{l})\)</span></li>
<li>则级数的每一项都是偶函数余弦</li>
<li>傅里叶偶展开又叫傅里叶余弦展开</li>
</ul></li>
<li>如果<span class="math inline">\(f(x)\)</span>是奇函数
<ul>
<li>则<span class="math inline">\(f(x)cos(nx)\)</span>为奇函数</li>
<li>则<span class="math inline">\(a_n=0\)</span></li>
<li>则<span class="math inline">\(f(x)\sim \sum_{n=1}^\infty
b_nsin(\frac{\pi nx}{l})\)</span></li>
<li>则级数的每一项都是奇函数正弦</li>
<li>傅里叶奇展开又叫傅里叶正弦展开</li>
</ul></li>
</ul></li>
</ul>
<h3 id="周期函数的拓展">周期函数的拓展</h3>
<ul>
<li>奇偶拓展（正余弦展开）：如果已知一个定义在原点单侧的区间上的函数，对其进行傅里叶奇展开或偶展开的步骤为
<ul>
<li>先把该函数当奇函数或偶函数拓展</li>
<li>再用周期函数性质把该函数拓展到整个R区间内</li>
<li>最后对该周期函数进行傅里叶展开并分析收敛性（<span class="math inline">\(\sim\)</span>看情况改写为<span class="math inline">\(=\)</span>）</li>
</ul></li>
<li>任意区间拓展：如果已知一个定义在非原点对称区间上的函数，对其进行傅里叶展开的步骤为
<ul>
<li>利用周期函数性质把该函数拓展到整个R区间内</li>
<li>对该周期函数傅里叶展开并分析收敛性（<span class="math inline">\(\sim\)</span>看情况改写为<span class="math inline">\(=\)</span>）</li>
<li>回答在给定区间上的展开情况（用<span class="math inline">\(=\)</span>连接函数和傅里叶级数）</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第八章-常微分方程</title>
    <url>/2021/12/11/calculus8/</url>
    <content><![CDATA[<ul>
<li>本知识总结不提供完整的理论体系汇总，旨在给出<em>概念的理解</em>以及<em>各类问题的思考框架</em>。</li>
<li>笔记为个人整理，禁止商业用途</li>
<li>如有疏漏，欢迎留言</li>
</ul>
<h2 id="可分离变量微分方程">可分离变量微分方程</h2>
<ul>
<li>形式：<span class="math inline">\(y\)</span>和<span class="math inline">\(x\)</span>可分离到等式两侧</li>
<li>方法：分离变量至两次后，两端积分即可</li>
</ul>
<h2 id="齐次微分方程">齐次微分方程</h2>
<ul>
<li>形式：<span class="math inline">\(\frac{dy}{dx}=f(\frac{y}{x})\)</span></li>
<li>思路：换元令<span class="math inline">\(t=\frac{y}{x}\)</span></li>
<li>注意：所有的换元操作在解出微分方程后都需要把原变量带回去，结果中的变量必须是原始的</li>
</ul>
<h2 id="一阶线性方程">一阶线性方程</h2>
<ul>
<li>形式：<span class="math inline">\(\frac{dy}{dx}+P(x)y=Q(x)\)</span></li>
<li>思路
<ul>
<li>背公式<span class="math inline">\(y=e^{-\int P(x)dx}\times(\int
Q(x)e^{\int P(x)dx}dx+C)\)</span></li>
<li>注意：因为是一阶微分方程，只带一个常数C，公式中的不定积分不需要带上常数</li>
</ul></li>
</ul>
<h2 id="伯努利方程">伯努利方程</h2>
<ul>
<li>形式：<span class="math inline">\(\frac{dy}{dx}+P(x)y=Q(x)y^n\)</span></li>
<li>思路
<ul>
<li>换元令<span class="math inline">\(u=y^{1-n},du=(1-n)y^{-n}dy\)</span></li>
<li>替换掉原式的<span class="math inline">\(dy\)</span>即可转化为一阶线性方程</li>
</ul></li>
</ul>
<h2 id="全微分方程">全微分方程</h2>
<ul>
<li>形式<span class="math inline">\(P(x,y)dx+Q(x,y)dy=0\)</span>，<span class="math inline">\(P,Q\)</span>有一阶连续偏导数，且<span class="math inline">\(\frac{\partial P}{\partial y}=\frac{\partial
Q}{\partial x}\)</span></li>
<li>思路：凑积分或偏积分求全微分的原函数，<span class="math inline">\(P(x,y)dx+Q(x,y)dy=du(x,y)=0\)</span></li>
</ul>
<h2 id="对称情况">对称情况</h2>
<ul>
<li>形式：有可能出现<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>的位置对调的情况</li>
<li>思路：把<span class="math inline">\(y\)</span>当<span class="math inline">\(x\)</span>，<span class="math inline">\(x\)</span>当<span class="math inline">\(y\)</span>来处理即可</li>
</ul>
<h2 id="可降阶的高阶微分方程">可降阶的高阶微分方程</h2>
<ul>
<li>一般只有三种形式
<ul>
<li><span class="math inline">\(y^{(n)}=f(x)\)</span></li>
<li><span class="math inline">\(y&#39;&#39;=f(x,y&#39;)\)</span></li>
<li><span class="math inline">\(y&#39;&#39;=f(y,y&#39;)\)</span></li>
</ul></li>
<li>思路分别对应如下
<ul>
<li>反复积分降阶</li>
<li>换元令<span class="math inline">\(y&#39;=u,y&#39;&#39;=\frac{du}{dx}\)</span>，降阶为<span class="math inline">\(u\)</span>和<span class="math inline">\(x\)</span>的一阶方程<span class="math inline">\(\frac{du}{dx}=f(x,u)\)</span></li>
<li>换元令<span class="math inline">\(y&#39;=u,y&#39;&#39;=\frac{du}{dx}=\frac{du}{dy}\frac{dy}{dx}=\frac{du}{dy}u\)</span>，降阶为<span class="math inline">\(u\)</span>和<span class="math inline">\(y\)</span>一阶方程<span class="math inline">\(\frac{du}{dy}u=f(y,u)\)</span></li>
</ul></li>
</ul>
<h2 id="线性方程解的结构">线性方程解的结构</h2>
<ul>
<li>齐次方程
<ul>
<li>方程的阶数即线性无关的解个数</li>
<li>通解：阶数个线性无关的解的线性组合</li>
</ul></li>
<li>非齐次方程：非齐次方程的通解 = 非齐次方程的一个特解 +
对应齐次方程的通解</li>
<li>叠加原理
<ul>
<li>用的比较少</li>
<li>指的是，已知两个非齐次微分方程的特解<span class="math inline">\(y_1,y_2\)</span>，则把两个非齐次方程右侧的x多项式相加后得到的非齐次方程的特解是<span class="math inline">\(y_1+y_2\)</span></li>
<li>不用背，按定义很容易推导</li>
</ul></li>
</ul>
<h2 id="线性常系数齐次方程">线性常系数齐次方程</h2>
<ul>
<li>形式：<span class="math inline">\(y^{(n)}+p_1y^{(n-1)}+\cdots+p_{n-1}y&#39;+p_ny=0\)</span></li>
<li>求解步骤
<ul>
<li>解特征方程<span class="math inline">\(y^{n}+p_1y^{n-1}+\cdots+p_{n-1}y+p_n=0\)</span>（即k阶导换成k次方）</li>
<li>每一重实根对应着一个线性无关的解，每一重<strong>复根对</strong>对应两个线性无关的解，对应如下</li>
<li>单实根<span class="math inline">\(r\)</span>
<ul>
<li><span class="math inline">\(Ce^{rx}\)</span></li>
</ul></li>
<li><span class="math inline">\(k\)</span>重实根<span class="math inline">\(r\)</span>
<ul>
<li><span class="math inline">\((C_1+C_2x+\cdots+C_kx^{k-1})e^{rx}\)</span></li>
</ul></li>
<li>单重复根对<span class="math inline">\(a\pm bi\)</span>
<ul>
<li><span class="math inline">\([C_1cos(bx)+C_2sin(bx)]e^{ax}\)</span></li>
</ul></li>
<li>k重复根对<span class="math inline">\(a\pm bi\)</span>
<ul>
<li><span class="math inline">\([(C_1+C_2x+\cdots+C_kx^{k-1})cos(bx)+(D_1+D_2x+\cdots+D_kx^{k-1})sin(bx)]e^{ax}\)</span></li>
</ul></li>
</ul></li>
</ul>
<h2 id="线性常系数非齐次方程">线性常系数非齐次方程</h2>
<ul>
<li>形式：<span class="math inline">\(y^{(n)}+p_1y^{(n-1)}+\cdots+p_{n-1}y&#39;+p_ny=f(x)\)</span></li>
<li>求解步骤
<ul>
<li>解对应齐次方程的通解</li>
<li>寻找一个非齐次方程的特解</li>
<li>利用线性方程解的结构，非齐次方程特解 + 齐次方程通解 =
非齐次方程通解</li>
</ul></li>
<li>非齐次方程特解求解方法
<ul>
<li>已知<span class="math inline">\(f(x)=e^{ax}[P_m(x)cos(bx)+P_n(x)sin(bx)]\)</span></li>
<li><span class="math inline">\(P_m\)</span>和<span class="math inline">\(P_n\)</span>是两个给定的<span class="math inline">\(m\)</span>次、<span class="math inline">\(n\)</span>次多项式</li>
<li>设特解为<span class="math inline">\(y^\star=x^ke^{ax}[Q_l(x)cos(bx)+R_l(x)sin(bx)]\)</span></li>
<li><span class="math inline">\(k\)</span>为特征方程的复根对<span class="math inline">\(a\pm bi\)</span>的重数</li>
<li><span class="math inline">\(l=\max\{m,n\}\)</span></li>
<li><span class="math inline">\(Q_l\)</span>和<span class="math inline">\(R_l\)</span>是两个待定系数的<span class="math inline">\(l\)</span>次多项式</li>
<li>特解待定系数带入原微分方程，算出特解</li>
</ul></li>
</ul>
<h2 id="欧拉方程">欧拉方程</h2>
<ul>
<li>形式：<span class="math inline">\(x^ny^{(n)}+p_1x^{n-1}y^{(n-1)}+p_2x^{n-2}y^{(n-2)}+\cdots+p_{n-1}y=f(x)\)</span></li>
<li>思路
<ul>
<li>这是<span class="math inline">\(y\)</span>关于<span class="math inline">\(x\)</span>线性微分方程，但不是常系数</li>
<li>设<span class="math inline">\(t=lnx\)</span>，则<span class="math inline">\(x^ky^{(k)}=D(D-1)\cdots(D-k+1)y\)</span>，<span class="math inline">\(D=\frac{d}{dt}\)</span></li>
<li>上面一条把<span class="math inline">\(y\)</span>关于<span class="math inline">\(x\)</span>的<span class="math inline">\(k\)</span>阶导数换成了<span class="math inline">\(y\)</span>关于<span class="math inline">\(t\)</span>的<span class="math inline">\(k\)</span>的阶导数。推导不难，但步骤比较繁琐，可以推但没必要，建议背下来直接使用。</li>
<li>换元后变成关于<span class="math inline">\(y\)</span>关于<span class="math inline">\(t\)</span>的线性常系数微分方程，用前面的方法求解</li>
<li>求解后把<span class="math inline">\(t\)</span>换回<span class="math inline">\(x\)</span></li>
</ul></li>
</ul>
<h2 id="已知通解求方程">已知通解求方程</h2>
<ul>
<li>根据通解<span class="math inline">\(y\)</span>，求出<span class="math inline">\(y&#39;\)</span>和<span class="math inline">\(y&#39;&#39;\)</span></li>
<li>消去上面的常量即可得到微分方程</li>
</ul>
<h2 id="微分方程应用题">微分方程应用题</h2>
<ul>
<li>根据题干条件思考变量之间的微分关系</li>
<li>列出微分方程</li>
<li>求解微分方程</li>
</ul>
]]></content>
      <categories>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 电阻电路分析</title>
    <url>/2022/05/05/circuit-analysis-2/</url>
    <content><![CDATA[<h2 id="kcl独立方程">KCL独立方程</h2>
<ul>
<li><span class="math inline">\(n\)</span>个节点的连通图，有且仅有<span class="math inline">\(n-1\)</span>个独立的KCL方程</li>
<li>任取<span class="math inline">\(n-1\)</span>个节点列出的KCL方程相互独立，这些节点叫独立节点</li>
</ul>
<h2 id="kvl独立方程">KVL独立方程</h2>
<ul>
<li><span class="math inline">\(n\)</span>个节点、<span class="math inline">\(b\)</span>条支路的连通图，有且仅有<span class="math inline">\(b-n+1\)</span>个独立的方程</li>
<li>能列出独立KVL方程的回路称为独立回路
<ul>
<li><span class="math inline">\(b+1-n\)</span>个基本回路对应<span class="math inline">\(b+1-n\)</span>个网孔</li>
</ul></li>
<li>注：该结论本质上是图论的欧拉定理
<ul>
<li>面数对应网孔数</li>
<li>边数对应支路数</li>
<li>点数对应节点数</li>
</ul></li>
</ul>
<h2 id="b法">2b法</h2>
<ul>
<li>思想
<ul>
<li><span class="math inline">\(b\)</span>个支路，设定<span class="math inline">\(b\)</span>个电压和<span class="math inline">\(b\)</span>个电流，共<span class="math inline">\(2b\)</span>个变量来列后续的方程</li>
</ul></li>
<li>步骤
<ul>
<li>列出<span class="math inline">\(n-1\)</span>个独立KCL方程</li>
<li>列出<span class="math inline">\(b-n+1\)</span>个独立KVL方程</li>
<li>列出<span class="math inline">\(b\)</span>个支路的欧姆定律方程</li>
<li>共<span class="math inline">\(2b\)</span>个方程，解<span class="math inline">\(2b\)</span>个变量</li>
</ul></li>
</ul>
<h2 id="支路法">支路法</h2>
<ul>
<li>思想
<ul>
<li><span class="math inline">\(b\)</span>个支路，设定<span class="math inline">\(b\)</span>个电压<strong>或</strong><span class="math inline">\(b\)</span>个电流，共<span class="math inline">\(b\)</span>个变量来列后续的方程</li>
</ul></li>
<li>步骤
<ul>
<li>列出<span class="math inline">\(n-1\)</span>个独立KCL方程</li>
<li>列出<span class="math inline">\(b-n+1\)</span>个独立KVL方程</li>
<li>共<span class="math inline">\(b\)</span>个方程，解<span class="math inline">\(b\)</span>个变量</li>
</ul></li>
</ul>
<h2 id="回路法">回路法</h2>
<ul>
<li>思想
<ul>
<li><span class="math inline">\(b+1-n\)</span>条独立回路，设定<span class="math inline">\(b+1-n\)</span>个回路电流，求解出回路电流从而很容易表示出支路电流的方法
<ul>
<li>回路电流本质上是电路中所有电流的一种分解</li>
</ul></li>
<li>特殊情况是选择网孔作为独立回路，此时叫网孔法
<ul>
<li>网孔法简单直观，但计算繁琐，只适用于平面图</li>
<li>一般的回路法灵活，但列方程不直观</li>
</ul></li>
</ul></li>
<li>步骤
<ul>
<li>选出<span class="math inline">\(b+1-n\)</span>条独立回路</li>
<li>用<span class="math inline">\(b+1-n\)</span>个回路电流变量表示<span class="math inline">\(b\)</span>个支路电流变量</li>
<li>列出<span class="math inline">\(b+1-n\)</span>个KVL方程，解出所有回路电流变量
<ul>
<li>该方法的核心目标就是求回路电流</li>
<li>需要使用欧姆定律</li>
</ul></li>
<li>从而进一步表示出支路电流变量、支路电压变量等</li>
</ul></li>
<li>电流源的处理
<ul>
<li>若流经电流源的回路电流只有一个，回路电流等于电流源电流</li>
<li>当流经电源流的回路有多个，可以把电流源当作电压源处理，多引入一个变量<span class="math inline">\(U\)</span>
<ul>
<li>多出来的一个方程根据电流源的位置选节点，用KCL方程补即可</li>
</ul></li>
</ul></li>
<li>受控源处理
<ul>
<li>首先将其看成独立电源，多出一个电压或电流变量</li>
<li>根据受控源的电压电流控制关系，补一个控制方程即可</li>
</ul></li>
</ul>
<h2 id="节点法">节点法</h2>
<ul>
<li>思想
<ul>
<li>以节点电压（电位）为未知变量列出并求解电路的方法</li>
<li>需要任意选定一个节点为参考点</li>
</ul></li>
<li>步骤
<ul>
<li>在<span class="math inline">\(n\)</span>个节点中选定一个参考点电位<span class="math inline">\(u_1=0\)</span>，假设其余<span class="math inline">\(n-1\)</span>点的电位<span class="math inline">\(u_2,\cdots,u_{n}\)</span></li>
<li>用<span class="math inline">\(n-1\)</span>个节点电压表示出<span class="math inline">\(b\)</span>个支路电压</li>
<li>列出<span class="math inline">\(n-1\)</span>个KCL方程，解出所有节点电压变量
<ul>
<li>该方法的核心目标就是求节点电压</li>
<li>需要使用欧姆定律</li>
</ul></li>
<li>从而进一步表示出支路电流变量、支路电压变量等</li>
</ul></li>
<li>电压源的处理
<ul>
<li>有伴电压源处理（和电阻串联的电压源）
<ul>
<li>转化为与电阻并联的电流源即可</li>
</ul></li>
<li>无伴电压源处理
<ul>
<li>若一端是参考点，则另一端的节点电压直接可得</li>
<li>若两端都不是参考节点，则将其当作电流源处理，多引入一个变量<span class="math inline">\(u\)</span>，多出来的一个方程根据电压源的位置选环路，用KVL方程补即可</li>
</ul></li>
</ul></li>
<li>受控源处理
<ul>
<li>首先将其看成独立电源，多出一个电压或电流变量</li>
<li>根据受控源的电压电流控制关系，补一个控制方程即可</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>电路分析</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 电路的基本定律</title>
    <url>/2022/04/12/circuit-analysis-1/</url>
    <content><![CDATA[<h2 id="电路模型">电路模型</h2>
<ul>
<li>电路
<ul>
<li>电器件互相连接构成的电流通路</li>
<li>一定包括电源、负载、导线</li>
</ul></li>
<li>电路功能
<ul>
<li>能量产生、传输、转换</li>
<li>对信号发射、接收、传输、处理</li>
</ul></li>
<li>理想电器元件模型
<ul>
<li>理想电阻元件
<ul>
<li>只消耗电能，如电阻器、灯泡、电炉</li>
</ul></li>
<li>理想电容元件
<ul>
<li>只存储电脑，如各种电容器</li>
</ul></li>
<li>理想电感元件
<ul>
<li>只存储磁能，如各种电感线圈</li>
</ul></li>
</ul></li>
<li>电路模型（电路图）
<ul>
<li>把实际电路的各个器件用器件模型表示，按原方式连接</li>
<li>电路理论研究的对象都是电路模型，是实际电路的抽象</li>
<li>一个实际电路可能有多个电路模型</li>
</ul></li>
</ul>
<h2 id="电路分类">电路分类</h2>
<ul>
<li>集总参数电路（lumped circuit）和分布式参数电路（distributed
circuit）
<ul>
<li>前者的电路尺寸远小于电磁波波长，此时认为电路各处电磁能量同时到达，电路为电磁空间一个点，导线上的电流处处相等</li>
<li>反之为后者</li>
</ul></li>
<li>线性电路（linear circuit）和非线性电路（nonlinear circuit）
<ul>
<li>描述前者的方程都是线性的代数或者微分方程，完全由线性元件、独立源、线性受控源构成</li>
<li>反之为后者，更普遍</li>
</ul></li>
<li>时不变电路（time-invariant circuit）和时变电路（time-varying
circuit）
<ul>
<li>前者的元件参数值不随时间变化，描述的方程是常系数的代数或微积分方程</li>
<li>反之为后者</li>
</ul></li>
<li>动态电路（dynamic circuit）和电阻电路（resistance circuit）
<ul>
<li>前者含有储能元件，如电感或电容，描述方程为微积分方程</li>
<li>反之为后者，描述方程为代数方程</li>
</ul></li>
<li>有源电路（active circuit）和无源电路（passive circuit）
<ul>
<li>某种情况能对外提供能量为前者</li>
<li>任何情况都不能对外提供能量为后者</li>
</ul></li>
</ul>
<h2 id="电路变量">电路变量</h2>
<h3 id="分类">分类</h3>
<ul>
<li>基本变量
<ul>
<li>电流</li>
<li>电压</li>
</ul></li>
<li>复合变量
<ul>
<li>功率</li>
<li>能量</li>
</ul></li>
</ul>
<h3 id="电流变量">电流变量</h3>
<ul>
<li>电流的形成
<ul>
<li>电荷在电场力作用下有规则的定向移动</li>
</ul></li>
<li>电流强度<span class="math inline">\(i(t)\)</span>
<ul>
<li>单位时间内通过导体横截面的电荷量，单位安培（A）</li>
<li><span class="math inline">\(i(t)=\frac{dq(t)}{dt}\)</span></li>
</ul></li>
<li>电流方向：正电荷运动的方向
<ul>
<li>实际方向：正电荷运动的方向</li>
<li>参考方向：电路图中所假定正电荷运动的方向（若计算的结果为正，则参考方向就是实际方向，反之参考方向为实际方向的反方向）</li>
<li>电路图的电流方向标注
<ul>
<li><span class="math inline">\(i_{ab}\)</span>表示电流参考方向为从<span class="math inline">\(a\)</span>到<span class="math inline">\(b\)</span></li>
</ul></li>
</ul></li>
</ul>
<h2 id="电压变量">电压变量</h2>
<ul>
<li>电压定义
<ul>
<li><span class="math inline">\(u(t)=\frac{dW}{dq}\)</span>，单位伏特（V）</li>
</ul></li>
<li>电压极性（方向）
<ul>
<li>实际电压
<ul>
<li>高电位为"+"极，低电位为"-"极，两点电位降低的方向是电压的方向</li>
</ul></li>
<li>参考极性
<ul>
<li>假设电压的"+"极和"-"极</li>
</ul></li>
<li>关联参考方向
<ul>
<li>选取的参考电流方向和参考电压方向一致，则称电压u和电流i对该元件是<strong>参考方向关联的</strong></li>
</ul></li>
<li>电路图的电压极性标注
<ul>
<li><span class="math inline">\(u_{ab}\)</span>表示电压<span class="math inline">\(a\)</span>端为"+"极，<span class="math inline">\(b\)</span>端为"-"极</li>
<li>若不标注电压参考方向，则认为与电流参考方向关联</li>
</ul></li>
<li>直流电流和直流电压
<ul>
<li>大小和方向都不随时间变化的电流和电压</li>
<li>I和U表示</li>
</ul></li>
</ul></li>
</ul>
<h2 id="功率">功率</h2>
<ul>
<li>定义
<ul>
<li>单位时间电场力所做的功，单位瓦（W）</li>
<li><span class="math inline">\(p(t)=\frac{dW(t)}{dt}\)</span></li>
</ul></li>
<li>与电压和电流的关系（以关联电路为例）
<ul>
<li><span class="math inline">\(p(t)=\frac{dW(t)}{dq}frac{dq}{dt}=u(t)i(t)\)</span>
<ul>
<li>若<span class="math inline">\(p&gt;0\)</span>则电路消耗（吸收）功率</li>
<li>若<span class="math inline">\(p&lt;0\)</span>则电路产生（发出）功率</li>
<li>因此上式为消耗功率公式，而<span class="math inline">\(p=-u(t)i(t)\)</span>为产生功率公式</li>
</ul></li>
</ul></li>
<li>额定功率
<ul>
<li>为了设备安全设置的功率限额</li>
</ul></li>
<li>能量计算
<ul>
<li><span class="math inline">\(w(t)=\int_{-\infty}^tp(\xi)d\xi=\int_{-\infty}^tu(\xi)i(\xi)d\xi\)</span></li>
<li><span class="math inline">\(u\)</span>和<span class="math inline">\(i\)</span>关联</li>
</ul></li>
</ul>
<h2 id="基尔霍夫定律">基尔霍夫定律</h2>
<h3 id="常见电路术语">常见电路术语</h3>
<ul>
<li>支路
<ul>
<li>电路中流过同一电流的几个元件串联的分支</li>
<li>支路数<span class="math inline">\(b\)</span></li>
</ul></li>
<li>节点
<ul>
<li>两条以上支路的汇集点</li>
<li>节点数<span class="math inline">\(n\)</span></li>
</ul></li>
<li>回路
<ul>
<li>由支路构成的电路中任意闭合路径</li>
<li>回路数<span class="math inline">\(l\)</span></li>
</ul></li>
<li>网孔
<ul>
<li>不包含任何支路的单一回路</li>
<li>网孔数<span class="math inline">\(m\)</span></li>
</ul></li>
</ul>
<h3 id="基尔霍夫电流定律kcl">基尔霍夫电流定律(KCL)</h3>
<ul>
<li>任一集中参数电路的任一节点，任一瞬间，流向某节点电流代数和恒等于零</li>
<li><span class="math inline">\(\sum\limits_{k=1}^ni_k(t)=0\)</span></li>
<li>说明
<ul>
<li>适用于节点、也适用于任何<strong>封闭曲面</strong></li>
<li>列线性方程求解，流出和等于流入和</li>
<li>注意方程变量的正负号和电流本身的正负号的区别</li>
<li>本质是电荷守恒</li>
</ul></li>
</ul>
<h3 id="基尔霍夫电压定律kvl">基尔霍夫电压定律(KVL)</h3>
<ul>
<li>环绕电路任意回路的所有电压代数和等于零</li>
<li><span class="math inline">\(\sum U=0\)</span></li>
<li>说明
<ul>
<li>电路中任意两点的电压和绕行路径无关</li>
<li>本质是能量守恒（电场环路定理）</li>
</ul></li>
</ul>
<h2 id="电阻元件">电阻元件</h2>
<ul>
<li>定义
<ul>
<li>若二端元件在任意时刻，其上电压和电流关系能用u-i平面上过原点的曲线表示，则为电阻元件</li>
<li>这种曲线关系成为伏安关系</li>
</ul></li>
<li>分类
<ul>
<li>线性时不变电阻
<ul>
<li>任意时刻直线关系</li>
</ul></li>
<li>线性时变电阻
<ul>
<li>直线斜率随着时间变化</li>
</ul></li>
<li>非线性电阻
<ul>
<li>非线性关系</li>
</ul></li>
</ul></li>
<li>欧姆定理(OL)
<ul>
<li>对于线性电阻，<span class="math inline">\(R=\frac{U}{I}\)</span></li>
<li>电导<span class="math inline">\(G=\frac{1}{R}\)</span>，单位西门子(S)</li>
</ul></li>
</ul>
<h2 id="独立电源理想电源">独立电源（理想电源）</h2>
<ul>
<li>独立电压源
<ul>
<li>提供电压保持定值（直流源）或给定的时间函数（交流源）的电源</li>
</ul></li>
<li>独立电流源
<ul>
<li>提供电流保持定值（直流源）或给定的时间函数（交流源）的电源</li>
</ul></li>
</ul>
<h2 id="非独立电源受控源">非独立电源（受控源）</h2>
<ul>
<li>提供电压或电流受到外部电路其他变量的控制</li>
<li>受控电压源
<ul>
<li>电压控制电压源(VCVS)</li>
<li>电流控制电压源(CCVS)</li>
</ul></li>
<li>受控电流源
<ul>
<li>电压控制电流源(VCCS)</li>
<li>电流控制电流源(CCCS)</li>
</ul></li>
<li>对受控源分析时，首先当作独立源处理并使用基尔霍夫定律</li>
</ul>
<h2 id="电路的数值极性表示法">电路的数值极性表示法</h2>
<ul>
<li>参考点
<ul>
<li>大地为参考点</li>
<li>公共节点为参考点</li>
</ul></li>
<li>节点电位和零电位点</li>
<li>电路的数值极性表示法
<ul>
<li>一种简化的电路画法，简化一端接地的电压源</li>
<li>以参考点为0电位，绘制出其他点的电位来代替电压的表示</li>
</ul></li>
</ul>
<h2 id="电路等效">电路等效</h2>
<ul>
<li>若两个二端电路无论外部端口接什么电路都有相同的电压和电流关系，则这两个二端电路等效
<ul>
<li>可以用欧姆定律算出等效电阻</li>
<li>等效电路直接可以相互代替，不改变<strong>外部</strong>电路效果</li>
</ul></li>
<li>电阻的串联等效
<ul>
<li>流过各电阻的是同一电流</li>
<li><span class="math inline">\(R_{eq}=\sum R_i\)</span></li>
</ul></li>
<li>电阻的并联等效
<ul>
<li>各电阻两端是同一电压</li>
<li><span class="math inline">\(G_{eq}=\sum G_i\)</span></li>
</ul></li>
<li>电阻的混联等效
<ul>
<li>同时考虑分析串并联情况</li>
</ul></li>
<li>电阻的<span class="math inline">\(Y-\Delta\)</span>等效
<ul>
<li><span class="math inline">\(Y\)</span>变<span class="math inline">\(\Delta\)</span>
<ul>
<li><span class="math inline">\(R_{12}=\frac{R_1R_2+R_2R_3+R_3R_1}{R_3}\)</span></li>
<li><span class="math inline">\(R_{23}=\frac{R_1R_2+R_2R_3+R_3R_1}{R_1}\)</span></li>
<li><span class="math inline">\(R_{13}=\frac{R_1R_2+R_2R_3+R_3R_1}{R_2}\)</span></li>
</ul></li>
<li><span class="math inline">\(\Delta\)</span>变<span class="math inline">\(Y\)</span>
<ul>
<li><span class="math inline">\(R_1=\frac{R_{12}R_{13}}{R_{12}+R_{23}+R_{13}}\)</span></li>
<li><span class="math inline">\(R_2=\frac{R_{12}R_{23}}{R_{12}+R_{23}+R_{13}}\)</span></li>
<li><span class="math inline">\(R_3=\frac{R_{23}R_{13}}{R_{12}+R_{23}+R_{13}}\)</span></li>
</ul></li>
</ul></li>
</ul>
<h2 id="含受控源电阻电路的等效">含受控源电阻电路的等效</h2>
<ul>
<li>使用基尔霍夫定律</li>
</ul>
<h2 id="独立源的串并联等效">独立源的串并联等效</h2>
<ul>
<li>使用基尔霍夫定律</li>
</ul>
<h2 id="实际电源和等效替换">实际电源和等效替换</h2>
<ul>
<li>考虑电源的内阻</li>
<li>外接滑动变阻器，测定伏安曲线</li>
<li>电压源的内阻和电源串联，电流源的内阻和电源并联
<ul>
<li>电压源模型和电流源模型可以相互等效</li>
<li>即电压<span class="math inline">\(U_s\)</span>串联一个<span class="math inline">\(R_s\)</span>等效于电流<span class="math inline">\(I_s\)</span>并联一个<span class="math inline">\(R_s\)</span>，且<span class="math inline">\(U_s=I_sR_s\)</span></li>
<li>个人理解等效的原因
<ul>
<li>电路是线性方程</li>
<li>短路和断路的情况外部电路等效，所以任何情况外部电路都等效</li>
</ul></li>
</ul></li>
</ul>
<h2 id="电源转移等效">电源转移等效</h2>
<ul>
<li>电压源转移等效
<ul>
<li>一个电压源等效于多个电压源</li>
<li>如下图 <img src="/2022/04/12/circuit-analysis-1/V_eq.png" class title="this is V_eq"></li>
</ul></li>
<li>电流源转移等效
<ul>
<li>一个电流源等效于多个电流源</li>
<li>如下图 <img src="/2022/04/12/circuit-analysis-1/I_eq.png" class title="this is I_eq"></li>
</ul></li>
</ul>
<h2 id="应用实例">应用实例</h2>
<ul>
<li>测量表量程拓展
<ul>
<li>电压表量程拓展</li>
<li>电流表量程拓展</li>
</ul></li>
<li>平衡电桥</li>
</ul>
]]></content>
      <categories>
        <category>电路分析</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 Counting</title>
    <url>/2021/03/09/combinatorics-1/</url>
    <content><![CDATA[<h2 id="double-counting-principle">Double Counting Principle</h2>
<h3 id="数学含义">数学含义</h3>
<p><span class="math inline">\(\sum_{i=1}^m\sum_{j=1}^n
A[i][j]=\sum_{j=1}^n\sum_{i=1}^m A[i][j]\)</span></p>
<p>###lemma定理： <span class="math inline">\(\sum\limits_{v\in
V}deg(v)=2|E|\)</span></p>
<p><strong>lemma定理的证明</strong>:定义一个矩阵，行是顶点，列是边，当一个顶点是边的端点，则矩阵对应位置为1。使用double
counting principle即可证得lemma定理。</p>
<p><strong>lemma定理的推论</strong>：奇度顶点有偶数个</p>
]]></content>
      <categories>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 程序设计基础知识</title>
    <url>/2022/02/24/cpp-1/</url>
    <content><![CDATA[<h2 id="程序的本质">程序的本质</h2>
<ul>
<li>程序 = 算法 + 数据结构</li>
<li>程序用<strong>数据类型</strong>描述数据，用<strong>流程控制语句</strong>实现算法</li>
</ul>
<h2 id="数据类型">数据类型</h2>
<ul>
<li>值集：规定数据类型包含的值和值结构</li>
<li>操作集：规定对值集的值的运算</li>
<li>区分数据类型便于检查合法性
<ul>
<li>静态类型语言：编译时检查数据类型</li>
<li>动态类型语言：运行时检查数据类型</li>
</ul></li>
</ul>
<h2 id="c数据类型">c++数据类型</h2>
<ul>
<li>基本数据类型
<ul>
<li>int、short、long</li>
<li>float、double</li>
<li>char</li>
<li>bool</li>
</ul></li>
<li>构造数据类型
<ul>
<li>枚举</li>
<li>数组</li>
<li>结构</li>
<li>联合</li>
<li>指针</li>
<li>引用</li>
</ul></li>
</ul>
<h2 id="流程控制语句">流程控制语句</h2>
<ul>
<li>顺序执行：表达式、空语句、复合语句</li>
<li>选择执行：if、switch</li>
<li>循环执行：for、while、do-while
<ul>
<li>计数循环</li>
<li>事件循环</li>
</ul></li>
<li>无条件转移：goto、break、continue</li>
</ul>
<h2 id="过程抽象">过程抽象</h2>
<ul>
<li>隐藏实现细节，使用者只需要知道相应的功能</li>
<li>函数调用实现过程抽象</li>
</ul>
<h2 id="程序在内存的分配">程序在内存的分配</h2>
<ul>
<li>静态数据区
<ul>
<li>全局变量、static局部变量、常量</li>
<li>默认初始化为0</li>
</ul></li>
<li>代码区</li>
<li>栈区
<ul>
<li>auto局部变量</li>
</ul></li>
<li>堆区
<ul>
<li>动态变量</li>
</ul></li>
</ul>
<h2 id="递归函数">递归函数</h2>
<ul>
<li>函数在函数体中直接或间接调用自己</li>
<li>递归条件、结束条件</li>
</ul>
<h2 id="指针和引用的区别">指针和引用的区别</h2>
<ul>
<li>引用直接访问实参（相当于别名），指针间接访问实参</li>
<li>引用只能访问实参，不能再引用其他变量，但指针可以通过修改地址访问实参以外的数据</li>
<li>可以使用引用实现的指针功能，尽量用引用实现</li>
<li>可以用const指针实现引用参数的功能
<ul>
<li>比如int * const p，此时p不可修改</li>
</ul></li>
<li>const int 表示不可修改的整型</li>
<li>const int* const p 表示不可修改的整型的指针，且该指针也不可修改</li>
<li>返回值也可以是引用类型，但是不应该返回局部变量的引用</li>
</ul>
<h2 id="数组">数组</h2>
<ul>
<li>静态表示</li>
<li>动态表示
<ul>
<li>动态数组</li>
<li>链表</li>
</ul></li>
</ul>
<h2 id="编译预处理命令">编译预处理命令</h2>
<ul>
<li>文件包含命令 #include
<ul>
<li>全局函数和全局变量的定义放在源文件，声明放在头文件</li>
</ul></li>
<li>宏定义 #define</li>
<li>条件编译命令
<ul>
<li>避免重复定义</li>
<li>基于多环境的程序编制（windows、unix、mac）</li>
<li>开发阶段的调试信息</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 数据抽象与封装</title>
    <url>/2022/02/26/cpp-2/</url>
    <content><![CDATA[<ul>
<li>数据抽象
<ul>
<li>数据的使用者只需要知道对数据的操作和操作间的关系，不需要知道数据具体形式</li>
</ul></li>
<li>数据封装
<ul>
<li>把数据和操作作为整体实现，使用者通过接口对数据操作，不需要知道数据具体形式</li>
</ul></li>
<li>对象
<ul>
<li>数据和操作的封装体</li>
</ul></li>
<li>类
<ul>
<li>描述了对象的特征（包含的数据和操作）</li>
</ul></li>
<li>继承
<ul>
<li>定义子类，把父类的特征先包含进来</li>
</ul></li>
<li>多态性（论域元素有多个解释）
<ul>
<li>一名多用
<ul>
<li>函数名重载</li>
<li>操作符重载</li>
</ul></li>
<li>类属性
<ul>
<li>类属函数：一个函数可以对多个类型的数据操作</li>
<li>类属类型：一个类型可以描述多种类型的数据</li>
</ul></li>
</ul></li>
<li>绑定：确定多态元素的使用是多态元素的哪一种
<ul>
<li>静态绑定
<ul>
<li>编译时决定</li>
</ul></li>
<li>动态绑定
<ul>
<li>运行时决定</li>
</ul></li>
</ul></li>
<li>this指针
<ul>
<li>类的成员函数的隐藏形参</li>
<li>类型为该类对象的指针</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【工作日志】 第一篇博客</title>
    <url>/2021/01/21/first%20blogs/</url>
    <content><![CDATA[<p>欢迎来到我的博客。</p>
<p>搭建博客的初衷，一方面是个人知识体系的总结与分享；其次是平时工作学习的记录和自我反馈。</p>
<p>文章中有任何问题需要交流，都可以在博客评论区留言。</p>
<p>本人邮箱：401986905@qq.com。</p>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>Working Logs</tag>
      </tags>
  </entry>
  <entry>
    <title>【工作日志】 毕设整理</title>
    <url>/2021/04/29/graduation-design-log/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误，请重试" data-whm="密码验证错误，请再试一试">
  <script id="hbeData" type="hbeData" data-hmacdigest="d3d3bf385de26ba3e2f23cde121c048c277e49075acd469dd33896084fa55fe7">ad43cd26d5b7026203cb76ab857976b3fae4deb41e0851382517be9714c0e852ef1b2c0f8346f8a7b875711cede7d228b2a0f636aaaab8a11543d09800398f9970c2738623e5ef4d8b3f9686d1e55e515ded58636bc80ed5c4903c07515468f9bd4ea527e250420451280f380c7d03d7d6d16ec041c49d338e8ee97f77d6859670b4562fe9dc42bd1eb896f99d11d17c0ffbf5fe73ae410dd474764c85c280d876ab175abe5813233a389de0c49c42f9b9a245fcff7645c1478cb32413936cdb9fad1273c34d1c5ae186d79d6f53c15533a41b4965aa2b1136c24c0f9aec8f9d96162cd2894e3051015cb1aa76036b8e1661c52ec5b9a072007a442059d5c8a87e1f3ef157cbaf70aa284ef5dd4cbfd8c80d657441a7b3af9bfa0d95fc881d63ad0f63b41bc00ed3202184eb100da1d5e924ec853db1c9c76cf4ad051403debf84d5e16e0a49e8c8bd9b7881e210059ab0746e2d4c427f5550af894ed3cefa536d0866ee1b2fb2004a93a679864ef3bcfc381d73c378583d4cdac5b84d9b08cf2f3bd1732cb3f633bf255855513908f34132b5d25ca4d5e5f5261e81190755a0ac0f888411899fbeabad53f4f68951aeb1a51f6590c82ef92e733e9af7f6a27f200fe30d1842b926955830bc4cb5bbab989b193c046e19b070e03dd0d2d783df25e375185067810155b9c0d22f18da7a1be931181b96868b2a81e28bd8392f0d0d6ac92efc929736c0206dcbed8a35a97e72660a4d40aae85c5432d7666aece21df53d9ed5fe14d8c23c8d11f13dd191efd58de3731ca80cceffcc8b690843bb107b63f645ade981e68b388a7bac01fdb300269a8222b807497bed882d2ef417e186b50666c60824b3bef88675b64eaea519ef3390fa694acb11531245db80759ff622cf15a106e0d6d2c51d0f481469a75aa84034af4da347250c173c22465e1673af6f2d3039105ae718d6d2d8cc65de052c525ab28ded5c5e6252db0b1d45f0f269838559d81f17e84f1517efa5057a6bc31b1f6f64ca338f94399a3772fa304b9bfd5073e377001ee2a71c0e3ef6cd267167f31be4abb8134cc819675694357f153a741935c1ef372bcb32c43df3cae6949a14caffc91d73731469f3b891590c6649ba1aed76be28623bcb777d216a7aa6d72e9d1a41a0f14c9d1a0f214c7ad0e9356133dc2320d91dc52ef6109d31b4e6a5ea122344a6d21fce1edf28aa3d8911984fe1afe61d89e86db11a3a44f8504569098fdf503735b1fdb396eba2fbfee3006354a83af5a5f2668f4f918efd6f5cdae0fc038abf2964be614f4f3f0a7556beac5fd885a27146e9d75fa140a4032904034aafd1059694542c570d35d1ed73e964a9e1fdcaabe66c6c075596269f0629c04c68daaf15e003c382061183e118cc99c712eaff77b52144014de1b86753b875ff55ae97b1f174ce0699b0e547eec293b4b394aa2adce4af4df73b7f70959ef74295ed2f47b40b9adb7145ceccb5e1cba64e16c3f7dc36ec75642b7c93151c92f90ec982320d9ad3acb6ed314f00ece737a743b3ede68d1eb7c96e097e3ac0ab8369cc7de89c6cfa272c2fdc254e7e7d6332730f9e9c24d8f6fdd53a586a8fdea65a66b6d592afb3ee761ff43612a100ac5d40d8275a7a1fa0b013e385e0f2d87125356589463b9ab2cbb9a3d7db1cb517192a74befc74fc607502ad3a7fdc140f6b6c1bb3fb1e0c8326deffa4cbb54f317af3979401b8185ba7b9eaa9adff0cef874ebda03547d4130ec91b52c5d9ae516c29455ba769837fa19a81fcf08482f24cddb248c87276702f65267faaf3ce40c36974c15e157287fdf7fc0ca883f2444b408d01457bcd3e6bececc8d1d9611556d77684a9af7dfdd0ff477b85c623ba940a90f9b5cc688331fd01b73f05f368ec81808e1a4d193aae753babdd261b5283612c77005e652fd6adebb72b4a1a089521bcfd6e07394a3d5c8f0a19b3264fcf5af8dc76081a270a2f589258dcde0c3d1455dab788fff71468611915e9c47d7001991fabd1d2b7cf2721085a574b7b45449068e24b506ffa7ea3295ce1caa833ccc5d5b081f310f53ba3c6ed20a421ed724cb37f1db38f3751181f137f127a69a7003109407a6edbe33eb6c544e567a26011a015837ebbb2587293665236c7d592ddafa7a33915c05a8c995e034358ef5020fb15affc29f0a66f58c51cd28558cc421215e8f10bd431681481b1a861c9b5481be177d7d67df67b44b2657ab667615ed18532c105bf566f32b407f921d15ca262b1dfb1f37bc3393963122ab9fe4324d1e3b44961e67e525a8f61ef4f23620a6993dc624c32324f795f6bc22b886468dd595783d14e36d9b7f87811c8968ca5ee42c2f6d42473d3d7fb0583f1847b51a47a0ad6df9dd7596b8f0556a127433f28c60ffbae117fd094bd22085b786c422d549a90cafc4da248de6e96bef7618463b8ed226ef96f17ddbafdc25226221d1bcb8e7f1ca1ef00bc257151aa14b1dd4e33fadbb5f08d6749f045c995e75eb6619661eae6059f47064fa76759d46d55b400d9c68fba805e924fd13d015ba83dbd3705803f94a9e9af5c36032db0ceaf7d7f53ca3e6d4f52f8b1a88a13b1fceeb07b9ba2f85df3777d39ed54b389dbc999f317bb8443057d14fe592cb31a9902f33d787807964569ad87723388c8c8d59334bffe619db7c85d42420fc4d788886c7bd81932eb8df71c7ba02c7fc9dd54778142cd3d923683b7cd8dc220e3679d49f27f2ac6ff6a6ea3a49167a050a1096c3a538782f85d7b41b4101643d62d0fd96cd506bcaf081d98810e2005508ca478e337e357ce832ef7662086d33c6df258002be9fe2c51daec2d650d8c36488c535d983e7566bde1f41e409a40b334f2a24e63edbf97a9737f892c56a93e700b363ccb6fd5c1f6a5b61e22d89511adfab02299ded51ed5f0bf8386d206a163cfeea9a0a1e895d9d080cdaed06c163c4b8f58f59f6f828533095f208bc89348e1d9b42708d0652f478ad0f797429d0f845c370b37de0ef0808f96ec36aa581a15c2408ad9464ffb6f7522d472976cb3a2c8f56ec929bb80df4c85d7f097117ace845b5d8f5b43c5f48daf3c1253ea970fc99eff8e75016ae5f899ede55024108c151a75862cde2a7a6a60e5c03c767a77f179e353fce25af28aad4f5a8e85bc888042f81f1ef075ff33df2833845340fea8ff283428611859eac92c898b5c3bcdcaa6b7069ef78eb8891df591f194671ffa732e1ccc4add1e06d74a2f8c82b2ad5939a7a6d204dca54548ea8f54f53e57a3d4c12970dd2a65db9b3312e497c8de77d362093ae97a127a60cc592ced38c5c56f06e4fccd59509c4e535af9e693de3d8ab840898df17473240b630d7506db3de9f657a7a22c757cc32108dcc1029d9d0374b4f4576970730d4199631117d632a41f4ae3eef212ba106735bf58f532ab869e7a0540794ab55af2cfe037de1103d80472b33d0cdc850e7e3aa478ef9179a4a03af1a4ad618655d0375ce3126541dbaa859a1a07367d7f6d459e6d921be4e57420b543f03aca4bdbdab7d41c3560e4b73b845c15968f59f399cc70c189ce4d3cfcc11c8ea70e70831ea21450cd8e898f3297e5f364e078a98fdc8bff08259bc24b2789f918cb2e420422f9abb9ce4e28cc658f8544721921d4e2fb6dad67d7c24db882400d2b96f2497f72e11a3229268a0d29f44489781cd4e2ba68deda3bdc657bb69ee74629d5e4cde6c8ef03cf4d7bcff386ad1f206c1e9f7153656c225b6c21c38ab45350408ee99f9195d3b4de5180dcdc34998cae78e5f83460225a084b7808e5f9527c6290c5e5ed9655620eec0525c793bc336fc9d25cbdbce9bb40ddcd7a16bb008f370664b1b59792d12d16dcfaeeaa7a148bd2c27be177bc998b1c848ccd4bf479ceca3a3ba96c63162bd1e63fae448f6240e499478733021f33fec0f431b42eab88ea32f21f7b295a7498223d82</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-xray">
      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">请输入访问密码查看非公开内容</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>Working Logs</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 图的基本概念</title>
    <url>/2021/03/08/graphIntroduction-1/</url>
    <content><![CDATA[<h2 id="基本概念">基本概念</h2>
<h3 id="图">图</h3>
<p>定义：一集元素和它们之间关系的二元组(V,E)，其中集合V称为<strong>顶点集</strong>，集合E是V中元素组成的某些无序对的集合，称为<strong>边集</strong>，顶点的数目<span class="math inline">\(|V|\)</span>称为图的<strong>阶</strong>，边的数目<span class="math inline">\(|E|\)</span>称为图的边数。</p>
<h3 id="图示">图示</h3>
<p>定义：点表示顶点，线段表示边，绘制出平面表示图。</p>
<h3 id="术语">术语</h3>
<ul>
<li><strong>关联</strong>： 点是边的端点，则点和边在图中相关联。</li>
<li><strong>相邻</strong>：
两个点有边相连，则点相邻；两个边至少有一个公共端点，则边相邻。</li>
<li><strong>环边</strong>： 两个端点都重合的两个边。</li>
<li><strong>重边</strong>：
给定顶点u、v。则图中连接u、v的两条或以上的边称为图中u、v的重边。</li>
<li><strong>简单图</strong>： 无环边也无重边的图为简单图。</li>
<li><strong>完全图</strong>： 所有点对之间都有边的图。</li>
<li><strong>空图</strong>： 边集为空的图。</li>
<li><strong>平凡图</strong>： 只有一个顶点的空图。</li>
<li><strong>零图</strong>：
边集和点集都为空的图。（顶点集为空则边集肯定为空）。</li>
<li><strong>顶点的度</strong>： 图中顶点关联的边数，记为<span class="math inline">\(d_G(v)\)</span>或<span class="math inline">\(d(v)\)</span>。</li>
<li><strong>最大度</strong>： <span class="math inline">\(\Delta(G)=max\{d(v)|v \in V(G)\}\)</span>。</li>
<li><strong>最小度</strong>： <span class="math inline">\(\delta(G)=min\{d(v)|v \in V(G)\}\)</span>。</li>
<li><strong>正则图</strong>：
各个顶点度都一样（设度为k）的图，称为k-正则图。</li>
<li><strong>图的补图</strong>：
补图和原图的点集相同；补图和原图的边集互为补集(设完全图的边集为全集)。</li>
</ul>
<h3 id="lemma定理">lemma定理</h3>
<p>图中各顶点度数之和是边数的两倍，即<span class="math inline">\(\sum\limits_{v \in V(G)}d(v)=2|E|\)</span></p>
<p><strong>推论：图中奇度顶点的数目一定是偶数。</strong></p>
<h3 id="子图">子图</h3>
<ul>
<li>子图：对于图G和H，若<span class="math inline">\(V(H)\subset
V(G)\)</span>且<span class="math inline">\(E(H)\subset
E(G)\)</span>，则H是G的子图，记为<span class="math inline">\(H\subset
G\)</span>。</li>
<li>生成子图：H是G的子图且<span class="math inline">\(V(H)=V(G)\)</span>，则H是G的生成子图。</li>
<li>点导出子图：<span class="math inline">\(\forall v_i,v_j \in
V&#39;=V(H),((v_i,v_j)\in E(G)\rightarrow(v_i,v_j)\in
E(H))\)</span>，记为<span class="math inline">\(H=G[V&#39;]\)</span>。</li>
<li>边导出子图： <span class="math inline">\(V(H)=\bigcup\limits_{e\in
E(H)}e\)</span>，记为<span class="math inline">\(H=G[E&#39;]\)</span>。</li>
<li><span class="math inline">\(G-V&#39;\)</span>：从<span class="math inline">\(G\)</span>中删除顶点<span class="math inline">\(V&#39;\)</span>，包括删除顶点的边，从而获得子图。</li>
<li><span class="math inline">\(G-E&#39;\)</span>：从<span class="math inline">\(G\)</span>中删除边<span class="math inline">\(E&#39;\)</span>，不删除顶点，从而获得子图。</li>
</ul>
<h3 id="路和圈">路和圈</h3>
<p>途径：图G中一个点边交替出现的序列 迹：边不重复的途径
路：顶点不重复的迹 闭途径：起点终点相同的途径 闭迹：边不重复的闭途径。
圈：中途点不重复的闭迹。</p>
<h3 id="长度">长度</h3>
<p>途径的长度：边的数量 最短路的长度：即距离，两个点之间长度最小的路
奇圈：长度为奇数的圈 偶圈：长度为偶数的圈</p>
<h3 id="二部图">二部图</h3>
<p>定义：若G的顶点可以划分为两个非空子集X和Y，且单个子集内部没有边，则G为二部图。记为<span class="math inline">\(G=(X\cup Y,E)\)</span>。</p>
<p><strong>完全二部图</strong>：若二部图G的两个子集为X和Y，且X的每个顶点和Y的每个顶点之间都有边，则G为完全二部图。</p>
<p>定理:一个图是二部图当且仅当它不含奇圈。</p>
<h3 id="连通性">连通性</h3>
<ul>
<li>点连通：两个点间有路相同。</li>
<li>连通图：任意两顶点连通。</li>
<li>图的连通分支：把图的顶点划分为一系列非空子集，使得两顶点在同一个子集中当且仅当它们连通。通过这些子集得到的一系列点导出子图就是原图的一个个连通分支。连通分支的个数为连通分支数。</li>
<li>点的离心率e(v)：点v到图上距离该点最远的点的距离</li>
<li>中心：离心率最小的点</li>
<li>半径rad(G)：离心率的最小值</li>
<li>直径diam(G)：离心率的最大值</li>
</ul>
<p>定理：若图G(V,E)连通，则<span class="math inline">\(|E|\geq
|V|-1\)</span></p>
<h3 id="图的同构">图的同构</h3>
<p>定义：在图<span class="math inline">\(G=(V(G),E(G))\)</span>和图<span class="math inline">\(H=(V(H),E(H))\)</span>中，存在一一映射：<span class="math inline">\(\alpha:V(G)\rightarrow V(H)\)</span>和<span class="math inline">\(\beta: E(G)\rightarrow
E(H)\)</span>,使得对任意<span class="math inline">\(e=(u,v)\in
E(G)\)</span>，都有<span class="math inline">\((\alpha(u),\alpha(v))\in
E(H)\)</span>，且<span class="math inline">\(\beta(e)=(\alpha(u),\alpha(v))\)</span>，则G和H同构，记为<span class="math inline">\(G\cong H\)</span></p>
<p>注：同构关系是一个等价关系（自反、对称、传递）。同构的判断属于NP问题。</p>
<h3 id="图的运算">图的运算</h3>
<p>G的补图：<span class="math inline">\(\overline{G}=\langle
V(G),\{(x,y)\notin E(G)\}\rangle\)</span></p>
<p>G和H的并：<span class="math inline">\(G \cup H=\langle V(G)\cup
V(H),E(G)\cup E(H)\rangle\)</span></p>
<p>G和H的和：仅当<span class="math inline">\(V(G) \cap
V(H)\)</span>交集为空时，<span class="math inline">\(G+H=\langle
V(G)\cup V(H),E(G)\cup E(H)\rangle\)</span></p>
<p>G和H的联：<span class="math inline">\(V(G)\vee
V(H)\)</span>是在和的基础上连接<span class="math inline">\(V(G)\)</span>和<span class="math inline">\(V(H)\)</span>中的一些点对，即添加一些边</p>
<p>G和H的对称差：当<span class="math inline">\(V(G)=V(H)=V\)</span>，<span class="math inline">\(G\oplus H=\langle V,(E(G)\cup
E(H))\setminus(E(G)\cap E(H))\rangle\)</span></p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 可平面图的判断</title>
    <url>/2021/05/06/graphIntroduction-10/</url>
    <content><![CDATA[<h2 id="可平面图的判断">可平面图的判断</h2>
<h3 id="剖分">剖分</h3>
<ul>
<li>剖分：在一条边上加入一个新的顶点，将其分为两条边</li>
<li>Kuratowski子图：图中的，是<span class="math inline">\(K_5\)</span>或<span class="math inline">\(K_{3,3}\)</span>剖分的子图</li>
<li>Kuratowski定理：可平面图的充要条件是没有kuratowski子图</li>
<li>Wagner定理：可平面图的充要条件是没有可以收缩到<span class="math inline">\(K_5\)</span>或<span class="math inline">\(K_{3,3}\)</span>的子图</li>
</ul>
<h2 id="dmp算法">DMP算法</h2>
<h3 id="h-fragment">H-fragment</h3>
<p>图<span class="math inline">\(G\)</span>的<span class="math inline">\(H-fragment\)</span>：给定<span class="math inline">\(G\)</span>的子图<span class="math inline">\(H\)</span>，<span class="math inline">\(G\)</span>的<span class="math inline">\(H-fragment\)</span>是<span class="math inline">\(G\)</span>中去掉<span class="math inline">\(H\)</span>后剩余的“连通分支”，包括：</p>
<ul>
<li>一条不在<span class="math inline">\(H\)</span>中但两个端点都在<span class="math inline">\(H\)</span>中的边及其两端</li>
<li><span class="math inline">\(G-V[H]\)</span>的一个连通分支加上它连到H的边及其端点</li>
</ul>
<h3 id="基本思路">基本思路</h3>
<ul>
<li>迭代地嵌入当前子图的fragment，直到G全部被嵌入（可平面）或者某个fragment无法嵌入（不可平面）</li>
<li>嵌入一个fragment可能难以操作，但总能嵌入其中的一条路</li>
<li>图<span class="math inline">\(G\)</span>是可平面的当且仅当<span class="math inline">\(G\)</span>的每个块都是可平面的</li>
</ul>
<h3 id="dmp算法流程">DMP算法流程</h3>
<ul>
<li>如果有多个块，只需要检测每个块（2-连通图）是否可平面即可</li>
<li>对于每个2-连通图<span class="math inline">\(G\)</span>，从中任取一个圈<span class="math inline">\(G_0\)</span>，平面嵌入</li>
<li>迭代如下
<ul>
<li>找到所有<span class="math inline">\(G_i-fragment\)</span></li>
<li>对于每个<span class="math inline">\(G_i-fragment\)</span>（称作<span class="math inline">\(B\)</span>），在<span class="math inline">\(G_i\)</span>中找到所有包含所有<span class="math inline">\(B\)</span>的附着点的面（称为<span class="math inline">\(F(B)\)</span>）。如果某个<span class="math inline">\(F(B)\)</span>为空，则<span class="math inline">\(G\)</span>不可平面；如果某个<span class="math inline">\(|F(B)|=1\)</span> 则选中这个<span class="math inline">\(B\)</span>；如果每个<span class="math inline">\(|F(B)&gt;1|\)</span>，则任选一个<span class="math inline">\(B\)</span></li>
<li>从选中的<span class="math inline">\(B\)</span>中任选一条连接两个附着点的路<span class="math inline">\(P\)</span>，将<span class="math inline">\(P\)</span>嵌入到<span class="math inline">\(F(B)\)</span>的一个面中。</li>
<li>将结果记作<span class="math inline">\(G_{i+1}\)</span></li>
<li>如果<span class="math inline">\(G_{i+1}=G\)</span>则<span class="math inline">\(G\)</span>可平面，否则继续迭代。</li>
</ul></li>
</ul>
<h3 id="复杂度">复杂度</h3>
<ul>
<li>块分解：<span class="math inline">\(O(v)\)</span>，基于DFS</li>
<li>找初始的圈：<span class="math inline">\(O(v)\)</span></li>
<li>迭代轮数:
<ul>
<li>简单平面图满足<span class="math inline">\(\epsilon\leq
3v-6\)</span></li>
<li><span class="math inline">\(\varphi=\epsilon-v+1\leq 2v-5\in
O(v)\)</span>，因此每轮迭代新增一个面</li>
</ul></li>
<li>每轮的迭代时间：<span class="math inline">\(O(v)\)</span></li>
</ul>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 边染色、点染色和面染色</title>
    <url>/2021/05/16/graphIntroduction-11/</url>
    <content><![CDATA[<h2 id="边染色">边染色</h2>
<h3 id="相关概念">相关概念</h3>
<ul>
<li>边<span class="math inline">\(k\)</span>染色
<ul>
<li><span class="math inline">\(E(G)\rightarrow
\{1,2,\cdots,k\}\)</span></li>
<li><span class="math inline">\(E_i\)</span>：色为<span class="math inline">\(i\)</span>的边集</li>
</ul></li>
<li>边正常<span class="math inline">\(k\)</span>染色：相邻的边不同色</li>
<li>边<span class="math inline">\(k\)</span>色可染的：
能找到一个边正常<span class="math inline">\(k\)</span>染色</li>
<li>边色数：
<ul>
<li>边<span class="math inline">\(k\)</span>色可染的最小<span class="math inline">\(k\)</span></li>
<li>记作<span class="math inline">\(\chi&#39;\)</span></li>
</ul></li>
<li>只考虑无环图，可以有重边</li>
</ul>
<h3 id="边色数的性质和意义">边色数的性质和意义</h3>
<ul>
<li><span class="math inline">\(\Delta\leq \chi&#39; \leq
\epsilon\)</span></li>
<li><span class="math inline">\(\chi&#39;\)</span>和匹配的联系：
<ul>
<li><span class="math inline">\(E(G)\)</span>至少要被划分成<span class="math inline">\(\chi&#39;(G)\)</span>个匹配</li>
<li>如果<span class="math inline">\(E(G)\)</span>能被划分为<span class="math inline">\(m\)</span>个匹配，则<span class="math inline">\(\chi&#39;(G)\leq m\)</span></li>
</ul></li>
</ul>
<h3 id="最佳边k染色">最佳边k染色</h3>
<ul>
<li>对于边<span class="math inline">\(k\)</span>染色<span class="math inline">\(c\)</span>，用<span class="math inline">\(c(v)\)</span>表示顶点<span class="math inline">\(v\)</span>出现的色数</li>
<li>若<span class="math inline">\(\sum c&#39;(v)&gt;\sum
c(v)\)</span>，则称<span class="math inline">\(c&#39;\)</span>是<span class="math inline">\(c\)</span>的一个改进</li>
<li>不能改进的边<span class="math inline">\(k\)</span>染色称作最佳边<span class="math inline">\(k\)</span>染色（未必是边正常<span class="math inline">\(k\)</span>染色）</li>
</ul>
<h3 id="vizing定理">Vizing定理</h3>
<p>对于简单图<span class="math inline">\(G\)</span>，<span class="math inline">\(\Delta\leq \chi&#39;\leq \Delta+1\)</span></p>
<h3 id="简单图的分类">简单图的分类</h3>
<ul>
<li>第一类图：<span class="math inline">\(\chi&#39;=\Delta\)</span></li>
<li>第二类图：<span class="math inline">\(\chi&#39;=\Delta+1\)</span></li>
</ul>
<h3 id="二部图的边色数">二部图的边色数</h3>
<ul>
<li>对于二部图<span class="math inline">\(G\)</span>，<span class="math inline">\(\chi&#39;=\Delta\)</span></li>
<li>二部图的边正常<span class="math inline">\(\Delta\)</span>染色算法
<ul>
<li><span class="math inline">\(k\)</span>正则二部图有<span class="math inline">\(k\)</span>个边不重的完美匹配</li>
<li>算法思路
<ul>
<li>将二部图扩展成<span class="math inline">\(\Delta\)</span>正则二部图</li>
<li>反复的求最大匹配，即完美匹配，染色后从图中删去</li>
<li>忽略添加的顶点和边</li>
</ul></li>
<li>二部图边染色复杂度：目前最快的算法是<span class="math inline">\(O(mlog\Delta)\)</span>；</li>
<li>一般简单图的边染色：多项式时间内可以做到<span class="math inline">\(\Delta+1\)</span>染色</li>
</ul></li>
</ul>
<h2 id="点染色">点染色</h2>
<h3 id="相关概念-1">相关概念</h3>
<ul>
<li><span class="math inline">\(k\)</span>染色
<ul>
<li><span class="math inline">\(V(G)\rightarrow
\{1,2,\cdots,k\}\)</span></li>
<li><span class="math inline">\(V_i\)</span>：色为<span class="math inline">\(i\)</span>的顶点集</li>
</ul></li>
<li>正常<span class="math inline">\(k\)</span>染色：相邻的顶点不同色</li>
<li><span class="math inline">\(k\)</span>色可染的： 能找到一个正常<span class="math inline">\(k\)</span>染色</li>
<li>色数：
<ul>
<li><span class="math inline">\(k\)</span>色可染的最小<span class="math inline">\(k\)</span></li>
<li>记作<span class="math inline">\(\chi\)</span></li>
</ul></li>
</ul>
<h3 id="色数的性质和意义">色数的性质和意义</h3>
<ul>
<li><span class="math inline">\(\chi \leq v\)</span></li>
<li><span class="math inline">\(\chi\)</span>和点独立集的联系：
<ul>
<li><span class="math inline">\(v(G)\)</span>至少要被划分成<span class="math inline">\(\chi(G)\)</span>个点独立集</li>
<li>如果<span class="math inline">\(V(G)\)</span>能被划分为<span class="math inline">\(m\)</span>个点独立集，则<span class="math inline">\(\chi(G)\leq m\)</span></li>
</ul></li>
</ul>
<h3 id="色临界图及其性质">色临界图及其性质</h3>
<ul>
<li><span class="math inline">\(k\)</span>临界的：<span class="math inline">\(\chi=k\)</span>的极小图</li>
<li><span class="math inline">\(k\)</span>色图一定包含一个<span class="math inline">\(k\)</span>临界子图</li>
<li>色临界图一定是连通的简单图</li>
<li>对于<span class="math inline">\(k\)</span>临界图<span class="math inline">\(G\)</span>中的任一顶点<span class="math inline">\(v\)</span>，能找到一个正常<span class="math inline">\(k\)</span>染色使得<span class="math inline">\(v\)</span>的色独一无二且与其他<span class="math inline">\(k-1\)</span>种色都相邻</li>
<li><span class="math inline">\(k\)</span>临界图满足<span class="math inline">\(\Delta\geq k-1\)</span></li>
<li>对于<span class="math inline">\(k\)</span>临界图<span class="math inline">\(G\)</span>中的任一边<span class="math inline">\(e\)</span>，<span class="math inline">\(G-e\)</span>的任一正常<span class="math inline">\(k-1\)</span>染色都使得<span class="math inline">\(e\)</span>的两个端点同色</li>
<li>色临界图的点割集不是团（两两相邻的顶点子集）</li>
<li>每个色临界图都是块（无割点的连通图）</li>
<li>色临界图若有2-点割集<span class="math inline">\(\{u,v\}\)</span>，则<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>不相邻</li>
</ul>
<h3 id="色数的界和正常染色算法">色数的界和正常染色算法</h3>
<h4 id="贪心算法一">贪心算法一</h4>
<ul>
<li>假设可以染的色为<span class="math inline">\(1,2,\cdots\)</span></li>
<li>对于顶点<span class="math inline">\(v_1,v_2,\cdots,v_n\)</span>按任意序染色，总选择不冲突的下标最小的色</li>
<li>最多需要<span class="math inline">\(\Delta+1\)</span>种颜色</li>
<li><span class="math inline">\(\chi\leq \Delta+1\)</span></li>
</ul>
<h4 id="贪心算法二">贪心算法二</h4>
<ul>
<li>假设可以染的色为<span class="math inline">\(1,2,\cdots\)</span></li>
<li>对于顶点<span class="math inline">\(v_1,v_2,\cdots,v_n\)</span>按度降序染色，总选择不冲突的下标最小的色</li>
<li><span class="math inline">\(\chi\leq
\max_i\min\{d(v_i)+1,i\}=1+\max_i\min\{d(v_i),i-1\}\leq
\Delta+1\)</span></li>
<li>初期<span class="math inline">\(i\)</span>较小，后期<span class="math inline">\(d(v_i)\)</span>较小，因此总体较小</li>
</ul>
<h4 id="定理">定理</h4>
<p>除完全图和奇圈以外的连通简单图<span class="math inline">\(G\)</span>满足<span class="math inline">\(\chi\leq
\Delta\)</span></p>
<h4 id="其他">其他</h4>
<ul>
<li>对于<span class="math inline">\(k&gt;2\)</span>，判断一个图是否<span class="math inline">\(k\)</span>色可染是NP-完全问题</li>
<li>一般意义上的求色数更是<span class="math inline">\(NP-hard\)</span>问题</li>
<li>找到一个近似比为常数的近似算法同样困难</li>
</ul>
<h2 id="面染色">面染色</h2>
<h3 id="相关概念-2">相关概念</h3>
<ul>
<li>面<span class="math inline">\(k\)</span>染色</li>
<li>面正常<span class="math inline">\(k\)</span>染色：边界有公共边的面不同色</li>
<li>面<span class="math inline">\(k\)</span>色可染的</li>
<li>面色数</li>
</ul>
<h3 id="五色定理">五色定理</h3>
<ul>
<li>定理：对于任何平面图<span class="math inline">\(G\)</span>,<span class="math inline">\(\chi(G)\leq 5\)</span></li>
<li>推论：由对偶图都是平面图，故平面图一定是面5色可染的</li>
</ul>
<h3 id="四色猜想">四色猜想</h3>
<ul>
<li>猜想：对任何平面图<span class="math inline">\(G\)</span>，<span class="math inline">\(\chi(G)\leq 4\)</span></li>
<li>三角剖分平面图：每个面的度数都为3的简单平面图</li>
<li>构形：每个内部面的度数都为3的简单平面图</li>
<li>极小反例：
<ul>
<li><span class="math inline">\(\chi&gt;4\)</span>的简单平面图中阶最小的一个</li>
<li>不失一般性，设其为三角剖分平面图，如果不是也可以加边使之成为三角剖分平面图，且还是极小反例。</li>
</ul></li>
<li>不可免集：构形的集合，任何一个极小反例至少包含其中一个构形</li>
<li>如果找到一个不可免集，其中每个构形都不可能出现在极小反例中，称作可约的，则出现了矛盾，因此极小反例不存在，四色猜想得证。</li>
</ul>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 有向图</title>
    <url>/2021/05/27/graphIntroduction-12/</url>
    <content><![CDATA[<h2 id="有序对">有序对</h2>
<ul>
<li>无序对：
<ul>
<li>含有1个或2个元素的集合</li>
<li><span class="math inline">\((v_1,v_2)=\{v_1,v_2\}\)</span>，<span class="math inline">\((v_2,v_2)={v_2}\)</span></li>
</ul></li>
<li>有序对：<span class="math inline">\(\langle a_1,b_1\rangle=\langle
a_2,b_2\rangle\)</span> 当且仅当 <span class="math inline">\(a_1=a_2\)</span> 且 <span class="math inline">\(b_1=b_2\)</span></li>
<li>有序对的集合表示：<span class="math inline">\(\langle
a,b\rangle=\{\{a\},\{a,b\}\}\)</span></li>
</ul>
<h2 id="有向图和弧">有向图和弧</h2>
<ul>
<li><span class="math inline">\(G=\langle V,A \rangle\)</span>
<ul>
<li><span class="math inline">\(V\)</span>：顶点集</li>
<li><span class="math inline">\(A\)</span>：弧集，一个有向对的集合。弧又称为有向边</li>
</ul></li>
<li>一些术语
<ul>
<li>弧的尾</li>
<li>弧的头</li>
<li>环弧：头尾相同的弧</li>
<li>并行弧：具有相同头的相同尾的弧</li>
<li>简单有向图：无环弧，无并行弧</li>
<li>反向弧：简单有向图中头尾相反的弧</li>
</ul></li>
</ul>
<h2 id="度和邻点">度和邻点</h2>
<ul>
<li>出度：<span class="math inline">\(d^+(v)\)</span></li>
<li>入度：<span class="math inline">\(d^-(v)\)</span></li>
<li>最小出度：<span class="math inline">\(\delta^+\)</span></li>
<li>最小入度：<span class="math inline">\(\delta^-\)</span></li>
<li>最大出度：<span class="math inline">\(\Delta^+\)</span></li>
<li>最大入度：<span class="math inline">\(\Delta^-\)</span></li>
<li>出邻点和入邻点</li>
</ul>
<h2 id="定理">定理</h2>
<p>对任何有向图<span class="math inline">\(G\)</span>，都有<span class="math inline">\(\sum\limits_{v\in V(G)}d^+(v)=\sum\limits_{v\in
V(G)}d^-(v)=\sum\limits_{v\in V(G)}\frac{d(v)}{2}=\epsilon\)</span></p>
<h2 id="途径迹路圈">途径、迹、路、圈</h2>
<ul>
<li>有向途径
<ul>
<li>顶点和弧交替出现的序列</li>
<li>与弧的方向一致</li>
</ul></li>
<li>有向迹：弧不重复出现</li>
<li>有向路：顶点不重复出现</li>
<li>有向圈：起点和终点相同</li>
</ul>
<h2 id="底图和定向">底图和定向</h2>
<ul>
<li>底图：有向图 <span class="math inline">\(\rightarrow\)</span>
无向图</li>
<li>定向：无向图 <span class="math inline">\(\rightarrow\)</span> 有向图
<ul>
<li>不唯一</li>
<li>竞赛图：完全图的定向</li>
</ul></li>
</ul>
<h2 id="连通">连通</h2>
<ul>
<li>弱连通：底图是连通的</li>
<li>强连通：任取顶点u和v，存在从u到v的有向路</li>
<li>强连通分支：极大强连通子图</li>
<li>强连通分支之间不存在公共顶点</li>
<li>强连通分支图不存在有向圈</li>
</ul>
<h2 id="强连通的充要条件">强连通的充要条件</h2>
<p><span class="math inline">\(G\)</span>是强连通有向图的充要条件是<span class="math inline">\(G\)</span>的所有顶点在一条有向闭途径上</p>
<h2 id="强连通定向">强连通定向</h2>
<p>无向图<span class="math inline">\(G\)</span>可定向成强连通图的充分必要条件为：<span class="math inline">\(G\)</span>连通且无割边。</p>
<h2 id="竞赛图">竞赛图</h2>
<ul>
<li>王
<ul>
<li>到其他任何顶点都有长度不超过2的有向路</li>
<li>不一定唯一</li>
</ul></li>
<li>定理：竞赛图中出度最大的顶点一定是王</li>
<li>竞赛图中一个顶点<span class="math inline">\(v\)</span>是唯一的王当且仅当<span class="math inline">\(v\)</span>的出度是<span class="math inline">\(v-1\)</span></li>
</ul>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 网络流</title>
    <url>/2021/05/27/graphIntroduction-13/</url>
    <content><![CDATA[<h2 id="网络的基本概念">网络的基本概念</h2>
<ul>
<li>网络：弧带权的有向图
<ul>
<li>弧的权又称弧的容量，记作<span class="math inline">\(c(a)\geq
0\)</span></li>
<li>只讨论简单的有向图（无环弧、无并行弧）</li>
<li>有一个特殊的源点，记作<span class="math inline">\(s\)</span></li>
<li>有一个特殊的汇点，记作<span class="math inline">\(t\)</span></li>
</ul></li>
<li>流：
<ul>
<li><span class="math inline">\(f\)</span>：定义在弧上的非负实值函数</li>
<li><span class="math inline">\(f^+(v)\)</span>：顶点<span class="math inline">\(v\)</span>的所有出弧的流量和</li>
<li><span class="math inline">\(f^-(v)\)</span>：顶点<span class="math inline">\(v\)</span>的所有入弧的流量和</li>
</ul></li>
<li>可行流：
<ul>
<li>容量约束：<span class="math inline">\(\forall a\in A(G),0\leq
f(a)\leq c(a)\)</span></li>
<li>守恒约束：<span class="math inline">\(\forall v\in V(G)\setminus
\{s,t\},f^+(v)=f^-(v)\)</span></li>
</ul></li>
<li>对于任意网络，可行流总是存在的，比如：零值流</li>
<li>流量：
<ul>
<li><span class="math inline">\(f^-(t)-f^+(t)\)</span></li>
</ul></li>
<li>必有<span class="math inline">\(f^-(t)-f^+(t)=f^+(s)-f^-(s)\)</span></li>
<li>最大流：流量最大的可行流</li>
<li>f增广路
<ul>
<li>底图中的一条s-t路</li>
<li>经过的每条正向弧<span class="math inline">\(a\in
A(G):f(a)&lt;c(a)\)</span></li>
<li>经过的每条反向弧<span class="math inline">\(a\in
A(G):f(a)&gt;0\)</span></li>
</ul></li>
<li>增广路的“可增量”</li>
</ul>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 图的连通性</title>
    <url>/2021/03/11/graphIntroduction-2/</url>
    <content><![CDATA[<h2 id="割点和割边">割点和割边</h2>
<h3 id="割点定义">割点定义</h3>
<p><span class="math inline">\(v \in V(G):w(G-v)&gt;w(G)\)</span></p>
<h3 id="割点的一个定理">割点的一个定理</h3>
<p>如果点v是简单图G的一个割点，则边集<span class="math inline">\(E[G]\)</span>可划分为两个非空子集<span class="math inline">\(E_1\)</span>和<span class="math inline">\(E_2\)</span>，使得边导出子图<span class="math inline">\(G[E_1]\)</span>和<span class="math inline">\(G[E_2]\)</span>恰好有一个公共顶点v。</p>
<h3 id="连通图中割点的等价定义">连通图中割点的等价定义</h3>
<ul>
<li>v是G的割点</li>
<li>G-v不连通</li>
<li>存在<span class="math inline">\(V(G)\setminus\{v\}\)</span>的一个划分：<span class="math inline">\(V(G)\setminus\{v\}=U\cup W\)</span>,<span class="math inline">\(U\cap W=\emptyset\)</span>,使得对<span class="math inline">\(\forall u\in U\)</span>和<span class="math inline">\(\forall w\in W\)</span>,v在每条u-w路上</li>
<li>存在<span class="math inline">\(u,w\in
V(G)\)</span>,使得u,w异于v，且v在每条u-w路上</li>
</ul>
<h3 id="割边定义">割边定义</h3>
<p><span class="math inline">\(e \in E(G):w(G-e)&gt;w(G)\)</span></p>
<h3 id="割边的等价定义">割边的等价定义</h3>
<ul>
<li>e是G的割边</li>
<li>e不在G的任何圈中</li>
</ul>
<h3 id="连通图中割边的等价定义">连通图中割边的等价定义</h3>
<ul>
<li>e是G的割边</li>
<li>存在<span class="math inline">\(V(G)\)</span>的一个划分：<span class="math inline">\(V(G)=U\cup W\)</span>,<span class="math inline">\(U\cap W=\emptyset\)</span>,使得对<span class="math inline">\(\forall u\in U\)</span>和<span class="math inline">\(\forall w\in W\)</span>,e在每条u-w路上</li>
<li>存在<span class="math inline">\(u,v\in
V(G)\)</span>,使得e在每条u-v路上</li>
</ul>
<h2 id="连通度和边连通度">连通度和边连通度</h2>
<h3 id="点割集">点割集</h3>
<p><span class="math inline">\(S \subset V(G): w(G-S)&gt;1\)</span></p>
<h3 id="极小点割集">极小点割集</h3>
<p>任何真子集都不是点割集</p>
<h3 id="最小点割集">最小点割集</h3>
<p>图中含顶点数最少的点割集</p>
<h3 id="连通度">连通度</h3>
<ul>
<li>G不是完全图：最小点割集的势</li>
<li>G是完全图：v-1</li>
<li>G不连通：0</li>
<li>G是零图或平凡图：不讨论</li>
</ul>
<h3 id="连通度性质kappagkappa">连通度性质（<span class="math inline">\(\kappa(G)=\kappa\)</span>）</h3>
<ul>
<li>没有势为k-1或更小的点割集</li>
<li>任意去掉k-1或更少的点，仍然连通</li>
</ul>
<h3 id="k-连通">k-连通</h3>
<p>即<span class="math inline">\(\kappa(G)\geq k\)</span></p>
<h3 id="边割集">边割集</h3>
<p><span class="math inline">\(S \subset E(G): w(G-S)&gt;1\)</span></p>
<h3 id="极小边割集">极小边割集</h3>
<p>任何真子集都不是边割集</p>
<h3 id="最小边割集">最小边割集</h3>
<p>图中含边数最少的边割集</p>
<h3 id="边连通度">边连通度</h3>
<ul>
<li>最小边割集的势</li>
<li>G不连通：0</li>
<li>G是零图或平凡图：不讨论</li>
</ul>
<h3 id="连通度性质kappagk">连通度性质（<span class="math inline">\(\kappa&#39;(G)=k\)</span>）</h3>
<ul>
<li>没有势为k-1或更小的边割集</li>
<li>任意去掉k-1或更少条边，仍然连通</li>
</ul>
<h3 id="k-边连通">k-边连通</h3>
<p>即<span class="math inline">\(\kappa&#39;(G)\geq k\)</span></p>
<h3 id="一个重要的定理">一个重要的定理</h3>
<p><span class="math inline">\(\kappa(G)\leq \kappa&#39;(G)\leq
\delta(G)\)</span></p>
<h3 id="kappag的一个上界"><span class="math inline">\(\kappa(G)\)</span>的一个上界</h3>
<p><span class="math inline">\(2\epsilon=\sum\limits_{u\in
V(G)}d(u)\geq\delta(G)v\Rightarrow\delta(G)\leq
\frac{2\epsilon}{v}\Rightarrow\kappa(G)\leq \delta(G)\leq
\frac{2\epsilon}{v}\Rightarrow\kappa(G)\)</span>的一个上界<span class="math inline">\(\lfloor\frac{2\epsilon}{v}\rfloor\)</span></p>
<h3 id="kappagkappag的一个充分条件"><span class="math inline">\(\kappa(G)=\kappa&#39;(G)\)</span>的一个充分条件</h3>
<p>G是3-正则图</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 k-连通图</title>
    <url>/2021/03/18/graphIntroduction-3/</url>
    <content><![CDATA[<h2 id="连通图的性质">2-连通图的性质</h2>
<h3 id="块">块</h3>
<p>G是块：G是无割点的连通图 H是G的块：H是G中极大无割点连通子图</p>
<h3 id="块的等价定义g是vgeq-3的连通图">块的等价定义(G是<span class="math inline">\(v\geq 3\)</span>的连通图)</h3>
<ul>
<li>G是2-连通的(块)</li>
<li>G的任二顶点共圈</li>
<li>G的任一顶点与任一边共圈</li>
<li>G的任二边共圈</li>
<li>对 <span class="math inline">\(\forall u,v\in V(G)\)</span> 及 <span class="math inline">\(\forall e \in E(G)\)</span> 存在 <span class="math inline">\((u,v)\)</span> 路含有边 <span class="math inline">\(e\)</span></li>
<li>对 <span class="math inline">\(\forall u,v,w\in V(G)\)</span>，存在
<span class="math inline">\((u,v)\)</span> 路含有顶点 <span class="math inline">\(w\)</span></li>
<li>对 <span class="math inline">\(\forall u,v,w\in V(G)\)</span>，存在
<span class="math inline">\((u,v)\)</span> 路不含有顶点 <span class="math inline">\(w\)</span></li>
</ul>
<h3 id="块的一些其他性质">块的一些其他性质</h3>
<ul>
<li>两个块最多只有一个公共顶点</li>
<li>两个块没有公共边</li>
<li>块是对图的边集的一种划分，等价关系是共圈</li>
<li>割点<span class="math inline">\(\Leftrightarrow\)</span>块的交点</li>
<li>块-割点图</li>
</ul>
<h3 id="块的求法">块的求法</h3>
<p>john Hopcroft和Robert Tarjan提出的经典算法 + 思想：基于一次DFS +
时间复杂度：线性 + 详细内容：可参考《算法导论》</p>
<h2 id="menger定理">Menger定理</h2>
<h3 id="分离集">分离集</h3>
<ul>
<li>x-y分离集(x-y cut)：<span class="math inline">\(S \subseteq
V(G)\setminus\{x,y\}:G-S\)</span>中没有<span class="math inline">\(x-y\)</span>路</li>
<li>最小x-y分离集(minmum x-y cut)：势最小的x-y分离集</li>
<li>x-y分离数：最小x-y分离集的势，记为s(x,y)</li>
<li>两两内部无公共顶点的x-y路的最大条数：记作r(x,y)</li>
</ul>
<h3 id="menger定理内容">Menger定理内容</h3>
<p>设x,y是图G的两个不相邻的顶点，则s(x,y)=r(x,y)</p>
<h3 id="menger定理推论">Menger定理推论</h3>
<p><span class="math inline">\(v\geq k+1\)</span>的图G是k-连通图</p>
<p><span class="math inline">\(\Leftrightarrow\)</span>
G中任二顶点至少被k条两两内部无公共顶点的路所连</p>
<h3 id="一个困惑">一个困惑</h3>
<p><span class="math inline">\(v\geq k+1\)</span>的图G是k-连通图</p>
<p><span class="math inline">\(\Leftrightarrow\)</span>
G中任二不相邻的顶点至少被k条两两内部无公共顶点的路所连</p>
<p>是否成立呢？</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 匹配的概念</title>
    <url>/2021/03/25/graphIntroduction-4/</url>
    <content><![CDATA[<h2 id="匹配">匹配</h2>
<ul>
<li>匹配：M是G的匹配：G中两两不相邻边构成的集合</li>
<li>被饱和的顶点：M中边的端点被M饱和</li>
</ul>
<h2 id="完美匹配">完美匹配</h2>
<ul>
<li>所有顶点都被饱和的匹配</li>
<li>阶是偶数</li>
<li>包含阶数的一半的边数</li>
<li><span class="math inline">\(K_{2n}\)</span> 包含 <span class="math inline">\(2n-1\)</span> 个不重的完美匹配</li>
</ul>
<h2 id="最大匹配">最大匹配</h2>
<ul>
<li>极大匹配：势极大的匹配，不是任何匹配的真子集</li>
<li>最大匹配：势最大的匹配</li>
</ul>
<h2 id="匹配的增光路">匹配的增光路</h2>
<ul>
<li>M交错路：边交替属于<span class="math inline">\(M\)</span>和<span class="math inline">\(E(G)\setminus M\)</span>的路</li>
<li>M增广路：起点和终点未被<span class="math inline">\(M\)</span>饱和的<span class="math inline">\(M\)</span>交错路</li>
</ul>
<h2 id="最大匹配的充要条件">最大匹配的充要条件</h2>
<p>图<span class="math inline">\(G\)</span>的一个匹配<span class="math inline">\(M\)</span>是最大匹配 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(G\)</span>中不存在<span class="math inline">\(M\)</span>的增广路</p>
<h2 id="奇分支">奇分支</h2>
<ul>
<li>阶为奇数的连通分支</li>
<li>图G的奇分支的数量记作<span class="math inline">\(o(G)\)</span></li>
<li>向图中增加边不会增加奇分支的数量</li>
</ul>
<h2 id="完美匹配的充要条件">完美匹配的充要条件</h2>
<p>图<span class="math inline">\(G\)</span>有完美匹配 <span class="math inline">\(\Leftrightarrow \forall S\subset V(G), o(G-S)\leq
|S|\)</span></p>
<h2 id="因子">因子</h2>
<ul>
<li><span class="math inline">\(k\)</span>-因子：图<span class="math inline">\(G\)</span>的<span class="math inline">\(k\)</span>-正则生成子图</li>
<li><span class="math inline">\(1\)</span>-因子：完美匹配</li>
<li>可<span class="math inline">\(k\)</span>-因子分解的：图G有一组<span class="math inline">\(k\)</span>-因子的边集构成<span class="math inline">\(E(G)\)</span>的一个划分</li>
<li><span class="math inline">\(k_{2n}\)</span> 是可<span class="math inline">\(1\)</span>-因子分解的</li>
<li><span class="math inline">\(\forall n&gt;0\)</span>, <span class="math inline">\(k_{2n+1}\)</span>是可<span class="math inline">\(2\)</span>-因子分解的</li>
</ul>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 最大匹配算法</title>
    <url>/2021/04/01/graphIntroduction-5/</url>
    <content><![CDATA[<h2 id="面向二部图的增广路算法">面向二部图的增广路算法</h2>
<h3 id="算法思路">算法思路</h3>
<ul>
<li>搜索一条增广路</li>
<li>如果找到了：替换得到更大的匹配，返回1</li>
<li>否则结束</li>
</ul>
<h3 id="算法细节">算法细节</h3>
<ol type="1">
<li>每轮从二部图的任意一侧的不饱和顶点开始，搜索增广路，以左侧为例。</li>
<li>左侧到右侧，找不在匹配中的边；右侧到左侧，找在匹配中的边。</li>
<li>如果找到一个不是起点的未饱和顶点 <span class="math inline">\(\Rightarrow\)</span> 则找到增广路 <span class="math inline">\(\Rightarrow\)</span> 替换得到更大的匹配 <span class="math inline">\(\Rightarrow\)</span> 转到5。</li>
<li>或深度优先搜索完所有的点和边，仍未找到增广路 <span class="math inline">\(\Rightarrow\)</span> 本轮没找到增广路 <span class="math inline">\(\Rightarrow\)</span> 转到5。</li>
<li>如果左侧还有不饱和的顶点没有搜索过，则转到1进入下一轮搜索。</li>
</ol>
<h3 id="算法正确性">算法正确性</h3>
<ul>
<li>算法一定会终止
<ul>
<li>DFS不重复的搜索 <span class="math inline">\(\Rightarrow\)</span>
每轮搜索一定会结束</li>
<li>总点数是有限的 <span class="math inline">\(\Rightarrow\)</span>
替换更大的匹配只能进行有限次 <span class="math inline">\(\Rightarrow\)</span> 轮数是有限的</li>
</ul></li>
<li>算法一旦终止，找到的一定是最大匹配
<ul>
<li>存在增广路 <span class="math inline">\(\Rightarrow\)</span>
一定能找到</li>
<li>不存在增广路 <span class="math inline">\(\Rightarrow\)</span>
无增广路 <span class="math inline">\(\Rightarrow\)</span>
找到最大匹配</li>
</ul></li>
</ul>
<h3 id="算法时间复杂度">算法时间复杂度</h3>
<ul>
<li>搜索的最大轮数: <span class="math inline">\(O(v)\)</span></li>
<li>每轮搜索的最大步骤数: <span class="math inline">\(O(v+\epsilon)\)</span></li>
<li>整个算法时间代价: <span class="math inline">\(O(v\epsilon)\)</span></li>
</ul>
<h2 id="面向二部图的hopcroft-karp算法">面向二部图的Hopcroft-karp算法</h2>
<h3 id="算法思路-1">算法思路</h3>
<ul>
<li>在增广路算法基础上改进</li>
<li>总搜索最短的增广路</li>
<li>每轮搜索多条无公共顶点的增广路，全部替换</li>
</ul>
<h3 id="算法细节-1">算法细节</h3>
<ol type="1">
<li>每轮从二部图的任意一侧的<strong>所有</strong>不饱和顶点开始，搜索增广路，以左侧为例。</li>
<li>左侧到右侧，找不在匹配中的边；右侧到左侧，找在匹配中的边。</li>
<li><strong>并发的</strong>利用广度优先搜索，对所有顶点进行分层；所有可能的起点构成第0层；与第i层相邻的所有未分层的顶点构成第i+1层。</li>
<li>若第k层包含未饱和的右侧顶点 <span class="math inline">\(\Rightarrow\)</span>
在分层信息引导下反向DFS搜回第0层，找到增广路，并把找到了增广路<strong>做删除标记</strong>
<span class="math inline">\(\Rightarrow\)</span>
第k层多个未饱和的右侧顶点可能找到多条无公共顶点的最短增广路。</li>
<li>若找不到增广路 <span class="math inline">\(\Rightarrow\)</span>
无增广路 <span class="math inline">\(\Rightarrow\)</span>
找到最大匹配；否则替换得到更大的匹配并返回步骤1。</li>
</ol>
<h3 id="算法正确性-1">算法正确性</h3>
<ul>
<li>算法一定会终止
<ul>
<li>BFS不重复的搜索 <span class="math inline">\(\Rightarrow\)</span>
每轮搜索一定会结束</li>
<li>总点数是有限的 <span class="math inline">\(\Rightarrow\)</span>
替换更大的匹配只能进行有限次 <span class="math inline">\(\Rightarrow\)</span> 轮数是有限的</li>
</ul></li>
<li>算法一旦终止，找到的一定是最大匹配
<ul>
<li>存在增广路 <span class="math inline">\(\Rightarrow\)</span>
一定能找到</li>
<li>不存在增广路 <span class="math inline">\(\Rightarrow\)</span>
无增广路 <span class="math inline">\(\Rightarrow\)</span>
找到最大匹配</li>
</ul></li>
</ul>
<h3 id="算法时间复杂度-1">算法时间复杂度</h3>
<ul>
<li>搜索的最大轮数: <span class="math inline">\(O(\sqrt{v}\)</span></li>
<li>每轮搜索的最大步骤数: <span class="math inline">\(O(v+\epsilon)\)</span></li>
<li>整个算法时间代价: <span class="math inline">\(O(\sqrt{v}\epsilon)\)</span></li>
</ul>
<h2 id="面向一般图的edmonds算法">面向一般图的Edmonds算法</h2>
<h3 id="算法思路-2">算法思路</h3>
<ul>
<li>在增广路算法的基础上改进</li>
<li>在每轮搜索中，如果一个顶点在本轮搜索中，已经经过长为偶数的交错路到达，同时又经过长为奇数的交错路到达，那么就发现了一个奇圈，两条路并称为flower；奇圈称为blossom</li>
<li>两条交错路的最长公共子路称为stem，其终点称为base</li>
<li>stem的最后一条边在当前匹配中，否则再往后的一条边一定在匹配中，是唯一的，和奇圈矛盾</li>
<li>blossom的顶点关联的边中，除blossom中的边和stem的最后一条边以外，其它都不在当前匹配中。(否则该边奇圈中的顶点在奇圈中的两条边都是未匹配的边，从而无法发现奇圈)</li>
<li>将blossom收缩为一个顶点：顶点合并，内部边删除、外部边保留</li>
<li>如果新图中有增广路，那么原图中一定有增广路</li>
</ul>
<h3 id="关键步骤">关键步骤</h3>
<ul>
<li>在搜索过程中，一旦发现奇圈，将其收缩成一个顶点，再继续搜索</li>
<li>如果新图中的增广路经过收缩后的顶点，那么利用奇圈中的两条交错路之一（恰有一条会符合要求）将其还原到原图的增广路</li>
</ul>
<h3 id="算法时间复杂度-2">算法时间复杂度</h3>
<ul>
<li>朴素的实现：<span class="math inline">\(O(v^4)\)</span></li>
<li>合适的数据结构表示blossom和处理收缩：<span class="math inline">\(O(v^3)\)</span></li>
<li>一般图最大匹配的其他算法中，时间开销最少的能到达：<span class="math inline">\(O(\sqrt{v}\epsilon)\)</span></li>
</ul>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 中国邮递员问题和旅行商问题</title>
    <url>/2021/04/08/graphIntroduction-6/</url>
    <content><![CDATA[<h2 id="中国邮递员问题">中国邮递员问题</h2>
<h3 id="最优邮路">最优邮路</h3>
<p>求赋权连通图中含有所有边且权和最小的闭途径</p>
<h3 id="euler图">Euler图</h3>
<ul>
<li>Euler迹：经过每条边恰好一次的迹</li>
<li>Euler闭迹：经过每条边恰好一次的闭迹</li>
<li>Euler图：有Euler闭迹的图</li>
<li>Euler图的最优邮路：即Euler闭迹</li>
</ul>
<h3 id="非euler图的最优邮路">非Euler图的最优邮路</h3>
<ul>
<li>必然要重复经过一些边</li>
<li>重复走过的边作为重边添加到图中 <span class="math inline">\(\Rightarrow\)</span> 新图一定是Euler图</li>
<li>原图的最优邮路和新图的Euler闭迹一一对应</li>
</ul>
<h3 id="问题转换">问题转换</h3>
<ul>
<li>添加重边成为Euler图（如果本身不是的话）</li>
<li>使添加的边权和最小</li>
<li>找Euler闭迹</li>
</ul>
<h3 id="添加重边成为euler图">添加重边成为Euler图</h3>
<h4 id="euler图的充要条件">Euler图的充要条件</h4>
<p>一个非空连通图是Euler图当且仅当它没有奇度顶点 #### 添加重边的方案 +
奇度顶点 <span class="math inline">\(\rightarrow\)</span> 偶度顶点 +
偶度顶点 <span class="math inline">\(\rightarrow\)</span> 偶度顶点</p>
<h3 id="使添加的边权和最小">使添加的边权和最小</h3>
<h4 id="定理">定理</h4>
<p>设<span class="math inline">\(G\)</span>是赋权连通图，<span class="math inline">\(G\)</span>中有<span class="math inline">\(2k\)</span>个奇度顶点。<span class="math inline">\(G^\star\)</span>是<span class="math inline">\(G\)</span>的最优邮路对应的Euler图，令<span class="math inline">\(E&#39;=E(G^\star) \setminus E(G)\)</span>。则<span class="math inline">\(H=G\[E&#39;\]\)</span>是以<span class="math inline">\(G\)</span>的奇度顶点为起点和终点的k条无公共边的最短路之并。</p>
<h4 id="重边的添加方法">重边的添加方法</h4>
<ul>
<li>连接k对奇度顶点的k条无公共边的最短路</li>
<li>且边权和最小</li>
</ul>
<h2 id="旅行商问题">旅行商问题</h2>
<h3 id="hamilton图">Hamilton图</h3>
<ul>
<li>Hamilton路：经过每个顶点恰一次的路</li>
<li>Hamilton圈：经过每个顶点恰一次的圈</li>
<li>Hamilton图：有Hamilton圈的图</li>
</ul>
<h3 id="旅行商问题的难度">旅行商问题的难度</h3>
<ul>
<li>找Hamilton圈：NP-complete</li>
<li>找权和最小的Hamilton圈：NP-hard</li>
</ul>
<h3 id="旅行商问题的近似算法">旅行商问题的近似算法</h3>
<ul>
<li>邻近点法</li>
<li>最小生成树法</li>
<li>最小权匹配法</li>
<li>Kernighan-Lin</li>
</ul>
<h3 id="邻近点法">邻近点法</h3>
<h4 id="基本思路">基本思路</h4>
<p>贪心的选择最近的未访问的邻点前行</p>
<h4 id="算法性能">算法性能</h4>
<ul>
<li>近似比<span class="math inline">\(w(H)\setminus w(H^\star)\leq
(\lceil log_2v\rceil)\)</span></li>
<li>最终结果只和初始点的选取有关</li>
<li>时间复杂度：<span class="math inline">\(O(v^2)\)</span></li>
</ul>
<h3 id="最小生成树法">最小生成树法</h3>
<h4 id="基本思路-1">基本思路</h4>
<ul>
<li>找<span class="math inline">\(K_n\)</span>的一颗最小生成树</li>
<li>为<span class="math inline">\(T\)</span>中的每条边添加重边成为<span class="math inline">\(T^\star\)</span></li>
<li>找<span class="math inline">\(T^\star\)</span>的一条Euler闭迹<span class="math inline">\(C\)</span></li>
<li>沿<span class="math inline">\(C\)</span>前行，跳过已访问过的顶点，直至访问完所有顶点</li>
</ul>
<h4 id="算法性能-1">算法性能</h4>
<ul>
<li>近似比<span class="math inline">\(w(H)\setminus w(H^\star)\leq
2\)</span></li>
<li>最终结果和最小生成树、闭迹、闭迹初始点有关</li>
<li>时间复杂度：找最小生成树<span class="math inline">\(O(\epsilon+vlog
v)\)</span>，添加重边<span class="math inline">\(O(v)\)</span>，找Euler闭迹<span class="math inline">\(O(v)\)</span>，沿Euler闭迹前行<span class="math inline">\(O(v)\)</span></li>
<li>本算法可以进一步优化</li>
</ul>
<h3 id="最小权匹配法">最小权匹配法</h3>
<h4 id="基本思路-2">基本思路</h4>
<ul>
<li>找<span class="math inline">\(K_n\)</span>的一颗最小生成树</li>
<li>找<span class="math inline">\(T\)</span>中奇度顶点在<span class="math inline">\(K_n\)</span>中异于导出子图<span class="math inline">\(G&#39;\)</span>的最小权完美匹配<span class="math inline">\(M\)</span></li>
<li>将<span class="math inline">\(M\)</span>添加到<span class="math inline">\(T\)</span>中成为<span class="math inline">\(T^\star\)</span></li>
<li>找<span class="math inline">\(T^\star\)</span>的一条Euler闭迹<span class="math inline">\(C\)</span></li>
<li>沿<span class="math inline">\(C\)</span>前行，跳过已访问过的顶点，直至访问完所有顶点</li>
</ul>
<h4 id="算法性能-2">算法性能</h4>
<ul>
<li>近似比<span class="math inline">\(w(H)\setminus w(H^\star)\leq
\frac{3}{2}\)</span></li>
<li>最终结果和最小生成树、最小权完美匹配、闭迹、闭迹初始点有关</li>
<li>时间复杂度：找最小生成树<span class="math inline">\(O(\epsilon+vlog
v)\)</span>，找最小权完美匹配<span class="math inline">\(O(\sqrt{v}\epsilon)，\)</span>添加边<span class="math inline">\(O(v)\)</span>，找Euler闭迹<span class="math inline">\(O(v)\)</span>，沿Euler闭迹前行<span class="math inline">\(O(v)\)</span></li>
<li>本算法可以进一步优化</li>
</ul>
<h3 id="kernighan-lin">Kernighan-Lin</h3>
<p>理论近似比差，实际效果好的算法，详略。</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 支配集、点独立集和点覆盖集</title>
    <url>/2021/04/15/graphIntroduction-7/</url>
    <content><![CDATA[<h2 id="支配集">支配集</h2>
<h3 id="支配集控制集">支配集(控制集)</h3>
<ul>
<li><span class="math inline">\(D\)</span>是<span class="math inline">\(G\)</span>支配集：<span class="math inline">\(\forall v \in (V(G)\setminus D), \exists u \in
D,(u,v)\in E(G)\)</span></li>
<li>极小支配集：任何真子集都不是支配集</li>
<li>最小支配集：顶点数最小</li>
<li>支配数<span class="math inline">\(\gamma(G)\)</span>：最小支配集的势</li>
</ul>
<h3 id="支配集与匹配">支配集与匹配</h3>
<ul>
<li>从完美匹配中的每条边任取一个端点构成一个支配集</li>
<li>从最大匹配中的每条边中存在一个端点的取法构成支配集</li>
</ul>
<h3 id="支配集和其补集">支配集和其补集</h3>
<ul>
<li>无孤立顶点的图<span class="math inline">\(G\)</span>中，存在支配集<span class="math inline">\(D\)</span>和<span class="math inline">\(V(G)\setminus D\)</span></li>
<li>无孤立顶点的图<span class="math inline">\(G\)</span>中，极小支配集<span class="math inline">\(D\)</span>的补集<span class="math inline">\(V(G)\setminus D\)</span>是支配集</li>
<li>无孤立顶点的图<span class="math inline">\(G\)</span>中，对任意一个极小支配集<span class="math inline">\(D_1\)</span>，必存在另一个极小支配集<span class="math inline">\(D_2\)</span>，使得<span class="math inline">\(D_1\cap D_2=\emptyset\)</span></li>
<li><span class="math inline">\(V(G)\setminus
D_1\)</span>是支配集且<span class="math inline">\(D_1\cap (V(G)\setminus
D_1)=\emptyset \Rightarrow\)</span>在<span class="math inline">\(V(G)\setminus D_1\)</span>的子集中取极小可得<span class="math inline">\(D_2\)</span></li>
</ul>
<h3 id="极小支配集的充要条件">极小支配集的充要条件</h3>
<p>图<span class="math inline">\(G\)</span>的支配集<span class="math inline">\(D\)</span>是一个极小支配集当且仅当<span class="math inline">\(D\)</span>中每个顶点<span class="math inline">\(v\)</span>满足下列条件之一： + <span class="math inline">\(N(v)\cap D =\emptyset\)</span> + 存在<span class="math inline">\(u\in V(G)\setminus D\)</span>使得<span class="math inline">\(N(u)\cap D={v}\)</span></p>
<h3 id="支配数的估计">支配数的估计</h3>
<ul>
<li>无孤立顶点的图<span class="math inline">\(G\)</span>满足<span class="math inline">\(\gamma(G)\leq \frac{v}{2}\)</span></li>
<li><span class="math inline">\(\lceil\frac{v}{1+\Delta(G)}\rceil\leq
\gamma(G)\leq v-\Delta(G)\)</span></li>
</ul>
<h3 id="求最小支配集的算法">求最小支配集的算法</h3>
<ul>
<li>和集合覆盖问题可以相互转化：NP-hard</li>
<li>贪心算法：每次迭代总选能支配最多剩余顶点的那个顶点，近似比<span class="math inline">\(1+log\ v\)</span></li>
<li>不存在近似比好于对数的多项式时间算法（除非P=NP），即贪心已经足够好了</li>
</ul>
<h3 id="支配集的应用">支配集的应用</h3>
<ul>
<li>奇次支配集：Lights Out</li>
<li>最小连通支配集：自组网络中的虚拟骨干网</li>
</ul>
<h2 id="点独立集">点独立集</h2>
<h3 id="点独立集-1">点独立集</h3>
<ul>
<li><span class="math inline">\(I\)</span>是<span class="math inline">\(G\)</span>的点独立集：<span class="math inline">\(\forall u,v\in I,(u,v)\notin E(G)\)</span></li>
<li>极大点独立集：顶点数极多（不是任何一个点独立集的真子集）</li>
<li>最大点独立集：顶点数最多</li>
<li>独立数<span class="math inline">\(\alpha(G)\)</span>：最大点独立集的势</li>
</ul>
<h3 id="点独立集与支配集">点独立集与支配集</h3>
<ul>
<li>极大点独立集必然是最小支配集</li>
<li>若<span class="math inline">\(I\)</span>是点独立集，则它是极大点独立集当且仅当它是支配集</li>
<li><span class="math inline">\(\alpha(G)\geq \gamma(G)\)</span></li>
</ul>
<h3 id="点独立集与连通度">点独立集与连通度</h3>
<ul>
<li>设<span class="math inline">\(v(G)\geq 2\)</span>，若图<span class="math inline">\(G\)</span>中任意两个不相邻顶点<span class="math inline">\(x,y\)</span>均有<span class="math inline">\(d(x)+d(y)\geq v(G)\)</span>，则<span class="math inline">\(\alpha(G)\leq \kappa(G)\)</span></li>
<li>设<span class="math inline">\(G\)</span>是<span class="math inline">\(v\)</span>阶简单图<span class="math inline">\((v
\geq 2)\)</span>。若<span class="math inline">\(\delta(G)\geq
\frac{v}{2}\)</span>，则<span class="math inline">\(\alpha(G)\leq
\kappa(G)\)</span></li>
</ul>
<h3 id="求最大独立集的算法">求最大独立集的算法</h3>
<ul>
<li>最大独立集即补图中最大团：NP-hard</li>
<li>不存在近似比显著好于线性的多项式时间算法（除非P=NP）</li>
</ul>
<h3 id="独立集的应用">独立集的应用</h3>
<h4 id="最大带权独立集图像分割">最大带权独立集：图像分割</h4>
<ul>
<li>顶点：所有可能的块</li>
<li>边：重叠的块</li>
<li>权：块的显著程度</li>
</ul>
<h2 id="点覆盖集">点覆盖集</h2>
<h3 id="点覆盖集-1">点覆盖集</h3>
<ul>
<li><span class="math inline">\(F\)</span>是<span class="math inline">\(G\)</span>的点覆盖集：<span class="math inline">\(\forall (u,v)\in E(G),\{u,v\}\cap F\neq
\emptyset\)</span></li>
<li>极小点覆盖集：顶点数极少（任何一个真子集都不是点覆盖集）</li>
<li>最小点覆盖集：顶点数最少</li>
<li>点覆盖数<span class="math inline">\(\beta(G)\)</span>：最小点覆盖集的势</li>
</ul>
<h3 id="点覆盖集与支配集">点覆盖集与支配集</h3>
<ul>
<li>点覆盖集与所有边关联</li>
<li>支配集与所有剩余点相邻</li>
<li>连通图中点覆盖集一定是支配集，但支配集不一定是点覆盖集</li>
</ul>
<h3 id="点覆盖集与独立集">点覆盖集与独立集</h3>
<ul>
<li><span class="math inline">\(F\)</span>是点覆盖集当且仅当<span class="math inline">\(V(G)\setminus F\)</span>是点独立集</li>
<li><span class="math inline">\(F\)</span>是极小点覆盖集当且仅当<span class="math inline">\(V(G)\setminus F\)</span>是极大点独立集</li>
<li><span class="math inline">\(\alpha(G)+\beta(G)=v(G)\)</span></li>
</ul>
<h3 id="求最小点覆盖集的算法">求最小点覆盖集的算法</h3>
<h4 id="点覆盖集和极大匹配的关系">点覆盖集和极大匹配的关系</h4>
<ul>
<li>极大匹配饱和的所有顶点构成一个点覆盖集</li>
<li>近似比2</li>
<li>找极大匹配即可</li>
<li>不存在近似比好于1.3606的多项式时间算法（除非P=NP）</li>
<li>目前还没有找到近似比显著小于2的多项式时间算法：基于极大匹配的算法还不错</li>
</ul>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 边独立集和边覆盖集</title>
    <url>/2021/04/22/graphIntroduction-8/</url>
    <content><![CDATA[<h2 id="边独立集">边独立集</h2>
<h3 id="边独立集-1">边独立集</h3>
<ul>
<li>边独立集（匹配）：两两不相邻的边</li>
<li>极大边独立集（极大匹配）：不是任何边独立集的真子集</li>
<li>最大边独立集（最大匹配）：边数最多</li>
<li>边独立数<span class="math inline">\(\alpha&#39;(G)\)</span>：最大边独立集的势</li>
</ul>
<h3 id="边独立集与点覆盖集">边独立集与点覆盖集</h3>
<ul>
<li>对任何无环边的图<span class="math inline">\(G\)</span>，<span class="math inline">\(\alpha&#39;(G)\leq \beta(G)\)</span></li>
<li>二部图<span class="math inline">\(X-Y\)</span>有饱和<span class="math inline">\(X\)</span>的匹配当且仅当<span class="math inline">\(\forall S\subset X,|N(S)|\geq |S|\)</span></li>
<li>二部图<span class="math inline">\(G\)</span>，<span class="math inline">\(\alpha&#39;(G)=\beta(G)\)</span></li>
</ul>
<h4 id="求最小点覆盖的算法">求最小点覆盖的算法</h4>
<ul>
<li>一般图：不存在近似比好于1.3606的多项式时间算法（除非P=NP）</li>
<li>二部图：存在精确的多项式时间算法</li>
</ul>
<h4 id="二部图最小点覆盖算法细节">二部图最小点覆盖算法细节</h4>
<ul>
<li>求最大匹配</li>
<li>未饱和顶点作为第0层</li>
<li>根据交错路的距离对其他顶点分层</li>
<li>每条边都有一个端点在奇层</li>
<li>奇层顶点恰根据匹配中一条边引出一个新的偶层顶点</li>
</ul>
<h3 id="边独立数的估计">边独立数的估计</h3>
<p>设图<span class="math inline">\(G\)</span>无孤立点，则<span class="math inline">\(\lceil\frac{v}{1+\Delta(G)}\rceil\leq
\alpha&#39;(G)\leq \lfloor\frac{v}{2}\rfloor\)</span></p>
<h2 id="边覆盖集">边覆盖集</h2>
<h3 id="边覆盖集-1">边覆盖集</h3>
<ul>
<li><span class="math inline">\(L\)</span>是<span class="math inline">\(G\)</span>（<span class="math inline">\(G\)</span>无孤立点即<span class="math inline">\(\delta(G)&gt;0\)</span>）的边覆盖集：<span class="math inline">\(\forall u\in V(G),\exists v\in V(G),(u,v)\in
L\)</span></li>
<li>极小边覆盖集：任何一个真子集都不再是边覆盖集</li>
<li>最小边覆盖集：边数最少</li>
<li>边覆盖数<span class="math inline">\(\beta&#39;(G)\)</span>：最小边覆盖集的势</li>
</ul>
<h3 id="边覆盖集与边独立集">边覆盖集与边独立集</h3>
<ul>
<li>若<span class="math inline">\(\delta(G)&gt;0\)</span>，则<span class="math inline">\(\alpha&#39;(G)+\beta&#39;(G)=v(G)\)</span></li>
<li>设<span class="math inline">\(\delta(G)&gt;0\)</span>，则<span class="math inline">\(\alpha&#39;(G)\leq
\beta&#39;(G)\)</span>，等号成立当且仅当<span class="math inline">\(G\)</span>有完美匹配</li>
</ul>
<h3 id="边覆盖集与点独立集">边覆盖集与点独立集</h3>
<ul>
<li><span class="math inline">\(\alpha(G)\leq
\beta&#39;(G)\)</span></li>
<li>设<span class="math inline">\(G\)</span>是二部图且<span class="math inline">\(\delta(G)\geq 0\)</span>，则<span class="math inline">\(\alpha(G)=\beta&#39;(G)\)</span></li>
</ul>
<h3 id="边覆盖数的估计">边覆盖数的估计</h3>
<p>设<span class="math inline">\(G\)</span>无孤立点，则<span class="math inline">\(\lceil\frac{v}{2}\rceil\leq\beta&#39;(G)\leq\lceil
v\frac{\Delta(G)}{1+\Delta(G)}\rceil\)</span></p>
<h3 id="无孤立点图中更一般的关系">无孤立点图中更一般的关系</h3>
<ul>
<li>边独立集小于等于边覆盖集，当边独立集为完美匹配，边覆盖集为最小时取等号</li>
<li>边独立集小于等于点覆盖集，当边独立集为最大匹配，点覆盖集为最小时取等号</li>
<li>点独立集小于等于边覆盖集，当点独立集为最大，边覆盖集为最小时取等号</li>
<li><span class="math inline">\(\gamma(G)\leq
\min\{\alpha(G),\beta(G),\alpha&#39;(G),\beta&#39;(G)\}\)</span></li>
</ul>
<h3 id="求最小边覆盖集的算法">求最小边覆盖集的算法</h3>
<ul>
<li>原理是<span class="math inline">\(\beta&#39;(G)=v(G)-\alpha&#39;(G)=\alpha&#39;(G)+[v(G)-2\alpha&#39;(G)]\)</span></li>
<li>最大匹配</li>
<li>每个未饱和点任取一边</li>
</ul>
<h2 id="关系小节">关系小节</h2>
<ul>
<li><span class="math inline">\(\gamma(G)\leq
\min\{\alpha(G),\beta(G),\alpha&#39;(G),\beta&#39;(G)\}\)</span></li>
<li><span class="math inline">\(\alpha(G)\leq
\beta&#39;(G)\)</span></li>
<li><span class="math inline">\(\alpha&#39;(G)\leq
\beta(G)\)</span></li>
<li><span class="math inline">\(\alpha&#39;(G)\leq
\beta&#39;(G)\)</span></li>
<li><span class="math inline">\(\alpha(G)+ \beta(G)=v(G)\)</span></li>
<li><span class="math inline">\(\alpha&#39;(G)+
\beta&#39;(G)=v(G)\)</span></li>
</ul>
<h2 id="求解算法小节">求解算法小节</h2>
<ul>
<li>最小支配集：近似算法，贪心</li>
<li>最大点独立集：最小点覆盖集的补集</li>
<li>最小点覆盖集：一般图用近似算法，基于极大匹配；二部图基于最大匹配</li>
<li>最大边独立集：即最大匹配求解算法，一般图用Edmonds，二部图用Hopcroft-Karp</li>
<li>最小边覆盖集：基于最大匹配</li>
</ul>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第一章-行列式</title>
    <url>/2021/11/12/linearAlgebra1/</url>
    <content><![CDATA[<ul>
<li>本知识总结不提供完整的理论体系汇总，旨在给出<em>概念的理解</em>以及<em>各类问题的思考框架</em>。</li>
<li>笔记为个人整理，禁止商业用途</li>
<li>如有疏漏，欢迎留言</li>
</ul>
<h2 id="拉普拉斯展开式">拉普拉斯展开式</h2>
<ul>
<li><span class="math inline">\(\pmb{A}\)</span>和<span class="math inline">\(\pmb{B}\)</span>分别是<span class="math inline">\(m\)</span>阶矩阵和<span class="math inline">\(n\)</span>阶矩阵</li>
<li><span class="math inline">\(\begin{vmatrix} \pmb{A}&amp; \pmb{\star}
\\ \pmb{O}&amp; \pmb{B} \\ \end{vmatrix} =\begin{vmatrix} \pmb{A}&amp;
\pmb{O} \\ \pmb{\star}&amp; \pmb{B} \\ \end{vmatrix}
=|\pmb{A}|\cdot|\pmb{B}|\)</span></li>
<li><span class="math inline">\(\begin{vmatrix} \pmb{O}&amp; \pmb{A} \\
\pmb{B}&amp; \pmb{\star} \\ \end{vmatrix}=\begin{vmatrix}
\pmb{\star}&amp; \pmb{A} \\ \pmb{B}&amp; \pmb{O} \\ \end{vmatrix}
=(-1)^{mn}|\pmb{A}|\cdot|\pmb{B}|\)</span></li>
</ul>
<h2 id="范德蒙行列式">范德蒙行列式</h2>
<p><span class="math inline">\(\begin{vmatrix} 1&amp; 1&amp; \cdots&amp;
1 \\ x_1&amp; x_2&amp; \cdots&amp; x_n \\ {x_1}^2&amp; {x_2}^2&amp;
\cdots&amp; {x_n}^2 \\ \vdots&amp; \vdots&amp; \ &amp; \vdots \\
{x_1}^{n-1}&amp; {x_2}^{n-1}&amp; \cdots&amp; {x_n}^{n-1} \end{vmatrix}
=\prod\limits_{1\leq j\leq i\leq n}(x_i-x_j)\)</span></p>
<h2 id="爪型行列式">爪型行列式</h2>
<ul>
<li>形式：<span class="math inline">\(\begin{vmatrix} a_{11}&amp;
a_{12}&amp; a_{13}&amp; \cdots &amp;a_{1n} \\ a_{21}&amp; a_{22}&amp; \
&amp; \ &amp; \  \\ a_{31}&amp; \ &amp; a_{33} &amp; \ &amp;\  \\ \vdots
&amp; \  &amp; \ &amp; \ &amp;\  \\ a_{n1} &amp; \ &amp; \ &amp;
\  &amp;a_{nn} \end{vmatrix}\)</span></li>
<li>解法：把第<span class="math inline">\(1\)</span>列以外的第<span class="math inline">\(i\)</span>列，按某个比例加到第<span class="math inline">\(1\)</span>列，消去第<span class="math inline">\(1\)</span>列的第<span class="math inline">\(i\)</span>行元素</li>
</ul>
<h2 id="代数余子式">代数余子式</h2>
<p>代数余子式相关问题考虑根据下面的思路</p>
<ul>
<li>代数余子式定义：直接计算</li>
<li>行列式构造：利用某行代数余子式与该行元素值无关，<strong>构造</strong>新的行列式</li>
<li>行列式定义：<strong>行列式的值等于</strong>其任意一行（列）的元素与该行（列）代数余子式的乘积和</li>
<li>行列式性质：行列式任意一行（列）的元素与其他任意行（列）代数余子式的乘积和<strong>等于0</strong></li>
<li>伴随矩阵定义：矩阵的伴随矩阵的<strong>第i行第j列</strong>元素等于矩阵的行列式<strong>第j行第i列</strong>的代数余子式</li>
</ul>
<h2 id="数字型行列式计算">数字型行列式计算</h2>
<h3 id="基本操作">基本操作</h3>
<ul>
<li>不断把某行的k倍加到另一行，进行化简</li>
<li>按行或列展开，进行降阶</li>
</ul>
<h3 id="行列式拓展">行列式拓展</h3>
<ul>
<li><span class="math inline">\(\begin{vmatrix}
a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}\\ a_{21} &amp;a_{22} &amp;\cdots
&amp;a_{2n} \\ \vdots &amp;\vdots&amp; \  &amp;\vdots\\
a_{n1}&amp;a_{n2}&amp;\cdots&amp;a_{nn} \end{vmatrix} =\begin{vmatrix}
1&amp; 1 &amp; 1&amp; \cdots&amp; 1 \\ 0&amp;
a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}\\ 0&amp;a_{21} &amp;a_{22}
&amp;\cdots &amp;a_{2n} \\0&amp; \vdots &amp;\vdots&amp;
\  &amp;\vdots\\ 0&amp;a_{n1}&amp;a_{n2}&amp;\cdots&amp;a_{nn}
\end{vmatrix}\)</span></li>
</ul>
<h3 id="转化为求特征值问题">转化为求特征值问题</h3>
<ul>
<li>详见第二章矩阵笔记的矩阵加法分解部分</li>
</ul>
<h2 id="三对角型行列式">三对角型行列式</h2>
<ul>
<li>求解<span class="math inline">\(D_n=\begin{vmatrix} a&amp; b&amp; \
&amp; \  &amp;\  \\ c&amp; a&amp; b&amp; \ &amp; \  \\ \ &amp; c&amp;
a&amp; \ddots&amp;\  \\ \ &amp; \  &amp; \ddots&amp; \ddots&amp;b \\ \
&amp; \ &amp; \ &amp; c &amp;a \end{vmatrix}\)</span></li>
<li>核心思路
<ul>
<li>把<span class="math inline">\(D_n\)</span>展开</li>
<li>算出递推式：<span class="math inline">\(D_n=aD_{n-1}-bcD_{n-2}\)</span></li>
<li>算出<span class="math inline">\(D_1\)</span>和<span class="math inline">\(D_2\)</span></li>
<li>如果题目是计算，则用数列知识继续算</li>
<li>如果题目是证明，考虑数学归纳法比较方便</li>
</ul></li>
</ul>
<h2 id="抽象型行列式计算">抽象型行列式计算</h2>
<p>主要是利用一些行列式性质来算，比如</p>
<ul>
<li><span class="math inline">\(|k \pmb{A}|=k^n|\pmb{A}|\)</span></li>
<li><span class="math inline">\(|\pmb{A}^T|=|\pmb{A}|\)</span></li>
<li><span class="math inline">\(|\pmb{A}\pmb{B}|=|\pmb{A}||\pmb{B}|\)</span></li>
<li><span class="math inline">\(|\pmb{A}^\star|=|\pmb{A}|^{n-1}\)</span></li>
<li><span class="math inline">\(|\pmb{A}^{-1}|=|\pmb{A}|^{-1}\)</span></li>
<li><span class="math inline">\(|\pmb{A}|=\prod\limits_{i=1}^n\lambda_i\)</span></li>
<li><span class="math inline">\(|\pmb{A}|\sim|\pmb{B}|\Rightarrow
|\pmb{A}|=|\pmb{B}|\)</span></li>
</ul>
<h2 id="判定行列式是否为零">判定行列式是否为零</h2>
<p>下面条件是等价的</p>
<ul>
<li><strong>行列式</strong>：<span class="math inline">\(|\pmb{A}|=0\)</span>（可用各种性质直接计算）</li>
<li><strong>矩阵</strong>：<span class="math inline">\(\pmb{A}\)</span>不可逆</li>
<li><strong>秩</strong>：<span class="math inline">\(r(\pmb{A})&lt;n\)</span></li>
<li><strong>向量</strong>：<span class="math inline">\(\pmb{A}\)</span>的各行（列）向量线性相关</li>
<li><strong>线性方程组</strong>：<span class="math inline">\(\pmb{Ax}=\pmb{0}\)</span>有非零解</li>
<li><strong>特征值</strong>：存在<span class="math inline">\(\lambda_i=0\)</span></li>
</ul>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 平面图的概念</title>
    <url>/2021/04/29/graphIntroduction-9/</url>
    <content><![CDATA[<h3 id="平面图的概念">平面图的概念</h3>
<h4 id="可平面图">可平面图</h4>
<ul>
<li>定义：能画在平面上，且任意两边不交叉</li>
<li>交叉：包含端点以外的其他公共点</li>
<li>这个画法叫做一种平面嵌入</li>
<li>画出来的结果是一个平面图</li>
<li>两个很重要的不可平面图，是<span class="math inline">\(K_5,K_{3,3}\)</span></li>
</ul>
<h4 id="可平面图的性质">可平面图的性质</h4>
<ul>
<li>可平面图的子图是可平面图</li>
<li>环边和重边不影响可平面图</li>
</ul>
<h4 id="面和边界">面和边界</h4>
<ul>
<li>面
<ul>
<li>平面图的边将平面划分出的极大区域</li>
<li>面数：<span class="math inline">\(\varphi(G)\)</span></li>
</ul></li>
<li>无限面
<ul>
<li>面积无限的面，又称外部面</li>
<li>平面图只有一个无限面</li>
<li>每个非外部面都能按照另一种平面嵌入变为外部面</li>
</ul></li>
<li>边界
<ul>
<li>包围一个面的所有边</li>
</ul></li>
<li>面的度数
<ul>
<li>边界上边的数量，又称长度</li>
<li>只在一个面的边界上的边（即割边）计两次</li>
<li>图的所有面的度数和=所有边数目的两倍</li>
</ul></li>
<li>平面图G是二部图的充要条件是任意一个面的度数是偶数</li>
</ul>
<h4 id="极大可平面图">极大可平面图</h4>
<ul>
<li>极大可平面图：
<ul>
<li>简单可平面图</li>
<li>任意增加一条连接不相邻顶点的边都不再是可平面图</li>
</ul></li>
<li>性质
<ul>
<li>一定是连通图</li>
<li>不能有割点或割边（<span class="math inline">\(v\geq
3\)</span>时）</li>
</ul></li>
<li>对于至少含3个顶点的极大平面图，其每个面的度数必定都是3</li>
</ul>
<h3 id="euler公式及其应用">Euler公式及其应用</h3>
<h4 id="euler公式">Euler公式</h4>
<ul>
<li>对于连通的平面图，<span class="math inline">\(v-\epsilon+\varphi=2\)</span></li>
<li>对于具有<span class="math inline">\(w\)</span>个连通分支的平面图，<span class="math inline">\(v-\epsilon+\varphi=w+1\)</span></li>
</ul>
<h4 id="euler公式的应用">Euler公式的应用</h4>
<ul>
<li>设<span class="math inline">\(G\)</span>是连通的平面图，且每个面的度数至少为<span class="math inline">\(l(l\geq 3)\)</span>，则<span class="math inline">\(\epsilon\leq \frac{l}{l-2}(v-2)\)</span></li>
<li>设<span class="math inline">\(G\)</span>是具有<span class="math inline">\(w(w\geq
1)\)</span>个连通分支的平面图，各个面的度数至少为<span class="math inline">\(l(l\geq 3)\)</span>，则<span class="math inline">\(\epsilon\leq \frac{l}{l-2}(v-w-1)\)</span></li>
<li><span class="math inline">\(K_5\)</span>和<span class="math inline">\(K_{3,3}\)</span>都是不可平面图</li>
<li>设<span class="math inline">\(G\)</span>是<span class="math inline">\(v\geq 3\)</span>的简单平面图，则<span class="math inline">\(\epsilon\leq 3v-6\)</span></li>
<li>设<span class="math inline">\(G\)</span>是<span class="math inline">\(v\geq 3\)</span>的简单平面图，则<span class="math inline">\(\delta \leq 5\)</span></li>
<li>设<span class="math inline">\(G\)</span>是<span class="math inline">\(v\geq 3\)</span>的极大简单平面图，则<span class="math inline">\(\epsilon= 3v-6,\varphi=2v-4\)</span></li>
<li>设<span class="math inline">\(G\)</span>是<span class="math inline">\(v\geq 3\)</span>的简单连通图，则<span class="math inline">\(G\)</span>是极大平面图当且仅当<span class="math inline">\(G\)</span>的每个面的度数均为3</li>
<li>不可能用正圆画出4个集合的Venn图</li>
</ul>
<h3 id="平面图的对偶图">平面图的对偶图</h3>
<h4 id="对偶图">对偶图</h4>
<ul>
<li>面<span class="math inline">\(\rightarrow\)</span>点</li>
<li>公共边界上的边<span class="math inline">\(\rightarrow\)</span>连接两点的边</li>
<li>割边<span class="math inline">\(\rightarrow\)</span>环</li>
<li>记作<span class="math inline">\(G^\star\)</span></li>
</ul>
<h4 id="对偶图的性质">对偶图的性质</h4>
<ul>
<li><span class="math inline">\(G\)</span>的割边对应<span class="math inline">\(G^\star\)</span>的环边，<span class="math inline">\(G\)</span>的环边对应<span class="math inline">\(G^\star\)</span>的割边</li>
<li><span class="math inline">\(G^\star\)</span>是连通图</li>
<li><span class="math inline">\(G^\star\)</span>是平面图</li>
<li>定理：设<span class="math inline">\(G^\star\)</span>是具有<span class="math inline">\(w\)</span>个连通分支的平面图<span class="math inline">\(G\)</span>的对偶图，则
<ul>
<li><span class="math inline">\(v^\star = \varphi\)</span></li>
<li><span class="math inline">\(\epsilon^\star =\epsilon\)</span></li>
<li><span class="math inline">\(\varphi^\star = v-w+1\)</span></li>
<li>设<span class="math inline">\(G^\star\)</span>的顶点<span class="math inline">\({v_i}^\star\)</span>位于<span class="math inline">\(G\)</span>的面<span class="math inline">\(F_i\)</span>中，则<span class="math inline">\(d_{G^\star}({v_i}^\star)=d(F_i)\)</span></li>
</ul></li>
<li>同构图的对偶图不一定同构</li>
<li>对于连通的平面图<span class="math inline">\(G\)</span>，其对偶图的对偶图还是<span class="math inline">\(G\)</span>，即<span class="math inline">\((G^\star)^\star=G\)</span></li>
</ul>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第二章-矩阵</title>
    <url>/2021/11/12/linearAlgebra2/</url>
    <content><![CDATA[<ul>
<li>本知识总结不提供完整的理论体系汇总，旨在给出<em>概念的理解</em>以及<em>各类问题的思考框架</em>。</li>
<li>笔记为个人整理，禁止商业用途</li>
<li>如有疏漏，欢迎留言</li>
</ul>
<h2 id="伴随矩阵">伴随矩阵</h2>
<h3 id="伴随矩阵的求法">伴随矩阵的求法</h3>
<ul>
<li>定义法
<ul>
<li>伴随矩阵的第<span class="math inline">\(i\)</span>行第<span class="math inline">\(j\)</span>列的值是原矩阵第<span class="math inline">\(j\)</span>行第<span class="math inline">\(i\)</span>列的代数余子式</li>
<li>注意这里有一个转置操作</li>
</ul></li>
<li>性质法
<ul>
<li><span class="math inline">\(\pmb{A}\pmb{A}^\star=|\pmb{A}|\pmb{E}\)</span></li>
<li>注意这种方法求伴随矩阵要求<span class="math inline">\(\pmb{A}\)</span>可逆，此时<span class="math inline">\(\pmb{A}^\star=|\pmb{A}|\pmb{A}^{-1}\)</span></li>
</ul></li>
</ul>
<h3 id="伴随矩阵相关证明">伴随矩阵相关证明</h3>
<ul>
<li>思路
<ul>
<li>一般会用到伴随矩阵的性质<span class="math inline">\(\pmb{A}\pmb{A}^\star=\pmb{A}^\star\pmb{A}=|\pmb{A}|\pmb{E}\)</span>出发</li>
<li>结合矩阵运算法则</li>
<li>一般会用到表达式中其他操作的定义</li>
</ul></li>
<li>举例：证明<span class="math inline">\((\pmb{A}^\star)^{-1}=(\pmb{A^{-1}})^\star\)</span>
<ul>
<li>即证明<span class="math inline">\(\pmb{A}^\star(\pmb{A^{-1}})^\star=\pmb{E}\)</span>（可逆操作的定义）</li>
<li>即证明<span class="math inline">\(\pmb{A}\pmb{A}^\star(\pmb{A^{-1}})^\star\pmb{A}^{-1}=\pmb{E}\)</span>（矩阵基本左乘右乘法则）</li>
<li>即证明<span class="math inline">\((|\pmb{A}|\pmb{E})(|\pmb{A}|^{-1}\pmb{E})=|\pmb{A}\pmb{A}^{-1}|\pmb{E}=\pmb{E}\)</span>（伴随矩阵的性质、行列式运算法则）</li>
</ul></li>
</ul>
<h2 id="初等变换">初等变换</h2>
<ul>
<li>初等变换
<ul>
<li>倍乘变换</li>
<li>互换变换</li>
<li>倍加变换</li>
</ul></li>
<li>初等矩阵：对单位矩阵初等变换
<ul>
<li>倍乘矩阵</li>
<li>互换矩阵</li>
<li>倍加矩阵</li>
</ul></li>
<li>常用性质
<ul>
<li>性质1：左（右）乘初等矩阵<span class="math inline">\(\Leftrightarrow\)</span>作对应的初等行（列）变换，不改变矩阵的型和秩</li>
<li>性质2：可逆矩阵可以表示为有限个初等矩阵的乘积，即可以通过初等行变换转换为单位矩阵
<ul>
<li>后面矩阵初等变换分解的一个推论</li>
</ul></li>
<li>性质3：两个矩阵是等价矩阵（关系符号是<span class="math inline">\(\cong\)</span>）<span class="math inline">\(\Leftrightarrow\)</span>两个矩阵可以通过有限次初等变换相互转换<span class="math inline">\(\Leftrightarrow\)</span>两个矩阵同型且秩相同
<ul>
<li>第一个到第二个：等价矩阵的定义</li>
<li>第二个到第三个：初等变换不改变矩阵的型和秩</li>
<li>第三个到第二个：先用矩阵的初等变换分解，再利用左右乘初等矩阵等价于作相应初等变换</li>
</ul></li>
</ul></li>
</ul>
<h2 id="可逆矩阵">可逆矩阵</h2>
<h3 id="判断矩阵是否可逆">判断矩阵是否可逆</h3>
<p><em>该问题是行列式一章中，判断行列式是否为0的镜像问题</em></p>
<p>下面条件是等价的</p>
<ul>
<li><strong>行列式</strong>：<span class="math inline">\(|\pmb{A}|\neq
0\)</span></li>
<li><strong>矩阵</strong>：<span class="math inline">\(\pmb{A}\)</span>可逆，即存在<span class="math inline">\(\pmb{B}\)</span>，使得<span class="math inline">\(\pmb{A}\pmb{B}=\pmb{E}\)</span></li>
<li><strong>秩</strong>：<span class="math inline">\(r(\pmb{A})=n\)</span></li>
<li><strong>向量</strong>：<span class="math inline">\(\pmb{A}\)</span>的各行（列）向量线性无关</li>
<li><strong>线性方程组</strong>：<span class="math inline">\(\pmb{Ax}=\pmb{0}\)</span>有唯一零解（根据线性方程组解的结构也可以说<span class="math inline">\(\pmb{Ax}=\pmb{b}\)</span>有唯一解）</li>
<li><strong>特征值</strong>：所有特征值<span class="math inline">\(\lambda_i\neq 0\)</span></li>
</ul>
<h3 id="求逆矩阵基本思路">求逆矩阵基本思路</h3>
<ul>
<li>利用伴随矩阵的性质
<ul>
<li><span class="math inline">\(\pmb{A}\pmb{A}^\star=|\pmb{A}|\pmb{E}\Rightarrow
\pmb{A}^{-1}=\frac{\pmb{A}^\star}{|\pmb{A}|}\)</span></li>
</ul></li>
<li>初等变换法
<ul>
<li><span class="math inline">\((\pmb{A},\pmb{E})\)</span>经过初等变换<span class="math inline">\((\pmb{E},\pmb{A}^{-1})\)</span></li>
</ul></li>
<li>可逆矩阵定义法
<ul>
<li>存在<span class="math inline">\(\pmb{B}\)</span>，使得<span class="math inline">\(\pmb{A}\pmb{B}=\pmb{E}\)</span></li>
</ul></li>
<li>已知<span class="math inline">\(\pmb{A}^n=\pmb{O}\)</span>
<ul>
<li>根据<span class="math inline">\(\pmb{E}=\pmb{E}^n-\pmb{A}^n=(\pmb{E}-\pmb{A})(\pmb{E}+\pmb{A}+\cdots+\pmb{A}^{n-1})\)</span>和可逆矩阵定义，可以得到<span class="math inline">\(\pmb{E}-\pmb{A}\)</span>的逆矩阵</li>
</ul></li>
</ul>
<h2 id="秩的相关结论和证明">秩的相关结论和证明</h2>
<p><em>本节利用线性方程组或向量组来证明结论，理解本节有利于思考其他的和秩有关的证明题</em></p>
<ul>
<li>结论1：<span class="math inline">\(\pmb{A}\)</span>有<span class="math inline">\(n\)</span>列，<span class="math inline">\(\pmb{B}\)</span>有<span class="math inline">\(n\)</span>行，<span class="math inline">\(\pmb{A}\pmb{B}=0\Rightarrow
r(\pmb{A})+r(\pmb{B})\leq n\)</span>，从线性方程组角度证明：
<ul>
<li>根据<span class="math inline">\(\pmb{B}\)</span>的每一列都是齐线性方程组<span class="math inline">\(\pmb{A}\pmb{x}=\pmb{0}\)</span>的解向量</li>
<li>线性无关的解向量个数为<span class="math inline">\(n-r(\pmb{A})\Rightarrow r(\pmb{B})\leq
n-r(\pmb{A})\)</span></li>
</ul></li>
<li>结论2：<span class="math inline">\(r(\pmb{A}^T\pmb{A})=r(\pmb{A})\)</span>，从线性方程组角度证明：
<ul>
<li><span class="math inline">\(\pmb{A}\pmb{x}=\pmb{0}\)</span>的解向量是<span class="math inline">\(\pmb{A}^T\pmb{A}\pmb{x}=\pmb{0}\)</span>的解向量
<ul>
<li>因为<span class="math inline">\(\pmb{A}^T\pmb{A}\pmb{x}=\pmb{A}^T\pmb{0}=\pmb{0}\)</span></li>
</ul></li>
<li><span class="math inline">\(\pmb{A}^T\pmb{A}\pmb{x}=\pmb{0}\)</span>的解向量是<span class="math inline">\(\pmb{A}\pmb{x}=\pmb{0}\)</span>的解向量
<ul>
<li>因为<span class="math inline">\(\pmb{x}^T\pmb{A}^T\pmb{A}\pmb{x}=(\pmb{Ax})^T(\pmb{Ax})=0\Rightarrow
\pmb{Ax}=\pmb{0}\)</span></li>
</ul></li>
</ul></li>
<li>结论3：<span class="math inline">\(r(\pmb{A}+\pmb{B})\leq
r(\pmb{A})+r(\pmb{B})\)</span>，从列向量组角度证明：
<ul>
<li><span class="math inline">\(\pmb{A}\)</span>的所有列向量和<span class="math inline">\(\pmb{B}\)</span>的所有列向量组构成的列向量组秩<span class="math inline">\(r\)</span>不超过<span class="math inline">\(r(\pmb{A})+r(\pmb{B})\)</span></li>
<li><span class="math inline">\(\pmb{A}+\pmb{B}\)</span>的列向量都是<span class="math inline">\(\pmb{A}\)</span>的列向量和<span class="math inline">\(\pmb{B}\)</span>的列向量的线性组合，则<span class="math inline">\(r(\pmb{A}+\pmb{B})\leq
r(\pmb{A})+r(\pmb{B})\)</span></li>
</ul></li>
<li>结论4：<span class="math inline">\(r(\pmb{A}\pmb{B})\leq
\min\{r(\pmb{A}),r(\pmb{B})\}\)</span>，从线性方程组角度证明：
<ul>
<li><span class="math inline">\(\pmb{B}\pmb{x}=\pmb{0}\)</span>的解向量是<span class="math inline">\(\pmb{A}\pmb{B}\pmb{x}=\pmb{0}\)</span>的解向量
<ul>
<li>因此<span class="math inline">\(r(\pmb{A}\pmb{B})\leq
r(\pmb{B})\)</span></li>
</ul></li>
<li><span class="math inline">\(r(\pmb{A}\pmb{B})=r(\pmb{B}^T\pmb{A}^T)\leq
\pmb{A}^T=\pmb{A}\)</span>
<ul>
<li>因此<span class="math inline">\(r(\pmb{A}\pmb{B})\leq
r(\pmb{A})\)</span></li>
</ul></li>
</ul></li>
<li>结论5：<span class="math inline">\(r(\pmb{A})=n\Rightarrow
r(\pmb{A}^\star)=n\)</span>，根据伴随矩阵性质以及结论4证明
<ul>
<li><span class="math inline">\(n= r(\pmb{A})\geq
r(\pmb{A}\pmb{A}^\star)=r(|\pmb{A}|\pmb{E})=n\)</span></li>
</ul></li>
<li>结论6：<span class="math inline">\(r(\pmb{A})=n-1\Rightarrow
r(\pmb{A}^\star)=1\)</span>，根据伴随矩阵定义、性质以及结论1证明
<ul>
<li><span class="math inline">\(r(\pmb{A}\pmb{A}^\star)=r(|\pmb{A}|\pmb{E})=0\Rightarrow
r(\pmb{A}^\star)\leq n-r(\pmb{A})=1\)</span></li>
<li><span class="math inline">\(r(\pmb{A})\)</span>有<span class="math inline">\(n-1\)</span>阶子式行列式非零，则<span class="math inline">\(r(\pmb{A})^\star\geq 1\)</span></li>
</ul></li>
<li>结论7：<span class="math inline">\(r(\pmb{A})&lt;n-1\Rightarrow
r(\pmb{A}^\star)=0\)</span>，根据伴随矩阵定义证明
<ul>
<li><span class="math inline">\(r(\pmb{A})\)</span>所有<span class="math inline">\(n-1\)</span>阶子式行列式为零，则<span class="math inline">\(r(\pmb{A})^\star=0\)</span></li>
</ul></li>
</ul>
<h2 id="矩阵的分解">矩阵的分解</h2>
<h3 id="矩阵的向量乘法分解">矩阵的向量乘法分解</h3>
<p><em>把矩阵分解为向量矩阵的乘积</em></p>
<ul>
<li>设<span class="math inline">\(r(\pmb{A})=1\)</span>，则<span class="math inline">\(\pmb{A}=\begin{bmatrix}
a_1b_1&amp;a_1b_2&amp;\cdots&amp;a_1b_n\\ a_2b_1 &amp;a_2b_2 &amp;\cdots
&amp;a_2b_n \\ \vdots &amp;\vdots&amp; \  &amp;\vdots\\
a_nb_1&amp;a_nb_2&amp;\cdots&amp;a_nb_n
\end{bmatrix}\)</span>可以分解为两个向量矩阵的乘积<span class="math inline">\(\pmb{\alpha}\pmb{\beta}^T=\begin{bmatrix} a_1\\
a_2 \\ \vdots \\ a_n\end{bmatrix} \begin{bmatrix}
b_1&amp;b_2&amp;\cdots&amp;b_n\end{bmatrix}\)</span></li>
<li>作用1：矩阵的迹<span class="math inline">\(tr(\pmb{A})=\pmb{\alpha}^T\pmb{\beta}=\pmb{\beta}^T\pmb{\alpha}=\begin{bmatrix}
b_1&amp;b_2&amp;\cdots&amp;b_n\end{bmatrix} \begin{bmatrix} a_1\\ a_2 \\
\vdots \\ a_n\end{bmatrix}\)</span></li>
<li>作用2：<span class="math inline">\(\pmb{A}^n=(\pmb{\alpha}\pmb{\beta}^T)^n=\pmb{\alpha}(\pmb{\beta}^T\pmb{\alpha})^{n-1}\pmb{\beta}=tr(\pmb{A})^{n-1}\pmb{A}\)</span></li>
</ul>
<h3 id="矩阵的加法分解">矩阵的加法分解</h3>
<ul>
<li>分解操作为：<span class="math inline">\(\pmb{A}=\pmb{B}+\pmb{C}\)</span></li>
<li>常见的用法
<ul>
<li>求<span class="math inline">\(\pmb{A}\)</span>的高次幂：<span class="math inline">\(\pmb{A}^n=(\pmb{B}+\pmb{E})^n\)</span>，结合二项式定理计算</li>
<li>把行列式计算问题转化为求特征值问题：<span class="math inline">\(|\pmb{A}|=|\lambda\pmb{E}-\pmb{B}|=\prod\limits_{i=1}^n(\lambda-\lambda_i)\)</span>
<ul>
<li><span class="math inline">\(\lambda\)</span>是已知量，在<span class="math inline">\(\pmb{A}\)</span>被分解后即可确定</li>
<li><span class="math inline">\(\lambda_i\)</span>是<span class="math inline">\(\pmb{B}\)</span>的特征值</li>
</ul></li>
</ul></li>
</ul>
<h3 id="矩阵的初等变换分解">矩阵的初等变换分解</h3>
<ul>
<li>已知<span class="math inline">\(m\times n\)</span>矩阵<span class="math inline">\(\pmb{A}\)</span>的秩为<span class="math inline">\(r\)</span>，则
<ul>
<li><span class="math inline">\(\pmb{A}\)</span>的等价标准形是<span class="math inline">\(\pmb{\Lambda}= \begin{bmatrix}\pmb{E}_r&amp;
\pmb{O}_{r\times (n-r)}\\\pmb{O}_{(m-r)\times r} &amp;
\pmb{O}_{(m-r)\times (n-r)} \end{bmatrix}\)</span></li>
<li>存在可逆矩阵<span class="math inline">\(\pmb{P}\)</span>和<span class="math inline">\(\pmb{Q}\)</span>，使得<span class="math inline">\(\pmb{A}=\pmb{P}\pmb{\Lambda}\pmb{Q}\)</span></li>
</ul></li>
</ul>
<h3 id="矩阵的相似对角化分解">矩阵的相似对角化分解</h3>
<ul>
<li>根据特征值的定义
<ul>
<li><span class="math inline">\(\pmb{A}\pmb{\alpha}_i=\lambda_i
\pmb{\alpha}_i\)</span></li>
<li><span class="math inline">\(\pmb{A}\)</span>的特征向量为<span class="math inline">\(\pmb{\alpha}_1,\pmb{\alpha}_2,\cdots,\pmb{\alpha}_n\)</span></li>
<li>特征矩阵<span class="math inline">\(\pmb{P}=\begin{bmatrix}\pmb{\alpha}_1,\pmb{\alpha}_2,\cdots,\pmb{\alpha}_n
\end{bmatrix}\)</span></li>
</ul></li>
<li><span class="math inline">\(\pmb{A}\pmb{P}=\begin{bmatrix}\pmb{A}\pmb{\alpha}_1,\pmb{A}\pmb{\alpha}_2,\cdots,\pmb{A}\pmb{\alpha}_n
\end{bmatrix} =
\begin{bmatrix}\pmb{\alpha}_1,\pmb{\alpha}_2,\cdots,\pmb{\alpha}_n
\end{bmatrix} diag\{\lambda_1,\lambda_2,\cdots,\lambda_n\}\)</span></li>
<li><span class="math inline">\(\pmb{A}\pmb{P}=\pmb{P}diag\{\lambda_1,\lambda_2,\cdots,\lambda_n\}\)</span></li>
<li>当<span class="math inline">\(\pmb{P}\)</span>可逆时，<span class="math inline">\(\pmb{A}=\pmb{P}diag\{\lambda_1,\lambda_2,\cdots,\lambda_n\}\pmb{P}^{-1}\)</span></li>
</ul>
<h3 id="矩阵的分块分解">矩阵的分块分解</h3>
<ul>
<li>含义：把矩阵分块为行向量或列向量</li>
<li>应用：主要和其他问题结合使用，详见后面的“矩阵乘法分解”、“矩阵乘法等式转化”</li>
</ul>
<h3 id="矩阵的矩阵乘法分解">矩阵的矩阵乘法分解</h3>
<ul>
<li>含义：矩阵以行（列）向量分块分解的形式给出，可以将其分解为两个矩阵的乘积</li>
<li>方法：比如矩阵<span class="math inline">\(\pmb{A}\)</span>以列向量分块分解形式给出
<ul>
<li><span class="math inline">\(\pmb{A}\)</span>的列向量的极大无关组按列排成矩阵<span class="math inline">\(\pmb{B}\)</span></li>
<li>因为极大无关组可以表示原向量组，因此<span class="math inline">\(\pmb{A}\)</span>可以分解为<span class="math inline">\(\pmb{B}\)</span>和一个矩阵的乘积</li>
</ul></li>
<li>举例：<span class="math inline">\(\begin{bmatrix}\pmb{\alpha}_1,\pmb{\alpha}_2-\pmb{\alpha}_1,2\pmb{\alpha}_3
\end{bmatrix} =
\begin{bmatrix}\pmb{\alpha}_1,\pmb{\alpha}_2,\pmb{\alpha}_3
\end{bmatrix} \begin{bmatrix}1&amp;-1&amp;0\\ 0&amp;1&amp;0\\
0&amp;0&amp; 2 \end{bmatrix}\)</span></li>
</ul>
<h2 id="矩阵的乘法">矩阵的乘法</h2>
<h3 id="对角矩阵的乘法">对角矩阵的乘法</h3>
<ul>
<li><span class="math inline">\(\begin{bmatrix} a_1&amp;\ &amp;\ &amp;\
\\ \ &amp;a_2\ &amp;\ \\ \ &amp;\ &amp; \ddots &amp;\ \\ \ &amp;\ &amp;\
&amp;a_n \end{bmatrix} \begin{bmatrix} b_1&amp;\ &amp;\ &amp;\ \\ \
&amp;b_2\ &amp;\ \\ \ &amp;\ &amp; \ddots &amp;\ \\ \ &amp;\ &amp;\
&amp;b_n \end{bmatrix} =\begin{bmatrix} a_1b_1&amp;\ &amp;\ &amp;\ \\ \
&amp;a_2b_2\ &amp;\ \\ \ &amp;\ &amp; \ddots &amp;\ \\ \ &amp;\ &amp;\
&amp;a_nb_n \end{bmatrix}\)</span></li>
<li>推广1：对角矩阵的高次幂运算</li>
<li>推广2：对角矩阵的逆矩阵求解</li>
<li>推广3：分块对角矩阵的乘法、幂运算</li>
</ul>
<h3 id="求矩阵的高次幂">求矩阵的高次幂</h3>
<ul>
<li>向量乘法分解法
<ul>
<li>前面矩阵向量乘法分解小节提到过</li>
<li>当<span class="math inline">\(r(\pmb{A})=1\)</span>，<span class="math inline">\(\pmb{A}^n=tr(\pmb{A})^{n-1}\pmb{A}\)</span></li>
</ul></li>
<li>加法分解法
<ul>
<li>前面矩阵加法分解小节提到过</li>
<li><span class="math inline">\(\pmb{A}^n=(\pmb{B}+\pmb{E})^n\)</span></li>
<li>需要再使用<strong>二项式定理</strong>展开</li>
</ul></li>
<li>对角分块矩阵法
<ul>
<li>前面对角矩阵乘法小节提到过</li>
<li><span class="math inline">\(\begin{bmatrix} \pmb{A_1}&amp;\ &amp;\
&amp;\ \\ \ &amp;\pmb{A_2}\ &amp;\ \\ \ &amp;\ &amp; \ddots &amp;\ \\ \
&amp;\ &amp;\ &amp;\pmb{A_n} \end{bmatrix} ^n= \begin{bmatrix}
\pmb{A_1}^n&amp;\ &amp;\ &amp;\ \\ \ &amp;\pmb{A_2}^n\ &amp;\ \\ \
&amp;\ &amp; \ddots &amp;\ \\ \ &amp;\ &amp;\ &amp;\pmb{A_n}^n
\end{bmatrix}\)</span></li>
</ul></li>
<li>相似对角化分解法
<ul>
<li>前面相似对角分解小节提到过</li>
<li>当矩阵有n个线性无关的特征向量，把矩阵相似对角化后再计算高次幂</li>
</ul></li>
<li>规律归纳法
<ul>
<li>当矩阵秩不高的时候，尝试计算几次幂，找规律</li>
<li>如果需要严格证明，则使用数学归纳法</li>
</ul></li>
</ul>
<h3 id="矩阵乘法的转化">矩阵乘法的转化</h3>
<p><em>使用前面所说的矩阵的分块分解法，把矩阵乘法等式条件，转化为等价的条件形式，方便处理</em></p>
<h4 id="转化为线性方程组条件">转化为线性方程组条件</h4>
<ul>
<li>矩阵乘法等式：<span class="math inline">\(\pmb{A}\pmb{B}=\pmb{0}\)</span></li>
<li>转化方法
<ul>
<li>把<span class="math inline">\(\pmb{A}\)</span>和<span class="math inline">\(\pmb{0}\)</span>分块为行向量，<span class="math inline">\(\pmb{A}\)</span>的每一行都是齐次线性方程组<span class="math inline">\(\pmb{x}^{T}\pmb{B}=\pmb{0}^{T}\)</span>的解</li>
<li>或把<span class="math inline">\(\pmb{B}\)</span>和<span class="math inline">\(\pmb{0}\)</span>分块为列向量，<span class="math inline">\(\pmb{B}\)</span>的每一列都是齐次线性方程组<span class="math inline">\(\pmb{A}\pmb{x}=\pmb{0}\)</span>的解</li>
</ul></li>
</ul>
<h4 id="转化为向量组线性表示条件">转化为向量组线性表示条件</h4>
<ul>
<li>矩阵乘法等式：<span class="math inline">\(\pmb{A}\pmb{B}=\pmb{C}\)</span></li>
<li>转化方法
<ul>
<li>把<span class="math inline">\(\pmb{A}\)</span>和<span class="math inline">\(\pmb{C}\)</span>分块为列向量，<span class="math inline">\(\pmb{C}\)</span>的列向量都可以由<span class="math inline">\(\pmb{A}\)</span>的列向量线性表示
<ul>
<li>可以结合前面的<strong>矩阵的矩阵乘法分解</strong>小节的例子进行思考</li>
<li><span class="math inline">\(\begin{bmatrix}\pmb{\alpha}_1,\pmb{\alpha}_2-\pmb{\alpha}_1,2\pmb{\alpha}_3
\end{bmatrix} =
\begin{bmatrix}\pmb{\alpha}_1,\pmb{\alpha}_2,\pmb{\alpha}_3
\end{bmatrix} \begin{bmatrix}1&amp;-1&amp;0\\ 0&amp;1&amp;0\\
0&amp;0&amp; 2 \end{bmatrix}\)</span></li>
</ul></li>
<li>或把<span class="math inline">\(\pmb{B}\)</span>和<span class="math inline">\(\pmb{C}\)</span>分块为行向量，<span class="math inline">\(\pmb{C}\)</span>的行向量都可以由<span class="math inline">\(\pmb{B}\)</span>的行向量线性表示</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第四章-线性方程组</title>
    <url>/2021/11/20/linearAlgebra4/</url>
    <content><![CDATA[<ul>
<li>本知识总结不提供完整的理论体系汇总，旨在给出<em>概念的理解</em>以及<em>各类问题的思考框架</em>。</li>
<li>笔记为个人整理，禁止商业用途</li>
<li>如有疏漏，欢迎留言</li>
</ul>
<h2 id="克拉姆法则">克拉姆法则</h2>
<ul>
<li>克拉姆法则
<ul>
<li>当且仅当<span class="math inline">\(\vert\pmb{A}\vert\neq
0\)</span>，方程<span class="math inline">\(\pmb{A}\pmb{x}=\pmb{b}\)</span>的唯一解是<span class="math inline">\(x_i=\frac{\vert\pmb{A}_i\vert}{\vert\pmb{A}\vert},i=1,2,\cdots,n\)</span></li>
<li>其中<span class="math inline">\(\vert\pmb{A}_i\vert\)</span>的第<span class="math inline">\(i\)</span>列是右端向量<span class="math inline">\(\pmb{b}\)</span>，其他列同<span class="math inline">\(\pmb{A}\)</span></li>
</ul></li>
<li><span class="math inline">\(\vert\pmb{A}\vert\neq
0\)</span>则方程有唯一解的原理
<ul>
<li><span class="math inline">\(\pmb{x}=\pmb{A}^{-1}\pmb{b}=\frac{\pmb{A}^{\star}\pmb{b}}{|\pmb{A}|}\)</span></li>
<li><span class="math inline">\(x_i=\frac{\begin{bmatrix}A_{1i}&amp;
A_{2i}&amp; \cdots&amp; A_{ni} \end{bmatrix}
\pmb{b}}{|\pmb{A}|}=\frac{\vert\pmb{A}_i\vert}{\vert\pmb{A}\vert}\)</span></li>
<li>由此直接把唯一解算出来了</li>
</ul></li>
<li><span class="math inline">\(\vert\pmb{A}\vert=
0\)</span>则方程无解或无穷解的原理
<ul>
<li>把不可逆矩阵<span class="math inline">\(\pmb{A}\)</span>可看作不可逆线性变换，理解成单射（没有逆映射）</li>
<li>没有逆映射有两种原因
<ul>
<li>新坐标系中的向量<span class="math inline">\(\pmb{b}\)</span>无法映射到原坐标系的向量（对应方程组无解情况）</li>
<li>新坐标系中的向量<span class="math inline">\(\pmb{b}\)</span>映射到原坐标系的多个向量（对应方程组无穷解情况）</li>
</ul></li>
</ul></li>
<li>线性方程组的主要运算在于求逆矩阵
<ul>
<li>因为求逆矩阵时，伴随矩阵法比初等变换法复杂得多，很少使用</li>
<li>所以解线性方程组时，克拉姆法则比高斯消元法复杂得多，很少使用</li>
</ul></li>
</ul>
<h2 id="齐次线性方程组">齐次线性方程组</h2>
<ul>
<li>形式:<span class="math inline">\(\pmb{A}_{m\times
n}\pmb{x}=\pmb{0}\)</span></li>
<li>有解条件：一定有零解</li>
<li>基础解系
<ul>
<li>所有解向量的极大线性无关组</li>
<li>课本的表述为线性无关，且可以线性表出所有解向量的向量组</li>
<li>一定是<span class="math inline">\(n\)</span>维非零向量</li>
</ul></li>
<li>基础解系向量个数
<ul>
<li><span class="math inline">\(n-r(\pmb{A})\)</span></li>
<li>从向量空间角度理解
<ul>
<li>基础解系，就是找到所有的线性无关的非零列向量，和<span class="math inline">\(\pmb{A}\)</span>的行向量正交</li>
<li>本质是，在<span class="math inline">\(n\)</span>维度向量空间中，正交于<span class="math inline">\(r(\pmb{A})\)</span>维子空间（由<span class="math inline">\(\pmb{A}\)</span>行向量张成）的非零且线性无关的向量有<span class="math inline">\(n-r(\pmb{A})\)</span>个</li>
<li>例如三维空间中，和某个二维平面垂直的线性无关非零向量，最多找到一个</li>
</ul></li>
</ul></li>
<li>通解：由基础解系线性表出即可</li>
<li>通解求法
<ul>
<li>初等行变换把<span class="math inline">\(\pmb{A}\)</span>变成行阶梯型矩阵
<ul>
<li>接下来只需要解同解方程组</li>
<li>本质就是高斯消元法</li>
</ul></li>
<li><span class="math inline">\(r\)</span>个独立变量和<span class="math inline">\(n-r\)</span>个自由变量
<ul>
<li>每次只选一个自由变量取<span class="math inline">\(1\)</span>，其他取<span class="math inline">\(0\)</span>，算出独立变量，得到一个解向量</li>
<li>选<span class="math inline">\(n-r\)</span>次自由变量，得到基础解系</li>
</ul></li>
</ul></li>
</ul>
<h2 id="非齐次线性方程组">非齐次线性方程组</h2>
<ul>
<li>形式:<span class="math inline">\(\pmb{A}_{m\times
n}\pmb{x}=\pmb{b}\)</span></li>
<li>有解等价条件：<span class="math inline">\(r(\pmb{A})=r(\pmb{A},b)\)</span></li>
<li>解的性质：两个解的差值是对应齐次线性方程组的解</li>
<li>通解结构：找到一个特解，再加上对应齐次线性方程组的通解</li>
<li>通解求法
<ul>
<li>初等行变换把<span class="math inline">\(\pmb{A}\)</span>变成行阶梯型矩阵
<ul>
<li>接下来只需要解同解方程组</li>
</ul></li>
<li><span class="math inline">\(r\)</span>个独立变量和<span class="math inline">\(n-r\)</span>个自由变量
<ul>
<li>自由变量取<span class="math inline">\(0\)</span>，算出一个特解</li>
<li>每个自由变量分别取<span class="math inline">\(1\)</span>，算出对应齐次线性方程组基础解系</li>
</ul></li>
<li>利用非齐次线性方程组的通解结构即可</li>
</ul></li>
</ul>
<h2 id="由基础解系求方程组">由基础解系求方程组</h2>
<ul>
<li>已知<span class="math inline">\(m\)</span>个方程<span class="math inline">\(n\)</span>个未知量的齐次线性方程组的基础解系为<span class="math inline">\(\pmb{\xi}_1,\pmb{\xi}_2,\cdots,\pmb{\xi}_k\)</span></li>
<li>即<span class="math inline">\(\pmb{A}_{m\times
n}\begin{bmatrix}\pmb{\xi}_1&amp;\pmb{\xi}_2&amp;\cdots&amp;\pmb{\xi}_k
\end{bmatrix} =\pmb{O}_{m\times k}\)</span></li>
<li>即<span class="math inline">\(\begin{bmatrix}\pmb{\xi}_1^T\\
\pmb{\xi}_2^T\\ \vdots \\ \pmb{\xi}_k^T \end{bmatrix} \pmb{A}^T_{n\times
m}=\pmb{O}_{k\times m}\)</span></li>
<li>新方程解出来的基础解系的向量个数为<span class="math inline">\(n-k=n-(n-r(\pmb{A}))=r(\pmb{A})\)</span>
<ul>
<li>可以根据该基础解系确定原方程的系数矩阵行向量</li>
</ul></li>
</ul>
<h2 id="两个方程组的公共解">两个方程组的公共解</h2>
<ul>
<li>法一：直接解联立方程组</li>
<li>法二：先解一个方程组，再代入另一个方程组</li>
<li>法三：分别解两个方程组得到各自的通解，令两个通解相等，解关于通解的参数的方程组</li>
</ul>
<h2 id="同解方程组">同解方程组</h2>
<ul>
<li>定义法（推荐使用）：证明一个方程组的解也是另一个方程组的解（两个方向都要证明）</li>
<li>初等行变换：只经过初等行变换（不改变方程的解），可以将两个方程组的（系数矩阵和右端向量的）增广矩阵相互转换，则说明是同解方程组</li>
<li>线性表示法：两个方程组的增广矩阵的行向量相互可以线性表出</li>
</ul>
<h2 id="解线性方程组应用于可逆矩阵">解线性方程组应用于可逆矩阵</h2>
<p>补充一个技巧：计算<span class="math inline">\(\pmb{A}^{-1}\pmb{B}\)</span>可以规约为解方程<span class="math inline">\(\pmb{A}\pmb{X}=\pmb{B}\)</span></p>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第三章-向量</title>
    <url>/2021/11/17/linearAlgebra3/</url>
    <content><![CDATA[<ul>
<li>本知识总结不提供完整的理论体系汇总，旨在给出<em>概念的理解</em>以及<em>各类问题的思考框架</em>。</li>
<li>笔记为个人整理，禁止商业用途</li>
<li>如有疏漏，欢迎留言</li>
</ul>
<h2 id="向量的表示">向量的表示</h2>
<ul>
<li>一般默认是列向量，比如<span class="math inline">\(\pmb{\alpha}=(a_1,a_2,\cdots,a_n)^T\)</span></li>
<li>行向量需要转置列向量，比如<span class="math inline">\(\pmb{\alpha}^{T}=(a_1,a_2,\cdots,a_n)\)</span></li>
<li>在计算时，对向量的行、列判断要清晰</li>
</ul>
<h2 id="线性相关性">线性相关性</h2>
<ul>
<li>线性相关的等价条件
<ul>
<li>存在不全为<span class="math inline">\(0\)</span>的数<span class="math inline">\(k_1,\cdots,k_n\)</span>，使得<span class="math inline">\(k_1\pmb{\alpha}_1+\cdots+k_n\pmb{\alpha}_n=\pmb{0}\)</span></li>
<li>存在不全为<span class="math inline">\(0\)</span>的数<span class="math inline">\(k_1,\cdots,k_n\)</span>，使得<span class="math inline">\(\begin{bmatrix}\pmb{\alpha}_1 &amp;
\pmb{\alpha}_2&amp; \cdots &amp;\pmb{\alpha}_n \end{bmatrix}
\begin{bmatrix}k_1\\k_2\\\vdots\\k_n \end{bmatrix}
=\pmb{0}\)</span></li>
<li><span class="math inline">\(\begin{bmatrix}\pmb{\alpha}_1 &amp;
\pmb{\alpha}_2&amp; \cdots &amp;\pmb{\alpha}_n
\end{bmatrix}\)</span>的秩小于<span class="math inline">\(n\)</span>（根据齐次线性方程组知识）</li>
<li>第一章行列式为<span class="math inline">\(0\)</span>的等价条件都适合此处</li>
</ul></li>
<li>线性无关的等价条件
<ul>
<li>不存在不全为<span class="math inline">\(0\)</span>的数<span class="math inline">\(k_1,\cdots,k_n\)</span>，使得<span class="math inline">\(k_1\pmb{\alpha}_1+\cdots+k_n\pmb{\alpha}_n=\pmb{0}\)</span></li>
<li>不存在不全为<span class="math inline">\(0\)</span>的数<span class="math inline">\(k_1,\cdots,k_n\)</span>，使得<span class="math inline">\(\begin{bmatrix}\pmb{\alpha}_1 &amp;
\pmb{\alpha}_2&amp; \cdots &amp;\pmb{\alpha}_n \end{bmatrix}
\begin{bmatrix}k_1\\k_2\\\vdots\\k_n \end{bmatrix}
=\pmb{0}\)</span></li>
<li><span class="math inline">\(\begin{bmatrix}\pmb{\alpha}_1 &amp;
\pmb{\alpha}_2&amp; \cdots &amp;\pmb{\alpha}_n
\end{bmatrix}\)</span>的秩等于<span class="math inline">\(n\)</span>（根据齐次线性方程组知识）</li>
<li>第二章可逆矩阵的等价条件都适合此处</li>
</ul></li>
</ul>
<h2 id="线性表出">线性表出</h2>
<ul>
<li>一个向量<span class="math inline">\(\pmb{\beta}\)</span>可以用一个向量组<span class="math inline">\(\pmb{\alpha}_1,\cdots,\pmb{\alpha}_n\)</span>线性表出的等价条件
<ul>
<li>存在实数<span class="math inline">\(k_1,\cdots,k_n\)</span>，使得<span class="math inline">\(k_1\pmb{\alpha}_1+\cdots+k_n\pmb{\alpha}_n=\pmb{\beta}\)</span></li>
<li>存在实数<span class="math inline">\(k_1,\cdots,k_n\)</span>，使得<span class="math inline">\(\begin{bmatrix}\pmb{\alpha}_1 &amp;
\pmb{\alpha}_2&amp; \cdots &amp;\pmb{\alpha}_n \end{bmatrix}
\begin{bmatrix}k_1\\k_2\\\vdots\\k_n \end{bmatrix}
=\pmb{\beta}\)</span></li>
<li><span class="math inline">\(\begin{bmatrix}\pmb{\alpha}_1 &amp;
\pmb{\alpha}_2&amp; \cdots &amp;\pmb{\alpha}_n
\end{bmatrix}\)</span>和<span class="math inline">\(\begin{bmatrix}\pmb{\alpha}_1 &amp;
\pmb{\alpha}_2&amp; \cdots &amp;\pmb{\alpha}_n &amp;
\pmb{\beta}\end{bmatrix}\)</span>的秩相同（根据非齐次线性方程组知识）</li>
</ul></li>
<li>一个向量<span class="math inline">\(\pmb{\beta}\)</span>不可以用一个向量组<span class="math inline">\(\pmb{\alpha}_1,\cdots,\pmb{\alpha}_n\)</span>线性表出的等价条件
<ul>
<li>不存在实数<span class="math inline">\(k_1,\cdots,k_n\)</span>，使得<span class="math inline">\(k_1\pmb{\alpha}_1+\cdots+k_n\pmb{\alpha}_n=\pmb{\beta}\)</span></li>
<li>不存在实数<span class="math inline">\(k_1,\cdots,k_n\)</span>，使得<span class="math inline">\(\begin{bmatrix}\pmb{\alpha}_1 &amp;
\pmb{\alpha}_2&amp; \cdots &amp;\pmb{\alpha}_n \end{bmatrix}
\begin{bmatrix}k_1\\k_2\\\vdots\\k_n \end{bmatrix}
=\pmb{\beta}\)</span></li>
<li><span class="math inline">\(\begin{bmatrix}\pmb{\alpha}_1 &amp;
\pmb{\alpha}_2&amp; \cdots &amp;\pmb{\alpha}_n
\end{bmatrix}\)</span>和<span class="math inline">\(\begin{bmatrix}\pmb{\alpha}_1 &amp;
\pmb{\alpha}_2&amp; \cdots &amp;\pmb{\alpha}_n &amp;
\pmb{\beta}\end{bmatrix}\)</span>的秩不相同（根据非齐次线性方程组知识）</li>
</ul></li>
<li>一个向量组<span class="math inline">\(\pmb{\beta}_1, \cdots
,\pmb{\beta}_n\)</span>可以用一个向量组<span class="math inline">\(\pmb{\alpha}_1,\cdots,\pmb{\alpha}_n\)</span>线性表出的等价条件
<ul>
<li><span class="math inline">\(\pmb{\beta}_1 , \cdots
,\pmb{\beta}_n\)</span>的每个向量都能用<span class="math inline">\(\pmb{\alpha}_1,\cdots,\pmb{\alpha}_n\)</span>线性表示</li>
<li>存在实数<span class="math inline">\(k_{11},\cdots,k_{nn}\)</span>，使得<span class="math inline">\(\begin{bmatrix}\pmb{\alpha}_1 &amp; \cdots
&amp;\pmb{\alpha}_n \end{bmatrix}
\begin{bmatrix}k_{11}&amp;k_{12}&amp;\cdots&amp;k_{1n}\\k_{21}&amp;k_{22}&amp;\cdots&amp;k_{2n}\\
\vdots&amp;\vdots&amp;\
&amp;\vdots\\k_{n1}&amp;k_{n2}&amp;\cdots&amp;k_{nn} \end{bmatrix} =
\begin{bmatrix}\pmb{\beta}_1 &amp; \cdots &amp;\pmb{\beta}_n
\end{bmatrix}\)</span></li>
<li><span class="math inline">\(r( \begin{bmatrix}\pmb{\alpha}_1 &amp;
\cdots &amp;\pmb{\alpha}_n \end{bmatrix} )=r(
\begin{bmatrix}\pmb{\alpha}_1 &amp; \cdots &amp;\pmb{\alpha}_n &amp;
\pmb{\beta}_1 &amp; \cdots &amp;\pmb{\beta}_n\end{bmatrix}
)\)</span>（根据非齐次线性方程组知识）</li>
</ul></li>
<li>一个向量组<span class="math inline">\(\pmb{\beta}_1, \cdots
,\pmb{\beta}_n\)</span>不可以用一个向量组<span class="math inline">\(\pmb{\alpha}_1,\cdots,\pmb{\alpha}_n\)</span>线性表出的等价条件
<ul>
<li>不存在实数<span class="math inline">\(k_{11},\cdots,k_{nn}\)</span>，使<span class="math inline">\(\begin{bmatrix}\pmb{\alpha}_1 &amp; \cdots
&amp;\pmb{\alpha}_n \end{bmatrix}
\begin{bmatrix}k_{11}&amp;k_{12}&amp;\cdots&amp;k_{1n}\\k_{21}&amp;k_{22}&amp;\cdots&amp;k_{2n}\\
\vdots&amp;\vdots&amp;\
&amp;\vdots\\k_{n1}&amp;k_{n2}&amp;\cdots&amp;k_{nn} \end{bmatrix} =
\begin{bmatrix}\pmb{\beta}_1 &amp; \cdots &amp;\pmb{\beta}_n
\end{bmatrix}\)</span></li>
<li><span class="math inline">\(r( \begin{bmatrix}\pmb{\alpha}_1 &amp;
\cdots &amp;\pmb{\alpha}_n \end{bmatrix} )\neq r(
\begin{bmatrix}\pmb{\alpha}_1 &amp; \cdots &amp;\pmb{\alpha}_n &amp;
\pmb{\beta}_1 &amp; \cdots &amp;\pmb{\beta}_n\end{bmatrix}
)\)</span>（根据非齐次线性方程组知识）</li>
</ul></li>
</ul>
<h2 id="向量组等价">向量组等价</h2>
<h3 id="向量组等价的判断">向量组等价的判断</h3>
<ul>
<li>两个向量组等价的充要条件
<ul>
<li>两个向量组相互可以线性表示对方</li>
<li><span class="math inline">\(r( \begin{bmatrix}\pmb{\alpha}_1 &amp;
\cdots &amp;\pmb{\alpha}_n \end{bmatrix} )=r(
\begin{bmatrix}\pmb{\beta}_1 &amp; \cdots &amp;\pmb{\beta}_n
\end{bmatrix} )= r( \begin{bmatrix}\pmb{\alpha}_1 &amp; \cdots
&amp;\pmb{\alpha}_n &amp; \pmb{\beta}_1 &amp; \cdots
&amp;\pmb{\beta}_n\end{bmatrix} )\)</span>（线性表出小节的推论）</li>
</ul></li>
</ul>
<h3 id="和矩阵等价的关系">和矩阵等价的关系</h3>
<p>本节探讨向量组等价和矩阵等价两个条件之间的关系（结论：互相不为对方的必要条件）</p>
<ul>
<li>向量组等价的定义：两个向量组相互可以线性表示</li>
<li>矩阵等价的等价条件：两个矩阵同型且秩相同（详见第二章初等变换部分性质3）</li>
<li>两个向量组等价，可以说明两个向量组秩相同，即由两向量组所拼成的两个矩阵的秩相同，但不一定同型（向量组的向量数不一定相同），所以，矩阵不一定等价</li>
<li>若两个矩阵等价，则对应行（列）向量组的向量个数相同，且秩相同，但两个向量组之间不一定可以线性表出。简单的例子：xy平面的10个向量，yz平面的10个向量，这两个向量组的向量个数都是10，且秩都是2，但是两个向量组之间不可以线性表出</li>
</ul>
<h2 id="极大线性无关组">极大线性无关组</h2>
<ul>
<li>求法
<ul>
<li>对列向量组作初等行变换，化成行阶梯型矩阵</li>
<li>因为初等行变换不改变（任意几列的列向量组成的）方程组的解，所以也不改变列向量的线性相关性</li>
<li>根据行阶梯型矩阵的各列向量的线性相关性，得到原向量组的极大线性无关组</li>
</ul></li>
<li>重要结论：极大线性无关组的向量个数 = 向量组的秩 = 矩阵的秩</li>
</ul>
<h2 id="理解线性无关向量组的正交化">理解线性无关向量组的正交化</h2>
<ul>
<li>向量个数为n的m维向量组线性无关，意思是向量组恰好张成了m维线性空间的n维子空间，可以表示这个n维子空间的任何向量</li>
<li>但是这个n个向量不一定两两垂直，正交化的步骤就是计算垂直分量的步骤</li>
<li>设n个向量为<span class="math inline">\(\pmb{\alpha}_1,\pmb{\alpha}_2,\cdots,\pmb{\alpha}_n\)</span>，正交化步骤如下
<ul>
<li><span class="math inline">\(\pmb{\beta}_1=\pmb{\alpha}_1\)</span>：第一个向量直接照搬，作为第一个维度</li>
<li><span class="math inline">\(\pmb{\beta}_2=\pmb{\alpha}_2-\frac{(\pmb{\alpha}_2,\pmb{\beta}_1)}{(\pmb{\beta}_1,\pmb{\beta}_1)}\pmb{\beta}_1\)</span>：<span class="math inline">\(\pmb{\alpha}_2\)</span>减去其在<span class="math inline">\(\pmb{\beta}_1\)</span>维度上的分量</li>
<li><span class="math inline">\(\pmb{\beta}_3=\pmb{\alpha}_3-\frac{(\pmb{\alpha}_3,\pmb{\beta}_1)}{(\pmb{\beta}_1,\pmb{\beta}_1)}\pmb{\beta}_1-\frac{(\pmb{\alpha}_3,\pmb{\beta}_2)}{(\pmb{\beta}_2,\pmb{\beta}_2)}\pmb{\beta}_2\)</span>：<span class="math inline">\(\pmb{\alpha}_3\)</span>减去其在<span class="math inline">\(\pmb{\beta}_1\)</span>和<span class="math inline">\(\pmb{\beta}_2\)</span>维度上的分量</li>
<li><span class="math inline">\(\pmb{\beta}_n=\pmb{\alpha}_n-\frac{(\pmb{\alpha}_n,\pmb{\beta}_1)}{(\pmb{\beta}_1,\pmb{\beta}_1)}\pmb{\beta}_1-\cdots-\frac{(\pmb{\alpha}_n,\pmb{\beta}_{n-1})}{(\pmb{\beta}_{n-1},\pmb{\beta}_{n-1})}\pmb{\beta}_{n-1}\)</span>：<span class="math inline">\(\pmb{\alpha}_n\)</span>减去其在<span class="math inline">\(\pmb{\beta}_1\)</span>一直到<span class="math inline">\(\pmb{\beta}_{n-1}\)</span>维度上的分量</li>
</ul></li>
<li>正交化后如果再单位化，即得到正交规范向量组</li>
</ul>
<h2 id="正交矩阵的理解">正交矩阵的理解</h2>
<ul>
<li>由正交规范向量组构成的矩阵是正交矩阵</li>
<li>不同行（列）的内积为0（因为正交化），同一行（列）的内积是1（因为单位化）
<ul>
<li>因此正交矩阵满足<span class="math inline">\(\pmb{A}\pmb{A}^T=\pmb{A}^T\pmb{A}=\pmb{E}\)</span></li>
</ul></li>
</ul>
<h2 id="基变换">基变换</h2>
<ul>
<li>从基<span class="math inline">\(\pmb{\alpha}_1,\cdots,\pmb{\alpha}_n\)</span>到基<span class="math inline">\(\pmb{\beta}_1,\cdots,\pmb{\beta}_n\)</span>
<ul>
<li><span class="math inline">\(\begin{bmatrix}\pmb{\alpha}_1 &amp;
\cdots &amp;\pmb{\alpha}_n \end{bmatrix} \pmb{C}=
\begin{bmatrix}\pmb{\beta}_1 &amp; \cdots &amp;\pmb{\beta}_n
\end{bmatrix}\)</span></li>
<li><span class="math inline">\(\pmb{C}=
\begin{bmatrix}c_{11}&amp;c_{12}&amp;\cdots&amp;c_{1n}\\c_{21}&amp;c_{22}&amp;\cdots&amp;c_{2n}\\
\vdots&amp;\vdots&amp;\
&amp;\vdots\\c_{n1}&amp;c_{n2}&amp;\cdots&amp;c_{nn}
\end{bmatrix}\)</span>是过渡矩阵</li>
</ul></li>
</ul>
<h2 id="坐标变换">坐标变换</h2>
<ul>
<li>从基<span class="math inline">\(\pmb{\alpha}_1,\cdots,\pmb{\alpha}_n\)</span>的坐标<span class="math inline">\(\begin{bmatrix}x_1\\x_2\\ \vdots\\ x_n
\end{bmatrix}\)</span>到自然基<span class="math inline">\(\begin{bmatrix}1\\0\\ \vdots\\ 0 \end{bmatrix} ,
\begin{bmatrix}0\\1\\ \vdots\\ 0 \end{bmatrix} ,\cdots,
\begin{bmatrix}0\\0\\ \vdots\\ 1 \end{bmatrix}\)</span>的坐标<span class="math inline">\(\begin{bmatrix}z_1\\z_2\\ \vdots\\ z_n
\end{bmatrix}\)</span>
<ul>
<li><span class="math inline">\(\begin{bmatrix}\pmb{\alpha}_1 &amp;
\cdots &amp;\pmb{\alpha}_n \end{bmatrix} \begin{bmatrix}x_1\\x_2\\
\vdots\\ x_n \end{bmatrix} =
\begin{bmatrix}1&amp;0&amp;\cdots&amp;0\\0&amp;1&amp;\cdots&amp;0\\
\vdots&amp;\vdots&amp;\ &amp;\vdots\\0&amp;0&amp;\cdots&amp;1
\end{bmatrix} \begin{bmatrix}z_1\\z_2\\ \vdots\\ z_n \end{bmatrix} =
\begin{bmatrix}z_1\\z_2\\ \vdots\\ z_n \end{bmatrix}\)</span></li>
</ul></li>
<li>从基<span class="math inline">\(\pmb{\alpha}_1,\cdots,\pmb{\alpha}_n\)</span>的坐标<span class="math inline">\(\begin{bmatrix}x_1\\x_2\\ \vdots\\ x_n
\end{bmatrix}\)</span>到基<span class="math inline">\(\pmb{\beta}_1,\cdots,\pmb{\beta}_n\)</span>的坐标<span class="math inline">\(\begin{bmatrix}y_1\\y_2\\ \vdots\\ y_n
\end{bmatrix}\)</span>
<ul>
<li><span class="math inline">\(\begin{bmatrix}\pmb{\alpha}_1 &amp;
\cdots &amp;\pmb{\alpha}_n \end{bmatrix} \begin{bmatrix}x_1\\x_2\\
\vdots\\ x_n \end{bmatrix} = \begin{bmatrix}\pmb{\beta}_1 &amp; \cdots
&amp;\pmb{\beta}_n \end{bmatrix} \begin{bmatrix}y_1\\y_2\\ \vdots\\ y_n
\end{bmatrix} = \begin{bmatrix}z_1\\z_2\\ \vdots\\ z_n
\end{bmatrix}\)</span></li>
</ul></li>
</ul>
<h2 id="线性变换">线性变换</h2>
<ul>
<li>基为<span class="math inline">\(\pmb{\alpha}_1,\cdots,\pmb{\alpha}_n\)</span>的坐标系到基为<span class="math inline">\(\pmb{\beta}_1,\cdots,\pmb{\beta}_n\)</span>的坐标系的线性变换
<ul>
<li>直观含义：线性变换是对坐标向量的映射变换
<ul>
<li><span class="math inline">\(\begin{bmatrix}y_1\\y_2\\ \vdots\\ y_n
\end{bmatrix} = \begin{bmatrix}\pmb{\beta}_1 &amp; \cdots
&amp;\pmb{\beta}_n \end{bmatrix} ^{-1} \begin{bmatrix}\pmb{\alpha}_1
&amp; \cdots &amp;\pmb{\alpha}_n \end{bmatrix} \begin{bmatrix}x_1\\x_2\\
\vdots\\ x_n \end{bmatrix} =\pmb{C}^{-1} \begin{bmatrix}x_1\\x_2\\
\vdots\\ x_n \end{bmatrix} =\pmb{T} \begin{bmatrix}x_1\\x_2\\ \vdots\\
x_n \end{bmatrix}\)</span></li>
</ul></li>
<li>重要性质：<span class="math inline">\(\pmb{T}=\pmb{C}^{-1}\)</span>
<ul>
<li>坐标系变化的方向和坐标变化的方向相反</li>
<li>比如坐标系左移，相当于坐标右移</li>
</ul></li>
<li>本质内涵：线性变换表面是对坐标的变换，本质是<strong>对坐标系的变换</strong>
<ul>
<li>任何向量在变换前后处于不同的坐标系，表达形式不同，但还是原本的向量</li>
<li>向量在原坐标系的表示看作自变量，在新坐标系的表示看作因变量，线性变换看作映射</li>
</ul></li>
<li>严格定义：线性变换<span class="math inline">\(\pmb{T}\)</span>使得<span class="math inline">\(\pmb{T}(a\pmb{X}+b\pmb{Y})=a\pmb{T}(\pmb{X})+b\pmb{T}(\pmb{Y})\)</span>恒成立
<ul>
<li>人话解读：原坐标系中满足合成关系的三个向量<span class="math inline">\(\pmb{X},\pmb{Y},\pmb{a\pmb{X}+b\pmb{Y}}\)</span>在线性变换后的坐标系中还满足相同比例的合成关系</li>
<li>超出了线代的基本范畴，理解即可</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第五章-特征值和特征向量</title>
    <url>/2021/11/20/linearAlgebra5/</url>
    <content><![CDATA[<ul>
<li>本知识总结不提供完整的理论体系汇总，旨在给出<em>概念的理解</em>以及<em>各类问题的思考框架</em>。</li>
<li>笔记为个人整理，禁止商业用途</li>
<li>如有疏漏，欢迎留言</li>
</ul>
<h2 id="特征值和特征向量">特征值和特征向量</h2>
<h3 id="定义和理解">定义和理解</h3>
<ul>
<li>定义：<span class="math inline">\(\pmb{A}\pmb{\alpha}=\lambda\pmb{\alpha}\)</span>且<span class="math inline">\(\pmb{\alpha}\neq 0\)</span>
<ul>
<li><span class="math inline">\(\lambda\)</span>为<span class="math inline">\(\pmb{A}\)</span>的特征值</li>
<li><span class="math inline">\(\pmb{\alpha}\)</span>为<span class="math inline">\(\pmb{A}\)</span>的特征向量</li>
</ul></li>
<li>向量空间角度理解
<ul>
<li>把矩阵看作线性变换，特征向量经过该变换后发生了伸缩</li>
</ul></li>
<li>线性方程组角度
<ul>
<li>相等于<span class="math inline">\((\lambda\pmb{E}-\pmb{A})\pmb{\alpha}=\pmb{0}\)</span>且<span class="math inline">\(\pmb{\alpha}\neq 0\)</span></li>
</ul></li>
</ul>
<h3 id="相关概念">相关概念</h3>
<ul>
<li>特征方程
<ul>
<li><span class="math inline">\(\vert\lambda\pmb{E}-\pmb{A}\vert=0\)</span></li>
</ul></li>
<li>特征多项式
<ul>
<li><span class="math inline">\(\vert\lambda\pmb{E}-\pmb{A}\vert=\prod(\lambda-\lambda_i)\)</span></li>
<li><span class="math inline">\(\lambda_i\)</span>是特征值</li>
</ul></li>
<li>特征矩阵
<ul>
<li><span class="math inline">\(\lambda\pmb{E}-\pmb{A}\)</span></li>
</ul></li>
</ul>
<h3 id="两个性质">两个性质</h3>
<ul>
<li>特征值的和 = 矩阵的迹</li>
<li>特征值的积 = 矩阵的行列式</li>
</ul>
<h3 id="求解方法">求解方法</h3>
<ul>
<li>具体矩阵：先利用特征多项式等于0解出特征值，再用特征方程解特征向量</li>
<li>抽象矩阵：使用定义求解
<ul>
<li>结论：<span class="math inline">\(\pmb{A}\)</span>的特征值是<span class="math inline">\(\lambda\)</span>，则<span class="math inline">\(f(\pmb{A})\)</span>的特征值一般是<span class="math inline">\(f(\lambda)\)</span>，特征向量一般不变</li>
<li>补充说明
<ul>
<li>具体计算需要按定义，该结论仅供验证结果</li>
<li>如果<span class="math inline">\(f\)</span>是多项式函数，该结论是正确的</li>
<li>该结论一般不显式的提问，而是作为中间处理的一步，因此需要有主动使用的意识</li>
</ul></li>
</ul></li>
</ul>
<h3 id="证明两个矩阵特征值相等">证明两个矩阵特征值相等</h3>
<p>思路包括 + 证明特征多项式相等 * 最常用的方法，等价条件 +
证明两个矩阵相似 * 是特征值相等的充分条件 + 按特征值定义证明 *
构造特征向量是一个难点</p>
<h2 id="相似矩阵">相似矩阵</h2>
<ul>
<li>定义：<span class="math inline">\(\pmb{A}\sim
\pmb{B}\)</span>即存在可逆矩阵<span class="math inline">\(\pmb{P}\)</span>，使得<span class="math inline">\(\pmb{A}\pmb{P}=\pmb{P}\pmb{B}\)</span>
<ul>
<li>相似变换指的是<span class="math inline">\(\pmb{B}=\pmb{P}^{-1}\pmb{A}\pmb{P}\)</span>，<span class="math inline">\(\pmb{P}\)</span>是可逆矩阵</li>
</ul></li>
<li>必要条件：相似矩阵的特征值、特征多项式、秩相同</li>
<li>相似关系是等价关系，有自反性、对称性、传递性</li>
</ul>
<h2 id="相似对角化">相似对角化</h2>
<ul>
<li>相似对角化方法：详见第二章，矩阵的相似对角化分解</li>
<li>对角化后的矩阵是原矩阵的相似标准形</li>
<li>重要结论
<ul>
<li>不同特征值对应特征向量线性无关
<ul>
<li>向量线性无关的定义 + 特征向量的定义即可证明</li>
</ul></li>
<li>任一特征值的线性无关的特征向量个数<strong>小于等于</strong>该特征值的重数
<ul>
<li>证明麻烦，建议记住</li>
</ul></li>
</ul></li>
</ul>
<h2 id="实对称矩阵的对角化">实对称矩阵的对角化</h2>
<ul>
<li>重要结论
<ul>
<li>实对称矩阵一定可以相似对角化
<ul>
<li>说明存在可逆矩阵<span class="math inline">\(\pmb{P}\)</span>使得<span class="math inline">\(\pmb{A}\pmb{P}=\pmb{P}\pmb{\Lambda}\)</span></li>
</ul></li>
<li>实对称矩阵不同特征值对应特征向量正交
<ul>
<li>说明存在正交矩阵<span class="math inline">\(\pmb{Q}\)</span>使得<span class="math inline">\(\pmb{A}\pmb{Q}=\pmb{Q}\pmb{\Lambda}\)</span></li>
<li>即实对称矩阵一定可以正交相似对角化</li>
</ul></li>
</ul></li>
<li>对角化步骤：同一般矩阵，核心是求特征值和特征向量，详见第二章，矩阵的相似对角化分解</li>
<li>正交对角化步骤
<ul>
<li>不同特征值的特征向量已经正交，只需要把同一个特征值的各特征向量正交化即可（正交化方法见第三章）</li>
<li>把所有特征向量单位化，此时所有特征向量是标准正交列向量组，按特征值对应顺序组成正交矩阵</li>
</ul></li>
</ul>
<h2 id="已知特征值特征向量反求矩阵">已知特征值特征向量反求矩阵</h2>
<ul>
<li>利用相似对角化的结论<span class="math inline">\(\pmb{A}\pmb{P}=\pmb{P}\pmb{\Lambda}\)</span>
<ul>
<li><span class="math inline">\(\pmb{P}\)</span>可逆时，直接矩阵运算即可</li>
<li><span class="math inline">\(\pmb{P}\)</span>不可逆时，转置等式两侧，相当于计算多个非齐次线性方程组</li>
</ul></li>
<li>如果<span class="math inline">\(\pmb{A}\)</span>是实对称矩阵，可以用正交矩阵来算，用转置运算代替较繁琐的求逆步骤</li>
</ul>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第六章-二次型</title>
    <url>/2021/11/21/linearAlgebra6/</url>
    <content><![CDATA[<ul>
<li>本知识总结不提供完整的理论体系汇总，旨在给出<em>概念的理解</em>以及<em>各类问题的思考框架</em>。</li>
<li>笔记为个人整理，禁止商业用途</li>
<li>如有疏漏，欢迎留言</li>
</ul>
<h2 id="二次型的矩阵表示">二次型的矩阵表示</h2>
<ul>
<li>二次型指的是变量的二次齐次多项式<span class="math inline">\(f(x_1,\cdots_,x_n)=\sum\limits_{i=1}^n\sum\limits_{j=1}^na_{ij}x_ix_j\)</span></li>
<li><span class="math inline">\(\sum\limits_{i=1}^n\sum\limits_{j=1}^na_{ij}x_ix_j=
\begin{bmatrix} x_1&amp;x_2&amp;\cdots&amp;x_n \end{bmatrix}
\begin{bmatrix} a_{11} &amp;a_{12}&amp; \cdots &amp; a_{1n}\\a_{21}&amp;
a_{22}&amp; \cdots &amp; a_{2n}\\\vdots&amp;\vdots&amp;\ &amp; \vdots\\
a_{n1}&amp;a_{n2}&amp; \cdots&amp; a_{nn} \end{bmatrix} \begin{bmatrix}
x_1\\x_2\\\cdots\\x_n \end{bmatrix}
=\pmb{x}^T\pmb{A}\pmb{x}\)</span></li>
<li>要求<span class="math inline">\(\pmb{A}\)</span>是对称矩阵，此时二次型和矩阵一一对应</li>
</ul>
<h2 id="二次型化为标准形">二次型化为标准形</h2>
<ul>
<li>标准形：只有平方项的二次型</li>
<li>规范性：在标准形基础上，平方项的系数只能是-1、0、1</li>
<li>线性变换：即第三章的坐标变换，<span class="math inline">\(\pmb{x}=\pmb{P}\pmb{y}\)</span>
<ul>
<li>当<span class="math inline">\(\pmb{P}\)</span>是正交矩阵<span class="math inline">\(\pmb{Q}\)</span>，则对应正交变换</li>
</ul></li>
<li>法一：通过正交变换<span class="math inline">\(\pmb{x}=\pmb{Q}\pmb{y}\)</span>化为标准形
<ul>
<li><span class="math inline">\(\pmb{x}^T\pmb{A}\pmb{x}=(\pmb{y}^T\pmb{Q}^T)\pmb{A}(\pmb{Q}\pmb{y})=\pmb{y}^T(\pmb{Q}^T\pmb{A}\pmb{Q})\pmb{y}=\pmb{y}^T\pmb{\Lambda}\pmb{y}\)</span></li>
<li>用到了第五章正交相似对角化的内容</li>
<li>求解要点
<ul>
<li>求特征值，算出<span class="math inline">\(\pmb{\Lambda}\)</span>，从而得到标准形</li>
<li>求特征向量并正交单位化，给出线性变换<span class="math inline">\(\pmb{y}=\pmb{Q}^{-1}\pmb{x}\)</span></li>
</ul></li>
</ul></li>
<li>法二：通过配方法化为标准形
<ul>
<li>有平方项则配方；无平方项则利用<span class="math inline">\(x_i=y_i+y_j,x_j=y_i-y_j\)</span>得到平方项，即<span class="math inline">\(a_{ij}x_ix_j=a_{ij}(y_i^2-y_j^2)\)</span></li>
<li>要给出可逆线性变换和标准形的表示
<ul>
<li>若配方后平方项个数不足原二次型的变量数，则需要补充平方项以保证线性变换可逆（补充方法不唯一，因为标准形也不唯一）</li>
</ul></li>
</ul></li>
</ul>
<h2 id="合同矩阵与合同二次型">合同矩阵与合同二次型</h2>
<ul>
<li>合同矩阵：<span class="math inline">\(\pmb{A}\simeq\pmb{B}\Leftrightarrow\)</span>
即存在可逆矩阵<span class="math inline">\(\pmb{C}\)</span>，使得<span class="math inline">\(\pmb{B}=\pmb{C}^T\pmb{A}\pmb{C}\)</span>
<ul>
<li>合同关系是等价关系，自反性、对称性、传递性</li>
<li>合同变换：双向箭头的右侧部分</li>
</ul></li>
<li>合同二次型：对原二次型进行<strong>可逆线性变换</strong><span class="math inline">\(\pmb{x}=\pmb{C}\pmb{y}\)</span>，得到合同二次型
<ul>
<li><span class="math inline">\(\pmb{x}^T\pmb{A}\pmb{x}=(\pmb{y}^T\pmb{C}^T)\pmb{A}(\pmb{C}\pmb{y})=\pmb{y}^T(\pmb{C}^T\pmb{A}\pmb{C})\pmb{y}=\pmb{y}^T\pmb{B}\pmb{y}\)</span></li>
<li>相当于对二次型的矩阵表示进行合同变换</li>
</ul></li>
<li>惯性定理：二次型的标准形不唯一，但是其正惯性指数、负惯性指数是确定的
<ul>
<li>正惯性指数：标准形正平方项个数</li>
<li>负惯性指数：标准形负平方项个数</li>
<li>二次型的秩：正负惯性指数的和</li>
</ul></li>
<li>重要定理：二次型的矩阵的合同变换不改变其正负惯性指数
<ul>
<li>因为二次型可逆线性变换不改变其规范形</li>
</ul></li>
</ul>
<h2 id="正定性的证明">正定性的证明</h2>
<ul>
<li>正定二次型的证明：等价条件如下
<ul>
<li>对任意<span class="math inline">\(\pmb{x}\neq
\pmb{0}\)</span>，有<span class="math inline">\(\pmb{x}^T\pmb{A}\pmb{x}&gt;0\)</span>恒成立
<ul>
<li>正定二次型的定义</li>
</ul></li>
<li><span class="math inline">\(\pmb{A}\)</span>顺序主子式大于0</li>
<li><span class="math inline">\(\pmb{A}\)</span>特征值都大于0</li>
<li>二次型正惯性指数等于变量个数</li>
<li>存在可逆矩阵<span class="math inline">\(D\)</span>，使得<span class="math inline">\(\pmb{A}=\pmb{D}^T\pmb{E}\pmb{D}=\pmb{D}^T\pmb{D}\)</span>
<ul>
<li>因为规范形的平方项系数全为1，对应二次型的矩阵表示为<span class="math inline">\(\pmb{E}\)</span></li>
</ul></li>
</ul></li>
<li>正定矩阵：正定二次型的矩阵表示
<ul>
<li>先证明是对称矩阵，再证明对应的二次型正定</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第一章-计算机网络概述</title>
    <url>/2021/11/21/network1/</url>
    <content><![CDATA[<h2 id="计算机网络基本概念">计算机网络基本概念</h2>
<h3 id="定义">定义</h3>
<p>三种观点定义网络</p>
<ul>
<li>广义观点
<ul>
<li>定义：能实现远程信息处理甚至资源共享的系统</li>
<li>评价：资源共享能力弱，处于计算机网络发展低级阶段</li>
</ul></li>
<li>资源共享观点
<ul>
<li>定义：以资源共享方式互联的自治计算机系统集合</li>
<li>评价：资源共享、由独立自治计算机组成、遵循网络协议，符合目前计算机的基本特征</li>
</ul></li>
<li>用户透明观点
<ul>
<li>定义：存在一个网络操作系统管理资源，用户无需关心网络的存在、资源位置</li>
<li>评价：未来的网络发展目标</li>
</ul></li>
</ul>
<h3 id="组成">组成</h3>
<p>有三种组成的说法</p>
<ul>
<li>由边缘和核心组成
<ul>
<li>边缘指的是用户主机（端系统）
<ul>
<li>作用是通信和资源共享</li>
</ul></li>
<li>核心指的是大量的网络和路由器
<ul>
<li>作用是提供连通和交换服务</li>
</ul></li>
</ul></li>
<li>由硬件、软件和协议组成
<ul>
<li>硬件：主机、通信链路（比如双绞线和光纤）、交换设备（比如交换机和路由器）、通信处理机（比如网卡）</li>
<li>软件：如网络操作系统，邮件软件，FTP程序，聊天软件</li>
<li>协议：网络传输数据时的规范</li>
</ul></li>
<li>由通信子网和资源子网组成
<ul>
<li>通信子网：包括传输介质、传输设备、协议</li>
<li>资源子网：包括资源共享设备和软件</li>
</ul></li>
</ul>
<h3 id="功能">功能</h3>
<p>主要的功能有五个</p>
<ul>
<li>数据通信
<ul>
<li>最基本和重要的功能</li>
</ul></li>
<li>资源共享
<ul>
<li>软件、数据、硬件的共享</li>
</ul></li>
<li>分布式处理
<ul>
<li>分解分配，解决复杂任务</li>
</ul></li>
<li>提高可靠性
<ul>
<li>各计算机互为替代机</li>
</ul></li>
<li>负载均衡
<ul>
<li>任务均衡的分配给各计算机</li>
</ul></li>
</ul>
<h3 id="分类">分类</h3>
<ul>
<li>按分布范围
<ul>
<li>广域网WAN：长距离跨城市的范围</li>
<li>城域网MAN：覆盖城市的范围</li>
<li>局域网LAN：百到千米，比如教学楼</li>
<li>个人区域网PAN：约10米，比如手机热点</li>
</ul></li>
<li>按传输技术
<ul>
<li>广播式网络
<ul>
<li>举例：局域网、广域网的无线卫星通信</li>
</ul></li>
<li>点对点网络
<ul>
<li>采用<strong>分组存储转发</strong>和<strong>路由选择机制</strong>（和广播式的重要区别）</li>
<li>举例：大部分的广域网</li>
</ul></li>
</ul></li>
<li>按拓扑结构
<ul>
<li>总线结构：单根线串主机，局域网使用</li>
<li>星形结构：各主机直接连中央设备（交换机或路由器），局域网使用</li>
<li>环形结构：计算机串成环，局域网使用</li>
<li>网状结构：大部分结点都有多个边，广域网使用</li>
</ul></li>
<li>按使用者
<ul>
<li>公用网：电信建造的大型网络，付费使用</li>
<li>专用网：部门内部自建的网络，不对外开放</li>
</ul></li>
<li>按交换技术
<ul>
<li>电路交换网
<ul>
<li>电路交换：源点和目标点建立专用通路，需要建立连接、传输、断开几个阶段</li>
<li>举例：传统的固定电话网络</li>
</ul></li>
<li>报文交换网（存储转发网）
<ul>
<li>报文交换：数据整体打包为报文，加上源地址、目的地址等信息，存储转发到相邻结点</li>
<li>特点：报文长度不固定，缓冲难管理</li>
</ul></li>
<li>分组交换网（包交换网）
<ul>
<li>分组交换：数据划分为多个等长的分组，各自加上源地址、目的地址等信息，存储转发到相邻结点</li>
<li>特点：分组长度固定，缓冲好管理</li>
<li>举例：目前主流的网络都是分组交换</li>
</ul></li>
</ul></li>
<li>按传输介质
<ul>
<li>有线网：如双绞线网络、同心电缆网络</li>
<li>无线网：如蓝牙网、无线电网</li>
</ul></li>
</ul>
<h3 id="性能指标">性能指标</h3>
<ul>
<li>带宽
<ul>
<li>在通信领域指频带范围，单位Hz</li>
<li>在网络领域指最高数据传输速率，单位b/s</li>
</ul></li>
<li>时延
<ul>
<li>发送时延（传输时延）
<ul>
<li>从分组第一个比特开始传送，到最后一个比特发送完毕的时间</li>
<li>等于分组长度/信道带宽</li>
</ul></li>
<li>传播时延
<ul>
<li>电磁波传播需要时间</li>
<li>等于信道长度/电磁波在信道上的速度</li>
</ul></li>
<li>处理时延
<ul>
<li>存储转发时的处理耗时，默认情况忽略</li>
</ul></li>
<li>排队时延
<ul>
<li>输入和输出路由器时，数据需要排队的时间，默认情况忽略</li>
</ul></li>
</ul></li>
<li>时延带宽积
<ul>
<li>信道可容纳的比特数</li>
<li>等于信道的带宽 <span class="math inline">\(\times\)</span>
传播时延</li>
</ul></li>
<li>往返时延（RTT）
<ul>
<li>包括发送方传播时延、中间结点的处理、排队时延、转发数据的发送时延</li>
<li>注意，不包括<strong>发送方传输时延</strong>和<strong>接收方确认</strong>的传输时延</li>
</ul></li>
<li>吞吐量
<ul>
<li>单位时间通过某网络的实际数据量</li>
</ul></li>
<li>速率（数据传输率）
<ul>
<li>信道中的实际数据传送速度，单位b/s</li>
</ul></li>
<li>信道利用率
<ul>
<li>某信道被使用的时间占总时间的比例</li>
</ul></li>
</ul>
<h2 id="计算机网络体系结构">计算机网络体系结构</h2>
<h3 id="分层结构">分层结构</h3>
<h4 id="有关概念">有关概念</h4>
<ul>
<li>网络体系结构：各层和各层协议的集合
<ul>
<li>网络分层不需要考虑具体的功能实现，这由设备厂家确定</li>
</ul></li>
<li>实体：可发送、接收信息的硬件或软件进程</li>
<li>对等层：不同机器的同一层</li>
<li>报文组成
<ul>
<li>服务数据单元SDU：某层的原始数据</li>
<li>协议控制信息PCI：某层的控制信息</li>
<li>协议数据单元PDU：由该层的SDU和PCI打包而成，并作为下层的SDU
<ul>
<li>n-PDU=n-SDU+n-PCI=(n-1)-SDU</li>
</ul></li>
</ul></li>
</ul>
<h4 id="层次结构含义">层次结构含义</h4>
<ul>
<li>同主机：高层使用低层提供的服务，但注意只能调用相邻低层的接口</li>
<li>不同主机：对等层逻辑上直接通信，下层的服务是透明的</li>
</ul>
<h3 id="协议接口服务">协议、接口、服务</h3>
<ul>
<li>协议：对等实体通信的规则
<ul>
<li>包括语法格式、语义功能、同步时序</li>
</ul></li>
<li>接口：同主机的相邻层交换信息的连接点
<ul>
<li>典型的接口比如服务访问点SAP，每层的SAP是相邻上层能直接访问服务的位置
<ul>
<li>物理层SAP：网卡接口</li>
<li>数据链路层SAP：MAC地址</li>
<li>网络层SAP：IP地址</li>
<li>传输层SAP：端口号</li>
<li>应用层SAP：用户界面</li>
</ul></li>
</ul></li>
<li>服务：同主机的下层为相邻上层提供服务
<ul>
<li>服务是垂直的，协议是水平的</li>
<li>OSI模型的服务原语（设A是用户主机，B是服务器主机）
<ul>
<li>请求：A的高层发送给A的低层</li>
<li>指示：B的低层发送给B的高层</li>
<li>响应：B的高层发送给B的低层</li>
<li>证实：A的低层发送给A的高层</li>
</ul></li>
<li>分类
<ul>
<li>面向连接服务和无连接服务（最大努力交付）：通信前是否需要建立连接</li>
<li>可靠服务和不可靠服务：是否通过检错、纠错、应答来保证数据正确</li>
<li>有应答服务和无应答服务：接收方是否应答</li>
</ul></li>
</ul></li>
</ul>
<h3 id="isoosi模型">ISO/OSI模型</h3>
<ul>
<li>协议栈共7层，低3层是通信子网，高3层是资源子网</li>
<li>物理层
<ul>
<li>传输单位：比特</li>
<li>功能：传输原始比特流</li>
<li>协议举例：EIA-232C、EIA/TIA RS-449、CCITT的X.21</li>
</ul></li>
<li>数据链路层
<ul>
<li>传输单位：帧</li>
<li>功能：提供点到点的通信（主机之间）
<ul>
<li>成帧、差错控制、流量控制、传输管理</li>
</ul></li>
<li>协议举例：SDLC、HDLC、PPP、STP、帧中继</li>
</ul></li>
<li>网络层
<ul>
<li>传输单位：数据报或分组（包）</li>
<li>功能：分组路由、流量控制、拥塞控制、差错控制、网络互联</li>
<li>协议举例：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF</li>
</ul></li>
<li>传输层
<ul>
<li>传输单位：报文段TCP或用户数据报UDP</li>
<li>功能：提供端到端的可靠通信服务（跨主机的进程之间）
<ul>
<li>数据传输和管理、流量控制、差错控制</li>
</ul></li>
<li>协议举例：TCP、UDP</li>
</ul></li>
<li>会话层
<ul>
<li>功能：建立同步，管理各主机的会话进程，设置校验同步点以在通信失效时恢复通信</li>
</ul></li>
<li>表示层
<ul>
<li>功能：数据压缩、加密、解密等</li>
</ul></li>
<li>应用层
<ul>
<li>传输单位：报文</li>
<li>功能：用户和网络的界面，应用多种多样</li>
<li>协议：文件传送FTP、电子邮件SMTP、万维网HTTP、域名解析DNS</li>
</ul></li>
</ul>
<h3 id="tcpip模型">TCP/IP模型</h3>
<ul>
<li>协议栈共4层，国际广泛使用的标准</li>
<li>网络接口层：类似于OSI的物理层和数据链路层</li>
<li>网际层：类似于OSI的网络层
<ul>
<li>协议举例：IPV4和IPV6</li>
</ul></li>
<li>传输层：类似于OSI的传输层</li>
<li>应用层：类似于OSI的会话层、表示层、应用层</li>
<li>与OSI模型的区别
<ul>
<li>OSI的网络层支持无连接<strong>或</strong>连接通信，TCP/IP的网际层只支持无连接通信
<ul>
<li>网络层无法同时支持无连接和连接的通信（数据报方式和虚电路方式二选一）</li>
</ul></li>
<li>OSI的传输层只有面向连接的通信，TCP/IP的传输层支持无连接<strong>和</strong>连接通信</li>
</ul></li>
</ul>
<h3 id="折中模型">折中模型</h3>
<ul>
<li>协议栈5层，学习网络时常用的模型</li>
<li>物理层、数据链路层、网络层、传输层、应用层</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第二章-物理层</title>
    <url>/2021/11/23/network2/</url>
    <content><![CDATA[<h2 id="通信基础">通信基础</h2>
<h3 id="基本概念">基本概念</h3>
<ul>
<li>数据：信息的实体</li>
<li>信号：数据的电气表现、存在形式
<ul>
<li>模拟信号：连续的信号</li>
<li>数字信号：离散的信号</li>
</ul></li>
<li>码元：用固定时长（即码元宽度）的信号波形表示一个k进制数
<ul>
<li>码元宽度：固定时长</li>
<li>数字脉冲：信号波形</li>
</ul></li>
<li>信源：产生和发送数据的源头
<ul>
<li>数据经过变换器变成信号，传给信道（详见编码和调制小节）</li>
</ul></li>
<li>信道：信号的传输媒介
<ul>
<li>噪声源会对信号产生干扰</li>
<li>按信号类型分类：模拟信道、数字信道</li>
<li>按传输介质分类：无线信道和有线信道</li>
</ul></li>
<li>信宿：接收数据的终点
<ul>
<li>信号经过反变换器变为数据，传给信宿</li>
</ul></li>
<li>基带传输：把数据以原始频带（基本频带）编码为基带信号，在数字信道上传输</li>
<li>频带传输：把基带信号调制为模拟信号，在模拟信道上传输</li>
<li>宽带传输：在频带传输基础上使用多个信道，每个信道同时频带传输，链路容量大，</li>
<li>通信方式
<ul>
<li>单向通信：只有一个方向的通信</li>
<li>半双工通信：同一时间只有一个方向的通信，需要两个信道</li>
<li>全双工通信：同一时间可以有两个方向的通信，需要两个信道</li>
</ul></li>
<li>速率：单位时间内传输的数据量
<ul>
<li>码元传输速率（波特率、调制速率）：单位时间传输码元的个数（脉冲数）
<ul>
<li>单位是波特（Baud）</li>
<li>与进制有关</li>
</ul></li>
<li>信息传输速率（比特率）：单位时间传输比特的个数
<ul>
<li>单位是b/s</li>
</ul></li>
</ul></li>
<li>带宽
<ul>
<li>在通信领域指频带范围，单位Hz</li>
<li>在网络领域指最高数据传输速率，单位b/s</li>
</ul></li>
</ul>
<h3 id="奈奎斯特定理">奈奎斯特定理</h3>
<ul>
<li>条件：理想低通信道，即无噪声且带宽有限，带宽设为<span class="math inline">\(W\)</span></li>
<li>结论：极限波特率为<span class="math inline">\(2W\)</span>，单位Baud</li>
</ul>
<h3 id="香农定理">香农定理</h3>
<ul>
<li>条件：高斯噪声且带宽有限的信道，带宽设为<span class="math inline">\(W\)</span>，信号平均功率为<span class="math inline">\(S\)</span>,噪声平均功率<span class="math inline">\(N\)</span></li>
<li>结论：极限数据传输速率<span class="math inline">\(Wlog_2(1+\frac{S}{N})\)</span>，单位b/s
<ul>
<li>信噪比：<span class="math inline">\(10lg(\frac{S}{N})\)</span>，单位dB</li>
</ul></li>
</ul>
<h3 id="编码">编码</h3>
<p>即数据转换为数字信号</p>
<ul>
<li>数字数据到数字信号
<ul>
<li>归零编码RZ：高电平为1（或0），低电平为0（或1）
<ul>
<li>时钟周期中间均跳到低电平（即归零）以传送时钟同步信号</li>
</ul></li>
<li>非归零编码NRZ：高电平为1（或0），低电平为0（或1）
<ul>
<li>时钟周期内电平不变，无法同步</li>
</ul></li>
<li>反向非归零编码NRZI：信号不变为1，信号翻转为0
<ul>
<li>可传送时钟信号以同步</li>
</ul></li>
<li>曼彻斯特编码：上半周期高电平下半周期低电平为1（或0），上半周期低电平上半周期低电平为1（或0）
<ul>
<li>跳变作为同步时钟信号</li>
<li>频带宽度是原始基带宽度的二倍，数据传输率是调制速率的一半</li>
<li>以太网的编码方式</li>
</ul></li>
<li>差分曼彻斯特编码：本周期上半部分和前一个周期下半部分相同则为1，否则为0
<ul>
<li>周期中间一定跳转，实现同步</li>
<li>周期之间的跳转决定编码</li>
</ul></li>
<li>4B/5B编码
<ul>
<li>用5位编码4位，多出的16种编码作为控制码</li>
</ul></li>
</ul></li>
<li>模拟数据到数字信号：一般的方法是脉冲编码调制PCM，采样、量化、编码
<ul>
<li>采样定理（奈奎斯特定理）：采样频率不小于最大频率的两倍，才能保证采样后的数字信号完整保留原模拟信号的信息</li>
<li>采样：模拟信号周期性取样，变成离散信号</li>
<li>量化：把取样的电平映射到确定的整数</li>
<li>编码：把量化的结果转化为二进制编码</li>
</ul></li>
</ul>
<h3 id="调制">调制</h3>
<p>即数据转换为模拟信号</p>
<ul>
<li>数字数据到模拟信号：变换器调制，反变换器解调，调制方法如下
<ul>
<li>幅移键控nASK：改变载波的振幅表示0到n
<ul>
<li>容易实现、不抗干扰</li>
</ul></li>
<li>频移键控nFSK：改变载波的频率表示0到n
<ul>
<li>容易实现、抗干扰</li>
</ul></li>
<li>相移键控nPSK：改变载波的相位表示0到n
<ul>
<li>绝对调相：不同相位对应不同值</li>
<li>相对调相：相邻码元的不同相位变换对应不同值</li>
</ul></li>
<li>正交振幅调制QAM：改变载波的频率和相位表示数字信号
<ul>
<li>设<span class="math inline">\(m\)</span>个频率，<span class="math inline">\(n\)</span>个相位，则每个波特为<span class="math inline">\(log_2\ (mn)\)</span> b</li>
</ul></li>
</ul></li>
<li>模拟数据到模拟信号
<ul>
<li>提高信号的频率，使用频分复用FDM技术</li>
<li>比如声音模拟信号转换为载波模拟信号进行传输</li>
</ul></li>
</ul>
<h3 id="交换技术">交换技术</h3>
<h4 id="电路交换">电路交换</h4>
<ul>
<li>阶段
<ul>
<li>连接建立
<ul>
<li>建立的是专用的<strong>物理通信路径</strong></li>
</ul></li>
<li>数据传输</li>
<li>连接释放</li>
</ul></li>
<li>优点
<ul>
<li>通信时延小</li>
<li>有序传输且没有冲突</li>
<li>适用于模拟信号、数字信号</li>
<li>控制简单</li>
</ul></li>
<li>缺点
<ul>
<li>连接建立时间长</li>
<li>线路独占，信道利用率低</li>
<li>不能差错控制</li>
</ul></li>
</ul>
<h4 id="报文交换">报文交换</h4>
<ul>
<li>报文作为交换单位，包括目的地址、源地址，采用<strong>存储转发机制</strong></li>
<li>优点
<ul>
<li>不用建立连接</li>
<li>动态分配线路，利用率高</li>
<li>提供多目标服务</li>
</ul></li>
<li>缺点
<ul>
<li>有转发时延</li>
<li>报文可能很大，故网络结点需要较大缓存</li>
</ul></li>
</ul>
<h4 id="分组交换">分组交换</h4>
<p><em>网络层的交换技术</em></p>
<ul>
<li>大的数据划分为等长度分组，加上源地址、目的地址等信息，采用<strong>存储转发机制</strong></li>
<li>优点
<ul>
<li>不用建立连接</li>
<li>线路利用率高</li>
<li>简化网络结点的缓冲存储管理</li>
<li>流水线方式快速传输</li>
<li>出错时重发数据量小</li>
</ul></li>
<li>缺点
<ul>
<li>有转发时延，不过比报文交换短</li>
<li>需要传输额外信息</li>
<li>分组可能失序、丢失、重复，需要进行编号管理</li>
</ul></li>
</ul>
<h3 id="数据报和虚电路">数据报和虚电路</h3>
<p><em>分组交换根据提供的服务，进一步分为面向连接的虚电路方式，和无连接的数据报方式</em></p>
<h4 id="数据报">数据报</h4>
<ul>
<li>不需要连接</li>
<li>分组包含目的地址</li>
<li>分组独立选择转发路径</li>
<li>数据不一定按序到达</li>
<li>网络尽最大努力交付，可靠性由用户保证</li>
<li>故障节点导致分组丢失，但可以选择其他路径正常工作</li>
<li>无差错控制和流量控制</li>
</ul>
<h4 id="虚电路">虚电路</h4>
<ul>
<li>需要连接</li>
<li>建立阶段需要使用目的地址，此后使用的是长度较短的虚电路号（对应某个链路）</li>
<li>同一个虚电路的分组转发的路径相同</li>
<li>数据按序到达</li>
<li>可靠性由网络保证</li>
<li>故障节点导致经过的虚电路不能工作</li>
<li>可以有差错控制、流量控制</li>
</ul>
<h2 id="传输介质">传输介质</h2>
<p><em>又叫传输媒体，工作于第1层的物理层之下，称为第0层</em></p>
<h3 id="双绞线">双绞线</h3>
<ul>
<li>结构：两根绝缘铜线绞合</li>
<li>屏蔽双绞线STP：双绞线的外面再加一层金属屏蔽层</li>
<li>非屏蔽双绞线UTP：无屏蔽层的双绞线</li>
<li>特点
<ul>
<li>价格便宜</li>
<li>数千米到数十千米范围</li>
<li>距离太远时，衰减的模拟信号需要放大器放大，失真的数字信号需要中继器整形</li>
</ul></li>
</ul>
<h3 id="同轴电缆">同轴电缆</h3>
<ul>
<li>结构：从内到外为内导体、绝缘层、网状屏蔽层、绝缘塑料外套</li>
<li>基带同轴电缆：50欧姆，传送基带信号</li>
<li>宽带同轴电缆：75欧姆，传送宽带信号</li>
<li>特点
<ul>
<li>价格比双绞线贵</li>
<li>传输距离远，速率快</li>
<li>抗干扰能力强</li>
</ul></li>
</ul>
<h3 id="光纤">光纤</h3>
<ul>
<li>结构：从内到外为纤芯（高折射率）、包层（低折射率）</li>
<li>原理
<ul>
<li>有光脉冲表示1，无光脉冲表示0</li>
<li>利用高折射率到低折射率介质的全反射</li>
</ul></li>
<li>多模光纤：不同角度入射的多个光线在光纤中传输
<ul>
<li>光源为发光二极管，容易失真</li>
<li>适合近距离传输</li>
</ul></li>
<li>单模光纤：光纤直径只有一个光波长时，光线直线传播，不反射
<ul>
<li>光源为半导体激光器，成本高，衰减小</li>
<li>适合远距离传输</li>
</ul></li>
<li>特点
<ul>
<li>传输损耗小、远距离经济</li>
<li>抗电磁性好</li>
<li>保密性好</li>
<li>体积小，质量轻</li>
</ul></li>
</ul>
<h3 id="无线传输介质">无线传输介质</h3>
<h4 id="无线电波">无线电波</h4>
<ul>
<li>穿透性强，传输距离远</li>
<li>应用：手机通信、无线局域网WLAN</li>
</ul>
<h4 id="视线介质">视线介质</h4>
<ul>
<li>包括微波、红外线、激光，直线传播</li>
<li>应用：三个地球同步卫星作为微波信号的中继，覆盖整个地球表面</li>
<li>特点：通信容量大、距离远、覆盖广；保密性差，传播时延长</li>
</ul>
<h3 id="物理层接口的特性">物理层接口的特性</h3>
<ul>
<li>机械特性：接口的形状尺寸、引脚数和排列、固定和锁定装置</li>
<li>电气特性：接口电缆各线的电压范围</li>
<li>功能特性：各线的电压表示的意义</li>
<li>过程特性（规程特征）：不同功能的事件出现顺序</li>
<li>物理层接口标准举例：EIA RS-232-C、ADSL、SONET/SDH</li>
</ul>
<h2 id="物理层设备">物理层设备</h2>
<h3 id="中继器">中继器</h3>
<ul>
<li>转发器包括
<ul>
<li>中继器：整形并放大失真的数字信号
<ul>
<li>放大原理：信号再生</li>
</ul></li>
<li>放大器：放大衰减的模拟信号
<ul>
<li>放大原理：信号放大</li>
</ul></li>
</ul></li>
<li>没有存储转发功能
<ul>
<li>因此两侧的网段协议相同，数据传输速率相同</li>
</ul></li>
<li>5-4-3规则：5段通信介质由4个中继器串联，只有3段可以接入计算机</li>
</ul>
<h3 id="集线器">集线器</h3>
<ul>
<li>即Hub，本质是多端口中继器</li>
<li>原理：从一个端口输入数据，经过整形和放大，从其他所有端口输出
<ul>
<li>显然是半双工工作方式
<ul>
<li>同一时钟周期只能传输一组数据，因此连接的各计算机平分带宽</li>
</ul></li>
<li>连接的网络一般为星形</li>
<li>集线器连接的各工作站集合在一个冲突域和广播域中
<ul>
<li>冲突域：存在冲突问题（由网络第二层解决）的主机范围</li>
<li>广播域：存在广播问题（由网络的第三层解决）的主机范围</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第五章-传输层</title>
    <url>/2021/12/01/network5/</url>
    <content><![CDATA[<h2 id="提供的服务">提供的服务</h2>
<h3 id="功能">功能</h3>
<ul>
<li>提供应用进程之间的逻辑通信
<ul>
<li>即端到端的水平方向通信，屏蔽传输层以下的实现细节</li>
</ul></li>
<li>复用和分用
<ul>
<li>复用
<ul>
<li>不同进程能使用同一传输层协议</li>
</ul></li>
<li>分用
<ul>
<li>接收的数据能正确交付到目的进程</li>
</ul></li>
</ul></li>
<li>差错检测
<ul>
<li>比网络层的差错检测更强，首部和数据部分都检查</li>
</ul></li>
<li>可同时提供面向连接和无连接的服务
<ul>
<li>网络层同时最多只能提供一个</li>
</ul></li>
</ul>
<h3 id="寻址和端口">寻址和端口</h3>
<h4 id="端口">端口</h4>
<ul>
<li>定义：传输层的服务访问点（TSAP）</li>
<li>性质：软件端口
<ul>
<li>硬件端口是接口中的CPU可访问寄存器</li>
</ul></li>
<li>作用：使得传输层能和端口号标识的应用进程交换数据</li>
</ul>
<h4 id="端口号">端口号</h4>
<ul>
<li>定义：标识应用进程的16比特，范围0-65535</li>
<li>分类
<ul>
<li>服务器端口号
<ul>
<li>熟知端口号：0-1023，由IANA（互联网地址指派机构）分配给被熟知的应用服务进程</li>
<li>登记端口号：1024-49151，非熟知的应用服务进程在INAA处登记</li>
</ul></li>
<li>客户端口号（短暂端口号、临时端口号）
<ul>
<li>49152-65536，客户进程运行时选择，通信结束后丢弃</li>
</ul></li>
</ul></li>
</ul>
<h4 id="套接字">套接字</h4>
<p>即Socket</p>
<ul>
<li>定义
<ul>
<li>Socket=（IP地址：端口号）</li>
</ul></li>
<li>作用
<ul>
<li>唯一的标识网络中一个主机的一个应用</li>
</ul></li>
</ul>
<h3 id="无连接服务和面向连接服务">无连接服务和面向连接服务</h3>
<ul>
<li>无连接服务
<ul>
<li>基本概念：通信不需要建立连接，直接发送信息，尽力而为传送</li>
<li>常用协议：TCP/IP模型的UDP</li>
</ul></li>
<li>面向连接服务
<ul>
<li>基本概念：通信前建立连接，通信时监管连接状态，通信后释放连接</li>
<li>常用协议：TCP/IP模型的TCP</li>
</ul></li>
</ul>
<h3 id="应用举例">应用举例</h3>
<ul>
<li>FTP（文件传输协议）
<ul>
<li>端口号：20/21</li>
<li>传输层协议：TCP</li>
</ul></li>
<li>TELNET（远程登陆）
<ul>
<li>端口号：23</li>
<li>传输层协议：TCP</li>
</ul></li>
<li>SMTP（简单邮件传输协议）
<ul>
<li>端口号：25</li>
<li>传输层协议：TCP</li>
</ul></li>
<li>DNS（域名系统）
<ul>
<li>端口号：53</li>
<li>传输层协议：UDP</li>
</ul></li>
<li>TFTP（小文件传输协议）
<ul>
<li>端口号：69</li>
<li>传输层协议：UDP</li>
</ul></li>
<li>HTTP（超文本传输协议）
<ul>
<li>端口号：80</li>
<li>传输层协议：TCP</li>
</ul></li>
<li>POP3（邮局协议版本3）
<ul>
<li>端口号：110</li>
<li>传输层协议：TCP</li>
</ul></li>
<li>SNMP（简单网络管理协议）
<ul>
<li>端口号：161</li>
<li>传输层协议：UDP</li>
</ul></li>
<li>RTP（实时传输协议）
<ul>
<li>端口号：5004/5005</li>
<li>传输层协议：UDP</li>
</ul></li>
</ul>
<h2 id="udp协议">UDP协议</h2>
<h3 id="udp概述">UDP概述</h3>
<ul>
<li>功能（不提供可靠服务，应用层自行实现可靠性）
<ul>
<li>复用分用</li>
<li>差错检测</li>
</ul></li>
<li>优点
<ul>
<li>不用建立连接
<ul>
<li>没有建立连接时延</li>
</ul></li>
<li>不用维护连接
<ul>
<li>可支持更多客户机</li>
</ul></li>
<li>首部短
<ul>
<li>只有8字节</li>
</ul></li>
<li>无拥塞控制
<ul>
<li>适合<strong>允许数据较少丢失</strong>但<strong>不允许较大时延</strong>的应用</li>
</ul></li>
<li>支持一对一、一对多、多对一、多对多的通信
<ul>
<li>显然支持全双工</li>
</ul></li>
</ul></li>
</ul>
<h3 id="udp数据报">UDP数据报</h3>
<ul>
<li>结构
<ul>
<li>UDP首部（8字节）
<ul>
<li>源端口（2字节）：若不需要对方回信则默认为全0</li>
<li>目的端口（2字节）：分用时若找不到目的端口则丢弃报文，发送ICMP端口不可达</li>
<li>长度（2字节）：UDP数据报的长度，单位字节，至少是8</li>
<li>校验和（2字节）：不需要校验UDP数据报则设置为全0</li>
</ul></li>
<li>用户数据（即应用层报文）</li>
</ul></li>
</ul>
<h3 id="功能的实现">功能的实现</h3>
<ul>
<li>封装（复用）
<ul>
<li>应用层报文（不进行分割）加上首部得到UDP数据报</li>
</ul></li>
<li>拆分（分用）
<ul>
<li>UDP数据报去掉首部得到应用层的报文</li>
<li>如果首部的目的端口正确，则向上提交报文
<ul>
<li>否则丢弃报文，并给发送方回应ICMP端口不可达</li>
</ul></li>
</ul></li>
<li>校验（差错检测）
<ul>
<li>检测源IP地址、目的IP地址</li>
<li>检测首部</li>
<li>检测用户数据</li>
</ul></li>
</ul>
<h3 id="udp校验">UDP校验</h3>
<ul>
<li>发送方
<ul>
<li>校验和设置为全0</li>
<li><strong>首部前</strong>临时添加伪首部（12字节）
<ul>
<li>源IP（4字节）</li>
<li>目的IP（4字节）</li>
<li>零填充（1字节）：全0</li>
<li>协议字段（1字节）：设为17</li>
<li>UDP数据报长度（首部和数据部分）（2字节）</li>
</ul></li>
<li><strong>数据部分后</strong>临时添加0填充，使得数据部分为偶数字节</li>
<li>以16位的字为单位，每个单位看作反码编码的数，按反码求和
<ul>
<li>反码加法采用<strong>循环进位</strong>，把进位与结果相加</li>
<li><span class="math inline">\(6+(-4)=0110+1011=1\
0001=0010=2\)</span></li>
<li><span class="math inline">\((-7)+(-7)+(-7)+(-7)=1000+\cdots+1000=10\
0000=0010\)</span></li>
</ul></li>
<li>求和结果按位取反，回填到校验和中
<ul>
<li>原理：设求和结果<strong>真值</strong>为A，则校验和<strong>真值</strong>为-A，接收方的校验结果<strong>真值</strong>为-0（全1）</li>
<li>特殊处理：当求和结果为全1，不用取反成全0，直接回填即可</li>
<li>特殊处理的原理：当求和结果真值为-0，校验和真值为-0而不是+0</li>
<li>特殊处理的必要性：校验和为全0的情况，已被用来表示<strong>不采用校验和</strong></li>
<li>特殊处理的正确性：全1和全1的反码加法结果就是全1，不影响接收方的差错校验</li>
</ul></li>
<li>删去伪首部和0填充，发送UDP数据报</li>
</ul></li>
<li>接收方
<ul>
<li>首部前临时添加伪首部</li>
<li>数据部分后临时添加0填充，使得数据部分为偶数字节</li>
<li>以16位的字为单位，按反码求和
<ul>
<li>求和结果为全1才说明无差错</li>
</ul></li>
<li>若无差错，则删去伪首部和0填充，并拆分UDP数据报
<ul>
<li>否则丢弃该UDP数据报</li>
</ul></li>
</ul></li>
</ul>
<h2 id="tcp协议">TCP协议</h2>
<h3 id="tcp功能">TCP功能</h3>
<ul>
<li>提供点对点的面向连接的服务</li>
<li>提供可靠交付
<ul>
<li>数据不丢失、不重复、不失序、无差错</li>
</ul></li>
<li>提供全双工通信
<ul>
<li>发送方进程把数据发送到发送缓存
<ul>
<li>数据收到确认后再移出缓存</li>
</ul></li>
<li>接收方进程把数据从接收缓存取出
<ul>
<li>失序的数据可提前进入缓存</li>
</ul></li>
</ul></li>
<li>提供面向字节流的管道
<ul>
<li>保证双方的字节序列相同</li>
<li>不保证数据块个数相同，因为用户数据可能被分割</li>
</ul></li>
</ul>
<h3 id="tcp报文段">TCP报文段</h3>
<ul>
<li>首部（20+4N字节）
<ul>
<li>源端口（2字节）：实现复用</li>
<li>目的端口（2字节）：实现分用</li>
<li>序号seq（4字节）：用户数据部分第一个字节的在整个字节流的序号</li>
<li>确认号ack（4字节）：期待对方发送的下一个报文段的第一个字节的序号</li>
<li>数据偏移（4位）：即首部长度，以4字节为单位，首部最长60字节</li>
<li>保留（6位）：暂时没用，置为0</li>
<li>标志字段（6位）
<ul>
<li>紧急位URG：表示是否有紧急数据（一定从用户数据的第一字节开始）</li>
<li>确认位ACK：表示确认号是否有效，TCP连接建立后必须置为1</li>
<li>推送位PSH：表示是否尽快交付给进程，而不用等接收缓存满</li>
<li>复位位RST：表示出现严重差错，连接必须释放、重新建立</li>
<li>同步位SYN：SYN为1，ACK为0表示<strong>连接请求</strong>，SYN为1，ACK为1表示<strong>连接接受</strong></li>
<li>终止位FIN：表示数据发送完毕，要求释放连接</li>
</ul></li>
<li>窗口（2字节）：本报文段发送方的接收窗口大小（接收缓存的字节余量）
<ul>
<li><strong>本报文段接收方发送窗口</strong>不能大于窗口字段值（流量控制）</li>
</ul></li>
<li>校验和（2字节）：使用同UDP，唯一区别是伪首部的协议字段从17改成6</li>
<li>紧急指针（2字节）：表示紧急数据的字节数，紧急位为1时使用</li>
<li>选项
<ul>
<li>最大报文段长度MSS：表示本报文段发送方能处理的<strong>最大用户数据字节数</strong>，默认536字节</li>
<li>窗口扩大：用于扩大窗口字段</li>
<li>时间戳：既能计算<span class="math inline">\(RTT\)</span>，又能处理序号在高速传输时因超过<span class="math inline">\(2^{32}\)</span>而重复的情况</li>
<li>选择确认SACK：包含本报文段发送方缺少的数据的边界，本报文段接收方只需重传这些数据即可</li>
</ul></li>
<li>填充字段：使首部是4字节的整数倍</li>
</ul></li>
<li>用户数据（即应用层报文）</li>
</ul>
<h3 id="连接管理">连接管理</h3>
<p><em>连接采取客户/服务器方式，连接的两端即两个套接字</em></p>
<ul>
<li>连接建立
<ul>
<li>第一次握手
<ul>
<li>服务器的进程处于收听状态（LISTEN）</li>
<li>客户机向服务器发送<strong>连接请求报文段</strong>（SYN=1,ACK=0,seq=x），该报文段<strong>不携带数据但消耗一个序号</strong></li>
<li>客户进程进入同步已发送状态（SYN-SENT）</li>
</ul></li>
<li>第二次握手
<ul>
<li>服务器收到后，如果同意，发送<strong>连接确认报文段</strong>（SYN=1,ACK=1,ack=x+1,seq=y），该报文段<strong>不携带数据但消耗一个序号</strong></li>
<li>服务器为连接分配缓存和变量</li>
<li>服务器进程进入同步已收到状态（SYN-RCVD）</li>
</ul></li>
<li>第三次握手
<ul>
<li>客户机收到后，发送<strong>确认报文段</strong>（ACK=1,seq=x+1,ack=y+1），该报文段<strong>可以携带数据</strong></li>
<li>客户机分配缓存和变量</li>
<li>客户进程进入连接已建立状态（ESTABLISHED）</li>
</ul></li>
</ul></li>
<li>数据传送
<ul>
<li>全双工通信</li>
</ul></li>
<li>连接释放
<ul>
<li>第一次握手
<ul>
<li>客户机发送<strong>连接释放报文段</strong>（FIN=1,seq=u），该报文段<strong>不携带数据但消耗一个序号</strong></li>
<li>客户机停止发数据，只能收数据（全双工变单向）</li>
<li>客户进程进入终止等待1状态（FIN-WAIT-1）</li>
</ul></li>
<li>第二次握手
<ul>
<li>服务器收到后，发送<strong>确认报文段</strong>（ACK=1,seq=v,ack=u+1）</li>
<li>服务器进入关闭等待状态（CLOSE-WAIT），服务器停止收数据，只能发数据（TCP连接半关闭）</li>
<li>客户机收到后，客户进程进入终止等待2状态（FIN-WAIT-2）</li>
</ul></li>
<li>第三次握手
<ul>
<li>服务器若没有要发送的数据，则发送<strong>连接释放报文段</strong>（FIN=1,ACK=1,seq=w,ack=u+1）</li>
<li>服务器进程进入最后确认状态（LAST-ACK）</li>
</ul></li>
<li>第四次握手
<ul>
<li>客户机收到后，发送确认报文段（ACK=1,seq=u+1,ack=w+1）</li>
<li>客户进程进入时间等待状态（TIME-WAIT）。</li>
<li>服务器收到确认报文段，进入连接关闭状态（CLOSED）</li>
<li>经过2MSL（2倍最大报文段寿命）的等待时间，客户进程进入连接关闭状态（CLOSED）</li>
</ul></li>
</ul></li>
<li>补充
<ul>
<li>连接建立的第三次握手的必要性：考虑超时的连接请求突然到达服务器的情况（举例如下）
<ul>
<li>A向B的第一次握手，连接请求超时，A重传连接请求</li>
<li>A和B两次握手，传输数据，完成后断开</li>
<li>A超时的连接请求到达B，B误以为连接建立</li>
</ul></li>
<li>连接释放的第四次握手以及期间让客户机等待2MSL的必要性
<ul>
<li>考虑超时的连接请求突然到达服务器的情况（同连接建立第三次握手的必要性）</li>
<li>考虑确认报文段丢失，服务器重传连接释放报文段的情况</li>
</ul></li>
<li>连接建立中，易受到<strong>SYN泛洪攻击</strong>的原因
<ul>
<li>根本原因：第二次握手服务器分配资源，第三次握手客户机分配资源</li>
<li>直接原因：客户机发送大量SYN连接请求，服务器分配太多资源导致崩溃</li>
</ul></li>
<li>连接建立中，初始序号随即设置而不固定的原因
<ul>
<li>防止新连接和旧连接的报文段序号冲突，因此新连接和近期旧连接的初始序号不同</li>
</ul></li>
</ul></li>
</ul>
<h3 id="可靠传输">可靠传输</h3>
<p><em>可靠传输，即保证数据不丢失、不重复、不失序、无差错</em></p>
<ul>
<li>确认机制
<ul>
<li>使用首部的确认号字段，保证数据不重复（默认累计确认）</li>
</ul></li>
<li>重传机制
<ul>
<li>下面两种情况进行重传，保证数据不丢失</li>
<li>超时
<ul>
<li>发送报文段后开启计时器</li>
<li>超时重传时间<span class="math inline">\(RTO\)</span>略大于加权平均往返时间<span class="math inline">\(RTT_s=(1-\alpha) RTT_s+\alpha RTT\)</span></li>
<li><span class="math inline">\(RTT\)</span>为最近一次发送到接收的间隔（不考虑重传间隔，因为重传确认和原确认难区分）</li>
<li>权值<span class="math inline">\(\alpha\in [0,1)\)</span></li>
</ul></li>
<li>冗余确认（冗余ACK）
<ul>
<li>发送方收到三个冗余确认时（报文段确认号相同），则认为从该确认号开始的报文段丢失，进行<strong>快速重传</strong>（即没有超时也立刻重传）</li>
</ul></li>
</ul></li>
<li>序号机制
<ul>
<li>使用首部的序号字段，保证数据不失序</li>
</ul></li>
<li>校验机制
<ul>
<li>使用首部的校验和字段，保证数据无差错</li>
</ul></li>
</ul>
<h3 id="流量控制">流量控制</h3>
<ul>
<li>和数据链路层流量控制的相同之处
<ul>
<li>流量控制目的：匹配发送方和接收方的速率</li>
<li>流量控制原理：基于滑动窗口机制</li>
</ul></li>
<li>和数据链路层流量控制的不同之处
<ul>
<li>TCP是端到端的流量控制，数据链路层是点到点的流量控制</li>
<li>TCP的滑动窗口能动态调整
<ul>
<li>接收方根据自己接收缓存的字节余量（接收窗口<span class="math inline">\(rwnd\)</span>），发送确认时设置窗口字段，动态调节发送方发送窗口大小</li>
</ul></li>
<li>TCP采取累计确认，但提供选择确认选项SACK
<ul>
<li>是GBN和SR的混合体</li>
</ul></li>
</ul></li>
</ul>
<h3 id="拥塞控制">拥塞控制</h3>
<h4 id="拥塞窗口">拥塞窗口</h4>
<ul>
<li>拥塞窗口<span class="math inline">\(cwnd\)</span>
<ul>
<li>对网络拥塞程度进行估计而设置的窗口（单位字节）</li>
<li>己方的发送窗口的上限为<span class="math inline">\(\min\{cwnd,rwnd\}\)</span>
<ul>
<li><span class="math inline">\(cwnd\)</span>是己方的拥塞窗口，通过后面的拥塞控制算法获得</li>
<li><span class="math inline">\(rwnd\)</span>是对方的接收窗口，通过对方发送的报文段的窗口字段获得</li>
</ul></li>
</ul></li>
<li>拥塞控制算法包括
<ul>
<li>慢开始</li>
<li>拥塞避免</li>
<li>快重传</li>
<li>快恢复</li>
</ul></li>
<li>接下来<strong>描述拥塞控制算法</strong>时，把己方最大报文段长度MSS作为己方拥塞窗口的单位
<ul>
<li>该做法只为了表述方便，实际上拥塞窗口的单位是字节</li>
</ul></li>
</ul>
<h4 id="慢开始和拥塞避免">慢开始和拥塞避免</h4>
<ul>
<li>慢开始
<ul>
<li>刚建立连接，开始发送报文段时，<span class="math inline">\(cwnd=1\)</span></li>
<li>每收到一个新报文段的确认，<span class="math inline">\(cwnd=cwnd+1\)</span>
<ul>
<li>冗余的确认不算</li>
<li>累计的一个新确认算作多个新确认</li>
</ul></li>
<li>大约每经过一个<span class="math inline">\(RTT\)</span>，<span class="math inline">\(cwnd=\min\{2cwnd,ssthresh\}\)</span>
<ul>
<li>大约每经过一个<span class="math inline">\(RTT\)</span>，<span class="math inline">\(cwnd\)</span>会翻倍</li>
<li>翻倍时不能跳过慢开始阈值<span class="math inline">\(ssthresh\)</span></li>
</ul></li>
<li>拥塞窗口到达<span class="math inline">\(ssthresh\)</span>后改用拥塞避免算法
<ul>
<li><span class="math inline">\(cwnd&lt;ssthresh\)</span>，使用慢开始</li>
<li><span class="math inline">\(cwnd=ssthresh\)</span>，默认改用拥塞避免，也可使用慢开始</li>
<li><span class="math inline">\(cwnd&gt;ssthresh\)</span>，使用拥塞避免</li>
</ul></li>
</ul></li>
<li>拥塞避免
<ul>
<li>每经过一个<span class="math inline">\(RTT\)</span>，<span class="math inline">\(cwnd=cwnd+1\)</span>
<ul>
<li>拥塞窗口从指数增长变成线性增长，以避免拥塞</li>
</ul></li>
</ul></li>
<li>确认超时
<ul>
<li>慢开始或拥塞避免阶段若出现确认超时，则认为网络出现拥塞
<ul>
<li><span class="math inline">\(ssthresh=\min\{\frac{cwnd}{2},2\}\)</span></li>
<li><span class="math inline">\(cwnd=1\)</span></li>
</ul></li>
<li>回到慢开始阶段</li>
</ul></li>
</ul>
<h4 id="快重传和快恢复">快重传和快恢复</h4>
<p><em>本节在慢开始和拥塞避免的基础上改进</em></p>
<ul>
<li>快重传
<ul>
<li>收到三个冗余确认时（报文段确认号相同），则认为从该确认号开始的报文段丢失，进行快速重传（即没有超时也立刻重传）</li>
<li>冗余的确认表明网络略微拥塞导致丢包，但不是严重拥塞，否则无法收到确认
<ul>
<li>转入快恢复处理</li>
</ul></li>
</ul></li>
<li>快恢复
<ul>
<li><span class="math inline">\(ssthresh=\min\{\frac{cwnd}{2},2\}\)</span></li>
<li><span class="math inline">\(cwnd=ssthresh\)</span></li>
<li>转入拥塞避免阶段，拥塞窗口线性增加</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第六章-应用层</title>
    <url>/2021/12/03/network6/</url>
    <content><![CDATA[<h2 id="网络应用模型">网络应用模型</h2>
<h3 id="客户服务器模型">客户/服务器模型</h3>
<ul>
<li>即Cient/Server模型、C/S模型
<ul>
<li>服务器是服务提供方，要一直保持运行状态</li>
<li>客户是服务请求方，要实现知道服务器的地址</li>
</ul></li>
<li>工作流程
<ul>
<li>服务器处于接收请求状态</li>
<li>客户机发出服务请求，等待结果</li>
<li>服务器收到后，分析请求、处理、把结果发给客户机</li>
</ul></li>
<li>特征
<ul>
<li>非对称
<ul>
<li>占少数的服务器集中管理整个网络</li>
<li>占多数的客户机的权限由服务器管理限制</li>
</ul></li>
<li>客户机之间不能通信</li>
<li>服务器支持的客户机数有限</li>
</ul></li>
<li>应用举例
<ul>
<li>FTP</li>
<li>TELNET</li>
<li>SMTP</li>
<li>DNS</li>
<li>WWW（Web）</li>
</ul></li>
</ul>
<h3 id="对等模型">对等模型</h3>
<ul>
<li>即P2P模型
<ul>
<li>P2P网络是由对等结点组成的逻辑网络</li>
</ul></li>
<li>特征
<ul>
<li>各计算机地位对称，既是客户，又是服务器
<ul>
<li>获取服务的同时需要提供服务，也算缺点</li>
</ul></li>
<li>任意一对计算机（对等方）直接相互通信</li>
<li>网络单结点失效不影响其他结点</li>
</ul></li>
<li>应用举例
<ul>
<li>PPlive</li>
<li>Bittorrent</li>
<li>电驴</li>
</ul></li>
</ul>
<h2 id="域名系统dns">域名系统DNS</h2>
<h3 id="层次域名空间">层次域名空间</h3>
<ul>
<li>域名：网络设备的一种具有层次结构的命名
<ul>
<li>比如www.google.com是谷歌搜索服务器的域名</li>
<li>".com"顶级域名、".google"二级域名、"www"三级域名</li>
</ul></li>
<li>概念介绍
<ul>
<li>域名
<ul>
<li>多个标号的序列，标号间"."隔开</li>
<li>每个标号对应一个子域名，且从左到右域名级别递增，最右边是顶级域名</li>
<li>不超过255各字符</li>
</ul></li>
<li>标号
<ul>
<li>由字母、数字、"-"组成</li>
<li>不区分大小写</li>
<li>不超过63个字符</li>
</ul></li>
<li>顶级域名
<ul>
<li>国家顶级域名：".cn"是中国、".us"是美国</li>
<li>通用顶级域名：".com"是公司、".org"是非营利组织</li>
<li>基础结构域名：".arpa"反向域名解析（唯一的基础结构域名）</li>
</ul></li>
<li>层次域名空间
<ul>
<li>各个域的关系可以用树状层次结构表示</li>
<li>各个域的管理组织不同，子域由子组织管理</li>
</ul></li>
</ul></li>
</ul>
<h3 id="域名服务器">域名服务器</h3>
<ul>
<li>域名服务器：采用<strong>C/S模型</strong>的分布式数据库系统，<strong>提供从域名到IP地址的解析</strong>
<ul>
<li>若不能进行解析，则给用户提供寻找其他域名服务器的信息</li>
</ul></li>
<li>区：一个域名服务器的管辖范围</li>
<li>域名系统（DNS）：以层次方式组织大量域名服务器，提供域名解析服务</li>
<li>域名服务器按层次的分类
<ul>
<li>根域名服务器
<ul>
<li>13个相互冗余的根域名服务器组成服务器集群，管理所有顶级域名服务器的IP地址</li>
<li>提供下一步要查询的顶级域名服务器的IP地址</li>
</ul></li>
<li>顶级域名服务器
<ul>
<li>管理该域名服务器所注册的所有二级域名</li>
<li>提供最终结果的IP地址或下一步要查询的域名服务器的IP地址</li>
</ul></li>
<li>授权域名服务器（又叫权限域名服务器，<strong>可以涉及多个层次</strong>）
<ul>
<li>管理在服务器注册的所有主机（一台主机一般在多个服务器注册）</li>
<li>提供从主机名到主机IP地址的转换</li>
</ul></li>
<li>本地域名服务器
<ul>
<li>每个因特网服务提供者（ISP）可以拥有一个本地域名服务器</li>
<li>处理本地主机的DNS查询请求</li>
</ul></li>
</ul></li>
</ul>
<h3 id="域名解析过程">域名解析过程</h3>
<ul>
<li>正向解析：域名映射到IP地址</li>
<li>反向解析：IP地址映射到域名</li>
<li>DNS请求报文：由用户机的DNS客户端构造，装入UDP，发往服务器，请求域名解析服务</li>
<li>域名解析方式
<ul>
<li>注：
<ul>
<li>为描述简洁，域名服务器简写，比如“根域名服务器”简写为“根”</li>
<li>低层服务器看作是高层服务器的用户机</li>
</ul></li>
<li>递归查询（负载较大，很少使用）
<ul>
<li>主机、本地、根、顶级、权限、顶级、根、本地、主机</li>
</ul></li>
<li>递归与迭代相结合的查询（常用）
<ul>
<li>完整的递归迭代查询：主机、<strong>本地</strong>、根、<strong>本地</strong>、顶级、<strong>本地</strong>、权限、<strong>本地</strong>、主机</li>
<li>不完整的递归迭代查询：前三个<strong>本地</strong>的任意一个，若已经查到了域名的IP地址，可以提前结束迭代，返回主机</li>
<li>退化为递归查询：主机、本地、主机</li>
</ul></li>
</ul></li>
<li>高速缓存
<ul>
<li>DNS服务器获得DNS查询结果后，除了将其发送给用户机，还要将其保存到高速缓存
<ul>
<li>方便之后相同的域名查询</li>
<li>高速缓存内容不永久保存，定期丢弃</li>
</ul></li>
</ul></li>
</ul>
<h2 id="文本传输协议ftp">文本传输协议FTP</h2>
<h3 id="工作原理">工作原理</h3>
<ul>
<li>功能
<ul>
<li>以用户登陆方式，获得远程FTP服务器的文件的管理权限
<ul>
<li>上传和下载</li>
</ul></li>
<li>以匿名方式（非用户登陆方式）提供公用文件的共享</li>
<li>提供不同种主机间的文件传输</li>
</ul></li>
<li>服务器的进程组成
<ul>
<li>一个主进程（端口号21）
<ul>
<li>接收新请求</li>
</ul></li>
<li>若干从属进程
<ul>
<li>处理单个请求</li>
</ul></li>
</ul></li>
<li>从属进程类型
<ul>
<li>控制进程（端口号21）</li>
<li>数据传送进程（默认情况端口号20）</li>
</ul></li>
<li>工作步骤
<ul>
<li>主进程等待客户连接请求</li>
<li>主进程收到客户连接请求，启动控制进程，建立<strong>控制连接</strong>
<ul>
<li>会话结束后终止控制进程</li>
</ul></li>
<li>控制进程收到客户数据传输请求，启动数据传送进程，建立<strong>数据连接</strong>
<ul>
<li>传送完后终止数据传送进程</li>
</ul></li>
<li>会话结束后，继续等待其他客户请求</li>
</ul></li>
</ul>
<h3 id="控制连接和数据连接">控制连接和数据连接</h3>
<ul>
<li>控制连接
<ul>
<li>两端进程：控制进程</li>
<li>服务器端口号：21</li>
<li>用户端口号：用户随机分配</li>
<li>功能：以ASCII格式传送控制信息，如数据连接请求、数据传送请求、中止传输命令等</li>
<li>带外传送：指控制连接和数据连接分离的传送方式</li>
</ul></li>
<li>数据连接
<ul>
<li>两端进程：数据传送进程</li>
<li>服务器端口号
<ul>
<li>主动模式：20</li>
<li>被动模式：服务器随机分配</li>
</ul></li>
<li>用户端口号：用户随机分配</li>
<li>功能：完成客户端和服务器端的文件数据传送</li>
<li>传送模式：默认为主动模式
<ul>
<li>主动模式PORT：客户发送PORT命令和客户端口号，再由服务器发起连接</li>
<li>被动模式PASV：客户发送PASV命令获取服务器端口号，再由客户机发起连接</li>
</ul></li>
</ul></li>
</ul>
<h3 id="文件修改方式">文件修改方式</h3>
<ul>
<li>传统的FTP
<ul>
<li>在本地复制远程文件的整个副本，修改后传回服务器，很耗时</li>
</ul></li>
<li>网络文件系统NFS
<ul>
<li>在本地复制远程文件的特定片段，修改后传回服务器，速度快</li>
</ul></li>
</ul>
<h2 id="电子邮件">电子邮件</h2>
<h3 id="电子邮件系统的组成结构">电子邮件系统的组成结构</h3>
<ul>
<li>用户代理
<ul>
<li>用户和电子邮件系统的接口（即邮件客户端软件）</li>
<li>提供邮件撰写、显示、处理、通信的功能</li>
</ul></li>
<li>邮件服务器
<ul>
<li>功能是发送和接收邮件</li>
<li>结构包括邮件缓存和用户邮箱</li>
<li>举例：qq邮件服务器、189邮件服务器等</li>
</ul></li>
<li>电子邮件的协议
<ul>
<li>发送协议（SMTP协议）
<ul>
<li>发送方用户代理（客户）数据<strong>推</strong>到发送方邮件服务器（服务器）的<strong>邮件缓存</strong></li>
<li>发送方邮件服务器（客户）发送数据到接收方邮件服务器（服务器）的<strong>用户邮箱</strong></li>
</ul></li>
<li>接收协议（POP3协议或IMAP协议）
<ul>
<li>接收方邮件服务器（服务器）数据<strong>拉</strong>到接收方用户代理（客户）</li>
</ul></li>
</ul></li>
</ul>
<h3 id="电子邮件格式">电子邮件格式</h3>
<ul>
<li>信封
<ul>
<li>自动填写</li>
</ul></li>
<li>内容
<ul>
<li>首部
<ul>
<li>From（自动填写）：[发送方用户邮箱名]@[发送方邮件服务器的域名]</li>
<li>To（用户必填）：[接收方用户邮箱名]@[接收方邮件服务器的域名]</li>
<li>Subject（用户选填）：[邮件的主题]</li>
</ul></li>
<li>主体
<ul>
<li>用户撰写的邮件内容（ASCII码）</li>
</ul></li>
</ul></li>
</ul>
<h3 id="mime">MIME</h3>
<p>即多用途网际邮件扩充</p>
<ul>
<li>功能
<ul>
<li>使得SMTP除了支持ASCII码，还支持其他编码以及二进制文件的发送</li>
</ul></li>
<li>实现
<ul>
<li>不改变SMTP</li>
<li>新定义了首部字段、主体结构、传送非ASCII码的规则</li>
</ul></li>
</ul>
<h3 id="smtp与pop3">SMTP与POP3</h3>
<ul>
<li>SMTP
<ul>
<li>连接建立
<ul>
<li>发送方邮件服务器定期扫描缓存</li>
<li>缓存发现邮件，则在端口25和接收方服务器建立TCP连接</li>
<li>接收方回复220 Service ready</li>
<li>发送方发出HELO，带有发送方主机名</li>
</ul></li>
<li>邮件传送
<ul>
<li>发送方发出的MAIL，带有发件人地址</li>
<li>接收方回复250 OK</li>
<li>发送方发出若干RCPT，确认接收方是否做好准备</li>
<li>接收方回复250 OK或No such user here</li>
<li>发送方发出DATA，传输邮件内容</li>
<li>接收方回复354 Start mail input；end with <CRLF>.<CRLF></CRLF></CRLF></li>
<li>发送方发出<CRLF>.<CRLF>，表示邮件内容结束</CRLF></CRLF></li>
</ul></li>
<li>连接释放
<ul>
<li>发送方发出QUIT</li>
<li>接收方回复221</li>
<li>进行TCP的连接释放</li>
</ul></li>
</ul></li>
<li>POP3
<ul>
<li>端口号110，基于TCP</li>
<li>工作方式（由POP3客户决定）
<ul>
<li>下载并保留：下载后邮件保留在邮箱</li>
<li>下载并删除：下载后邮件删除</li>
</ul></li>
<li>传输方式
<ul>
<li>明文传输</li>
</ul></li>
</ul></li>
<li>IMAP
<ul>
<li>比POP3复杂，但都是用于邮件接收</li>
</ul></li>
</ul>
<h3 id="http">HTTP</h3>
<p>在万维网的邮件系统中使用HTTP协议 +
用户代理（浏览器）和邮件服务器以HTTP发送和接收邮件</p>
<h2 id="www">WWW</h2>
<h3 id="www的概念和组成结构">WWW的概念和组成结构</h3>
<h4 id="基本概念">基本概念</h4>
<ul>
<li>万维网（WWW）：联机分布式的信息储藏所
<ul>
<li>万维网由大量网络站点互联</li>
<li>每个站点包含若干文档（页面、资源）</li>
</ul></li>
<li>超链接（链接）：从一个文档访问另一个文档的方法</li>
<li>超文本：包含链接的文档（纯文本）</li>
<li>超媒体：包含链接的文档（除了文本，还包含图像、声音、视频等媒体）</li>
<li>互联网、因特网、万维网的关系
<ul>
<li>互联网：多个计算机网络按协议连接的大型网络</li>
<li>因特网：实际已有的最大的互联网，包括网络站点、电子邮件、新闻组等</li>
<li>万维网：因特网的主要部分</li>
</ul></li>
</ul>
<h4 id="组成结构">组成结构</h4>
<ul>
<li>统一资源定位符（URL）：唯一的标识万维网的文档
<ul>
<li>例如："http://www.tsinghua.edu.cn:80/zjqh/xxgk1.htm"</li>
<li>结构：[传送协议]://[服务器主机域名]：[端口]/[路径]</li>
<li>注：传送协议一般是http或fps，端口一般省略</li>
</ul></li>
<li>超文本传输协议（HTTP）：基于TCP的应用层协议，在浏览器客户端和Web服务器之间传送超文本</li>
<li>超文本标记语言（HTML）：对页面进行描述的语言</li>
</ul>
<h3 id="http-1">HTTP</h3>
<h4 id="操作过程">操作过程</h4>
<ul>
<li>浏览器分析URL，得到URL的四个成分，传送协议是http</li>
<li>浏览器请求DNS解析URL中的服务器主机域名，得到服务器IP地址</li>
<li>浏览器与服务器的端口80建立TCP连接</li>
<li>浏览器发出HTTP请求，GET/[路径]</li>
<li>服务器发出HTTP响应，回复路径对应的文档</li>
<li>释放TCP</li>
<li>浏览器解释文档，并显示给用户</li>
</ul>
<h4 id="特点">特点</h4>
<ul>
<li>HTTP是无连接的
<ul>
<li>传送数据前不需要建立HTTP连接</li>
</ul></li>
<li>HTTP是无状态的
<ul>
<li>服务器不跟踪用户活动</li>
<li>可以用Cookie加数据库跟踪用户活动
<ul>
<li>Cookie在服务器生成，在浏览器储存</li>
</ul></li>
</ul></li>
<li>可以非持久连接和持久连接
<ul>
<li>非持久连接：服务器发送响应后释放TCP
<ul>
<li>比如前面的操作过程</li>
</ul></li>
<li>持久连接：服务器发送响应后保持TCP
<ul>
<li>非流水线方式（HTTP/1.0）：浏览器收到响应才能发出下一个请求</li>
<li>流水线方式（HTTP/1.1）：可以连续发送请求给浏览器</li>
</ul></li>
</ul></li>
</ul>
<h4 id="报文结构">报文结构</h4>
<p><em>注：每个字段都是ASCII码</em></p>
<ul>
<li>请求报文
<ul>
<li>请求行：[方法][空格][URL][空格][HTTP版本][CRLF]
<ul>
<li>GET方法：请求服务器响应并返回实体</li>
<li>HEAD方法：请求服务器响应，不返回实体</li>
<li>POST方法：给服务器发送注释</li>
<li>CONNECT方法：用于代理服务器</li>
<li>PUT方法：在URL处存储一个文档</li>
<li>DELETE方法：删除URL对应文档</li>
<li>CRLF：回车换行</li>
</ul></li>
<li>首部：包含若干首部行，每个首部行结构为[字段名][:][空格][值][CRLF]
<ul>
<li>Host字段：服务器主机域名</li>
<li>Connection字段：close或open，表示是否持久连接</li>
<li>User-Agent：浏览器名称和版本</li>
<li>Accept-Language：比如cn表示请求服务器优先响应中文文档</li>
</ul></li>
<li>[CRLF]</li>
<li>实体主体：通常不用</li>
</ul></li>
<li>响应报文
<ul>
<li>状态行：[版本][空格][状态码][空格][短语][CRLF]
<ul>
<li>状态码（3位5类）：通知收到（1xx）、接受请求（2xx）、资源位置已转移（3xx）、客户差错（4xx）、服务器差错（5xx）</li>
<li>短语：对状态码简单解释</li>
</ul></li>
<li>首部：包含若干首部行
<ul>
<li>首部行：[字段名][:][空格][值][CRLF]</li>
</ul></li>
<li>[CRLF]</li>
<li>实体主体：包含一个请求对象（如文本、一张图片），有时不用</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第一章-操作系统概述</title>
    <url>/2021/11/07/operatingSystem1/</url>
    <content><![CDATA[<h2 id="基本概念">基本概念</h2>
<h3 id="概念">概念</h3>
<ul>
<li>定义：操作系统是管理分配计算机系统软硬件资源，组织调度计算机工作，为用户和其他软件提供接口环境的程序集合</li>
<li>地位：操作系统是计算机系统最基本的系统软件</li>
</ul>
<h3 id="基本特征">基本特征</h3>
<ul>
<li>并发
<ul>
<li>通过引入进程，使得计算机系统有处理和调度多个程序同时间间隔运行的能力</li>
<li>和并行有区别，并行指的是同时刻，并发指的是同间隔</li>
</ul></li>
<li>共享
<ul>
<li>即资源共享，包括互斥共享方式、同时访问方式</li>
<li>互斥共享方式：对于临界资源（独占资源），一段时间只允许一个进程访问，如打印机和磁带</li>
<li>同时访问方式：一段时间内可以分时的共享某资源，宏观上是同时访问资源，如磁盘设备</li>
<li>并发和共享相互依存，是操作系统<strong>最基本的特征</strong></li>
</ul></li>
<li>虚拟
<ul>
<li>虚拟技术把实体变成用户感觉的逻辑对应物</li>
<li>虚拟处理器技术（时分复用技术）：分时的使用一个实体CPU，逻辑上变成多个虚拟CPU供每个用户使用</li>
<li>虚拟存储器技术（空分复用技术）：通过外存实现内存容量的扩展，使得用户感觉到更大的（虚拟）内存容量</li>
<li>虚拟设备技术：把一台IO物理设备虚拟为多台逻辑IO设备，逻辑上变成多个虚拟IO设备供每个用户使用</li>
</ul></li>
<li>异步：指进程的执行断断续续，以不可预测速度推进，操作系统处于随机的环境中</li>
</ul>
<h3 id="功能">功能</h3>
<ul>
<li>资源的管理者
<ul>
<li>处理机管理：进程的管理，如控制、同步、通信、死锁处理、调度等</li>
<li>存储器管理：内存分配和回收、地址映射、内存保护、内存扩充等</li>
<li>文件管理：操作系统的文件系统部分管理文件，比如文件存储空间的管理、目录管理、文件读写管理和保护等</li>
<li>设备管理：完成用户IO请求、方便用户使用、提供设备利用率，具体包括缓冲管理、设备分配、设备处理、虚拟设备等</li>
</ul></li>
<li>软硬件的接口
<ul>
<li>命令接口
<ul>
<li>联机命令接口：对应联机作业控制方式，控制台输入一行命令，执行一行命令，适合分时或实时系统</li>
<li>脱机命令接口：对应脱机作业控制方式，把一批命令写出说明书一起给系统，由命令解释程序执行，适合批处理系统</li>
</ul></li>
<li>程序接口
<ul>
<li>由系统调用（广义指令）组成</li>
<li>编程人员通过系统调用请求操作系统提供服务</li>
</ul></li>
</ul></li>
<li>扩充机器
<ul>
<li>又叫虚拟机</li>
<li>把裸机改造成功能更强的机器</li>
</ul></li>
</ul>
<h2 id="发展历程">发展历程</h2>
<ul>
<li>手工操作阶段
<ul>
<li>人工装入程序、运行、输出，无操作系统</li>
<li>用户独占全机器，资源利用率低</li>
<li>CPU等待手工操作，CPU利用不充分</li>
</ul></li>
<li>批处理阶段
<ul>
<li>解决人机矛盾、CPU和IO设备速度不匹配矛盾</li>
<li>脱机技术，解决独占设备的问题</li>
<li>开始出现操作系统，采用多道程序设计技术形成多道批处理操作系统（需要管理资源）</li>
<li>单道批处理系统
<ul>
<li>无需人工，成批按顺序对作业处理</li>
<li>内存只有一道作业，资源利用率受到限制</li>
</ul></li>
<li>多道批处理系统
<ul>
<li>内存存放多道独立的程序</li>
<li>宏观并行，微观串行</li>
<li>资源利用率高、系统吞吐量大</li>
<li>不能人机交互</li>
</ul></li>
</ul></li>
<li>分时操作系统
<ul>
<li>分时技术指按时间片轮流把处理器分配给各<strong>联机</strong>作业使用</li>
<li>多个用户宏观上<strong>同时</strong>且<strong>独立的</strong>和系统<strong>交互</strong>，系统响应<strong>及时</strong></li>
<li>特点：同时性、独立性、交互性、及时性</li>
</ul></li>
<li>实时操作系统
<ul>
<li>可以在比时间片更短的时间内，完成紧急任务</li>
<li>硬实时操作系统：要求紧急任务绝对完成，如飞行器的飞行控制系统</li>
<li>软实时操作系统：偶尔可以没完成，不会有永久性破坏。如飞机订票系统、银行管理系统</li>
<li>特点：及时性、可靠性</li>
</ul></li>
<li>网络操作系统：实现各计算机的资源管理、资源共享和通信，集中控制</li>
<li>分布式操作系统
<ul>
<li>分布式计算机系统
<ul>
<li>通信方式交换信息</li>
<li>各计算机地位对称</li>
<li>资源全局共享</li>
<li>一个工作可以分布在几台计算机上<strong>协同</strong>完成（和网络操作系统的区别）</li>
</ul></li>
<li>管理分布式计算机系统的是分布式操作系统，在网络操作系统之上，分布式控制</li>
</ul></li>
<li>个人计算机操作系统
<ul>
<li>比如Windows、Linux、Macintosh</li>
<li>最广泛的操作系统</li>
</ul></li>
</ul>
<h2 id="程序运行环境">程序运行环境</h2>
<h3 id="cpu运行模式">CPU运行模式</h3>
<ul>
<li>原语：操作系统最底层的不可分割的原子操作，操作时间短、调用频繁</li>
<li>特权指令
<ul>
<li>只有操作系统才能执行的指令</li>
<li>包括系统调用指令、时钟操作指令、中断操作指令、原语指令</li>
</ul></li>
<li>内核模式：运行内核程序（管理程序），执行特权指令</li>
<li>用户模式：运行用户程序，执行非特权指令</li>
</ul>
<h3 id="中断和异常的处理">中断和异常的处理</h3>
<ul>
<li>详见计算机组成原理第五章的异常和中断机制</li>
</ul>
<h3 id="系统调用">系统调用</h3>
<ul>
<li>指用户请求操作系统的服务，由操作系统代为执行资源有关的操作（必然用到特权指令）</li>
<li>系统调用会导致用户态进入内核态，需要在用户态执行访管指令（不是特权指令）</li>
<li>系统调用分为
<ul>
<li>设备管理类</li>
<li>文件管理类</li>
<li>进程控制类</li>
<li>进程通信类</li>
<li>内存管理类</li>
</ul></li>
</ul>
<h3 id="程序的链接和装入">程序的链接和装入</h3>
<ul>
<li>链接：编译后的一组目标模块和库函数，经过链接器，链接一起形式装入模块</li>
<li>装入：装入程序把装入模块送入内存运行</li>
<li>链接方式
<ul>
<li>静态链接：程序运行之前链接</li>
<li>装入时动态链接：程序装入内存时链接</li>
<li>运行时动态链接：程序运行时用到某模块再链接某模块</li>
</ul></li>
<li>装入方式
<ul>
<li>绝对装入
<ul>
<li>含义：按装入模块的地址，装入程序和数据至内存</li>
<li>特点：只适合单道程序环境</li>
</ul></li>
<li>可重定位装入（静态重定位）
<ul>
<li>含义：装入模块的相对地址在装入时一次性变换为绝对地址</li>
</ul></li>
<li>动态运行时装入（动态重定位）
<ul>
<li>含义：装入模块的相对地址在程序真正执行时变换为绝对地址</li>
<li>特点：程序可以在存储区中不连续、装入部分代码即可运行、运行期间动态申请分配空间、用户地址空间比存储空间大</li>
</ul></li>
</ul></li>
</ul>
<h3 id="进程的内存映像">进程的内存映像</h3>
<ul>
<li>代码段：可读、可多个进程共享、大小指定不变</li>
<li>数据段：全局变量和静态变量、大小指定不变</li>
<li>进程控制块PCB：存放在系统区，控制和管理进程</li>
<li>堆：存放动态变量、大小动态变化</li>
<li>栈：存放局部变量、实现函数调用、大小动态变化</li>
<li>下图是一个进程的内存映像举例
<ul>
<li>操作系统内核区存放内核代码、PCB等</li>
<li>共享库存放例如printf等库函数</li>
<li>.data是已初始化全局变量、静态变量</li>
<li>.bss是未初始化和所有初始化为0的全局变量和静态变量</li>
<li>.init是程序初始化函数</li>
<li>.text是用户程序代码</li>
<li>.rodata是只读数据</li>
</ul></li>
</ul>
<img src="/2021/11/07/operatingSystem1/mirror.jpg" class title="this is mirror">
<h3 id="地址空间">地址空间</h3>
<ul>
<li>进程有独立的（虚拟）地址空间</li>
<li>进程运行时看到的都是虚拟地址</li>
<li>操作系统通过内存管理单元MMU把虚拟地址转化为物理地址</li>
</ul>
<h2 id="操作系统结构">操作系统结构</h2>
<h3 id="分层">分层</h3>
<ul>
<li>最底层（层0）：硬件</li>
<li>最高层（层n）：用户接口</li>
<li>单向依赖：每层只能调用相邻底层的功能</li>
<li>优点
<ul>
<li>调试实现方便：从低层开始调试验证，逐层向上</li>
<li>扩充和维护方便：增、改一个层次，只要不改接口，不影响其他层次</li>
</ul></li>
<li>缺点
<ul>
<li>不灵活：层之间关系固定</li>
<li>效率差：执行一个功能要引入各个层之间的通信开销</li>
</ul></li>
</ul>
<h3 id="模块化">模块化</h3>
<ul>
<li>模块-接口设计法
<ul>
<li>操作系统看作大模块</li>
<li>每个模块可以划分为多个子模块，需要规定子模块功能和模块间通信接口</li>
<li>划分模块需要考虑独立性
<ul>
<li>模块内要独立性低，即内聚性高</li>
<li>模块间要独立性高，即耦合度低</li>
</ul></li>
</ul></li>
<li>优点
<ul>
<li>提供设计的正确性、可理解性、可维护性</li>
<li>增强操作系统可适应性</li>
<li>加速开发</li>
</ul></li>
<li>缺点
<ul>
<li>各模块之间的关系不全是单向依赖，调试顺序难确定</li>
<li>接口实际需求难以规定</li>
</ul></li>
</ul>
<h3 id="宏内核">宏内核</h3>
<ul>
<li>系统主要功能模块都放到内核态。又叫大内核、单内核</li>
<li>优点：各模块共享信息，性能好</li>
<li>缺点：结构逐渐复杂，内核容易崩溃</li>
<li>目前主流的操作系统都是宏内核架构</li>
</ul>
<h3 id="微内核">微内核</h3>
<ul>
<li>系统最基本功能模块（与CPU、IO硬件有关）放到微内核；大部分的其余模块（进程管理、存储管理、文件管理等服务器）放到用户态（服务器以进程形式实现）</li>
<li>优点
<ul>
<li>设计简单：内核中功能少</li>
<li>拓展灵活：拓展时基本无需修改内核代码</li>
<li>安全可靠：一个模块崩溃不导致内核崩溃</li>
<li>可移植性好</li>
<li>分布式计算：用户和服务器间、服务器间采用通信采用消息传递机制，适合分布式系统和网络系统</li>
</ul></li>
<li>缺点：性能差，需要频繁在内核态和用户态间切换</li>
<li>可以把一些频繁使用的模块放回内核，是提高性能和简化内核的折中</li>
<li>在实时、工业、航空、军事领域流行，因为对可靠性有要求</li>
</ul>
<h3 id="外核">外核</h3>
<ul>
<li>外核可以指一种操作系统结构设计，也可以指多道程序</li>
<li>多道程序是内核态唯一运行的程序，任务是给各个用户的虚拟机分配资源</li>
<li>一个用户一个虚拟机，每个虚拟机可以运行各自的操作系统，但只能使用分配给自己的资源</li>
<li>优点：减少映像层；把多道程序（内核态）和用户操作系统代码（用户态）分离</li>
</ul>
<h2 id="操作系统引导">操作系统引导</h2>
<ul>
<li>概念铺垫
<ul>
<li>引导：找到后续程序的位置，以执行</li>
<li>操作系统引导：计算机启动时，找到操作系统程序的硬盘位置，并加载到内存的过程</li>
<li>BOOT
<ul>
<li>含义：计算机开机时的入口引导程序，存放在ROM中</li>
<li>功能：进行硬件初始化，包括引导BIOS</li>
</ul></li>
<li>BIOS
<ul>
<li>含义：又叫基本输入输出系统，是固化在内存的程序，可以直接从其第一条指令开始执行</li>
<li>功能：硬件自检和引导MBR</li>
</ul></li>
<li>MBR
<ul>
<li>含义：全称主引导记录，又叫主引导扇区（Boot
Sector），是<strong>引导硬盘</strong>第一个扇区</li>
<li>功能：找到<strong>活动分区</strong>，即操作系统在硬盘的位置。MBR内有引导程序可引导PBR</li>
</ul></li>
<li>引导硬盘：即系统盘、启动盘，是存有操作系统的硬盘，第一个扇区是主引导扇区</li>
<li>活动分区：即计算机的启动分区，是硬盘中含有操作系统的分区</li>
<li>PBR
<ul>
<li>含义：全称是分区引导记录，是活动分区第一个扇区</li>
<li>功能：寻找并激活启动管理器（活动分区中负责引导操作系统的程序）</li>
</ul></li>
<li>启动管理器：引导操作系统的程序</li>
</ul></li>
<li>关键步骤
<ul>
<li>开机激活CPU来读取BOOT</li>
<li>BOOT把指令寄存器设置为BIOS的第一条指令</li>
<li>BIOS进行硬件自检，检查计算机硬件是否正常</li>
<li>BIOS加载MBR入内存
<ul>
<li>根据硬盘启动顺序Boot Sequnece把第一个硬盘的第一个扇区加载入内存</li>
<li>根据特定标识判断，若这是非引导硬盘，则继续把下一个硬盘的第一个扇区加载入内存</li>
<li>循环上一步直至发现引导硬盘，如果找不到则会死机</li>
</ul></li>
<li>MBR的引导程序根据MBR的硬盘分区表的特定标识找到活动分区</li>
<li>MBR的引导程序把活动分区的PBR读入内存</li>
<li>PBR把启动管理器加载入内存</li>
<li>启动管理器把操作系统加载入内存，然后操作系统进行初始化</li>
</ul></li>
</ul>
<h2 id="虚拟机">虚拟机</h2>
<ul>
<li>虚拟机通过虚拟机管理程序，为高层提供<strong>多台</strong>可以运行各自操作系统的虚拟机</li>
<li>第一类虚拟机
<ul>
<li>虚拟机管理程序建立在裸机上一层，运行在内核态</li>
<li>虚拟机管理程序的上一层是有各自操作系统的各个虚拟机</li>
<li>这些操作系统运行在虚拟内核态（工作在用户态但自认为工作在内核态）</li>
</ul></li>
<li>第二类虚拟机
<ul>
<li>虚拟机管理程序建立在<strong>宿主操作系统</strong>上，运行在用户态</li>
<li>虚拟机管理程序的上一层是有各自<strong>客户操作系统</strong>的各个虚拟机</li>
<li>客户操作系统安装在虚拟磁盘，对应宿主操作系统的一个文件</li>
<li>常见的第二类虚拟机管理程序有VMware Workstation</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第三章-存储管理</title>
    <url>/2021/11/13/operatingSystem3/</url>
    <content><![CDATA[<h2 id="内存管理基础">内存管理基础</h2>
<h3 id="内存管理基本概念">内存管理基本概念</h3>
<p>内存管理的功能</p>
<ul>
<li>地址转换：内存管理提供从逻辑地址到物理地址的变换机制
<ul>
<li>逻辑地址空间
<ul>
<li>编译后的目标模块从0单元开始编址</li>
<li>各个模块按顺序链接后构成统一的从0单元开始的逻辑地址空间</li>
<li>用户可见</li>
</ul></li>
<li>物理地址空间
<ul>
<li>主存中实际的物理地址</li>
<li>可执行代码装入内存时，要进行地址重定位，即把逻辑地址转换为物理地址</li>
</ul></li>
</ul></li>
<li>内存共享：允许多个进程访问内存同一个部分，比如同一个数据块</li>
<li>内存保护
<ul>
<li>含义：内存分配前，保护操作系统不受用户影响、保护用户之间不相互影响</li>
<li>方法有两种
<ul>
<li>在CPU中设置用户作业上下限寄存器，存放用户作业在主存中的上限、下限地址</li>
<li>把逻辑地址和界地址寄存器（限长寄存器）比较，判断是否越界；不越界的情况，把逻辑地址和重定位寄存器（基址寄存器）相加，得到物理地址</li>
</ul></li>
</ul></li>
<li>内存分配和回收
<ul>
<li>由操作系统管理主存空间的分配和回收，程序员不需要考虑</li>
</ul></li>
<li>内存扩充：利用外存扩充内存的容量，有两种方法
<ul>
<li>覆盖
<ul>
<li>思想：把用户空间分成固定区、覆盖区，活跃内容放固定区，其他即将访问的内容放覆盖区，其他暂时不用的内容放外存（需要时从外存替换入覆盖区）</li>
<li>特点：内存容量可以小于单进程总信息量；内存容量需要大于单进程任何运行时刻需要的信息量；主要应用于单进程；属于被淘汰的历史技术</li>
</ul></li>
<li>交换
<ul>
<li>思想：把等待态的进程换出到外存，把调度使用CPU的进程换入到内存（进程中级调度就是交换技术）</li>
<li>特点：交换时间希望短于进程执行时间；适合多进程或多作业情况；目前主流的技术</li>
</ul></li>
</ul></li>
</ul>
<h3 id="连续分配管理方式">连续分配管理方式</h3>
<ul>
<li>连续分配管理方式指在内存中为进程分配连续的空间</li>
<li>外部碎片：没有分配给进程，且无法利用的空间</li>
<li>内部碎片：分配给进程，但无法利用的空间</li>
</ul>
<h4 id="单一连续分配">单一连续分配</h4>
<ul>
<li>思想：内存直接分为系统区、用户区。无内存保护，因为内存中只有一道程序，空间不足采用覆盖技术，提高作业数采用交换技术</li>
<li>内存保护：界地址寄存器检查越界即可</li>
<li>优点：实现简单、无外部碎片</li>
<li>缺点：要求单用户任务、有内部碎片</li>
</ul>
<h4 id="固定分区分配">固定分区分配</h4>
<ul>
<li>思想：把内存分为固定大小的多个分区，分区可以大小相等，也可以大小不等（多个小分区，少量大分区）</li>
<li>需要分区表，表项包括：分区号、起址、大小、分配状态</li>
<li>内存保护（两个方法）
<ul>
<li>上下界寄存器检查越界</li>
<li>基地址寄存器和界地址寄存器进行地址转换</li>
</ul></li>
<li>优点：实现简单、无外部碎片；支持多道程序设计，但数量受限于分区个数</li>
<li>缺点：程序大于最大分区时需要使用覆盖技术；有内部碎片；无法内存共享</li>
</ul>
<h4 id="动态分区分配">动态分区分配</h4>
<ul>
<li>思想：进程装入内存时动态建立分区，又叫可变分区分配</li>
<li>内存保护（两个方法）
<ul>
<li>上下界寄存器检查越界</li>
<li>基地址寄存器和界地址寄存器进行地址转换</li>
</ul></li>
<li>优点：按需分配，因此无内部碎片；内存共享；程序数无限制</li>
<li>缺点：有外部碎片，但可以通过<strong>紧凑技术</strong>解决</li>
<li>常见的动态分区分配算法
<ul>
<li>首次适应算法First
Fit：从地址递增顺序查找第一个大小满足要求的空闲分区</li>
<li>最佳适应算法Best
Fit：按容量递增顺序查找查找第一个大小满足要求的空闲分区</li>
<li>最坏适应算法Worst Fit（最大适应算法Largest
Fit）：按容量递减顺序查找查找第一个大小满足要求的空闲分区</li>
<li>邻近适应算法Next
Fit（循环首次适应算法）：从上次查找结束的位置开始（按地址递增顺序）查找第一个大小满足要求的空闲分区</li>
</ul></li>
</ul>
<h3 id="非连续分配管理方式">非连续分配管理方式</h3>
<ul>
<li>本节主要从逻辑地址结构（维度）、表项结构、寻址过程三个方面思考</li>
<li>非连续和连续分配管理方式都是传统存储管理方式，目标是建立多个进程在内存中的位置映射，而并不引入虚拟存储管理，这种传统的存储管理的特点是
<ul>
<li>一次性：作业一次性全部装入内存才开始运行
<ul>
<li>作业过大则无法运行</li>
<li>不能支持很多作业同时运行</li>
</ul></li>
<li>驻留性：作业结束前不考虑替换出分配给作业的内存
<ul>
<li>因为IO等待的进程占用了内存空间</li>
</ul></li>
</ul></li>
</ul>
<h4 id="基本页式管理">基本页式管理</h4>
<ul>
<li>主要内容详见计算机组成原理第三章的页式虚拟存储器</li>
<li>补充内容1：页式管理的碎片情况
<ul>
<li>页式管理按相等大小给存储划分，无外部碎片</li>
<li>页比连续分配方式的分区小得多，因此进程只有最后一个不完整的页申请内存才会有页内碎片（平均情况即半个页大小的内部碎片）</li>
</ul></li>
<li>补充内容2：页表项的大小
<ul>
<li>以32位系统为例，页大小4KB，12位</li>
<li>因此页数量有20位，即页表项至少需要3个字节</li>
<li>linux中设置页表项4B，每一页可以装1K个页表项</li>
</ul></li>
</ul>
<h4 id="基本段式管理">基本段式管理</h4>
<ul>
<li>主要内容详见计算机组成原理第三章的段式虚拟存储器</li>
<li>补充内容1：段式管理碎片情况：有外部碎片，无内部碎片</li>
<li>补充内容2：段式管理的共享和保护
<ul>
<li>共享
<ul>
<li>两个作业的段表的表项指向同一个共享段</li>
<li>只有不能修改的代码（即纯代码、可重入代码）和不能修改的数据才可以共享</li>
</ul></li>
<li>保护
<ul>
<li>段表寄存器的段表长用于越界保护（这种保护方式页式管理也有）</li>
<li>段表项的段长用于越界保护（这种保护方式页式管理不需要，因为页内大小固定，即页长固定）</li>
</ul></li>
</ul></li>
</ul>
<h4 id="基本段页式管理">基本段页式管理</h4>
<ul>
<li>页式满足系统需要，段式满足用户需要（逻辑清晰、容易实现共享和动态链接），因此可以结合两者</li>
<li>需要三次访存，可以引入快表作为页表的Cache</li>
<li>主要内容详见计算机组成原理第三章的段页式虚拟存储器</li>
</ul>
<h2 id="虚拟内存管理">虚拟内存管理</h2>
<h3 id="虚拟内存基本概念">虚拟内存基本概念</h3>
<h4 id="局部性原理">局部性原理</h4>
<p>详见计算机组成原理第三章高速缓存Cache部分的程序访问局部性原理</p>
<h4 id="虚拟存储器">虚拟存储器</h4>
<ul>
<li>定义：由操作系统提供给用户的比实际内存大得多的存储器，大小不大于
<ul>
<li>计算机地址位数对应的容量</li>
<li>内存和外存的容量和</li>
</ul></li>
<li>特征
<ul>
<li>多次性：允许作业分多次调入内存</li>
<li>对换性：允许作业运行结束前替换出内存</li>
<li>虚拟性：内存容量逻辑上得到扩充</li>
</ul></li>
<li>实现方式
<ul>
<li>请求页式存储管理</li>
<li>请求段式存储管理</li>
<li>请求段页式存储管理</li>
</ul></li>
<li>所需的硬件支持
<ul>
<li>一定容量的外存：用于内存的扩充</li>
<li>页表或段表：主要的数据结构</li>
<li>中断机构：缺页缺段时产生中断</li>
<li>地址变换机构：把逻辑地址变成物理地址</li>
</ul></li>
</ul>
<h3 id="请求页管理">请求页管理</h3>
<h4 id="页表项">页表项</h4>
<ul>
<li>基本页式管理的页表项包括：页号、物理页号</li>
<li>请求页管理的页表项额外增加了：状态位、访问字段、修改位、外存地址（可参考计算机组成原理第三章的页式虚拟存储器）</li>
</ul>
<h4 id="缺页中断机构">缺页中断机构</h4>
<ul>
<li>内部中断，在一条指令执行期间可能多次发生</li>
<li>过程：保护CPU环境、分析中断原因、转入缺页中断处理程序、恢复CPU环境</li>
<li>处理过程
<ul>
<li>保存CPU现场</li>
<li>在外存中找到缺页</li>
<li>内存如果有空闲块，则分配，把调入页装入此块，修改相应页表项</li>
<li>内存如果没有空闲块，则替换某页，被淘汰的页如果修改位为1则结合回写策略写回外存</li>
<li>缺页进程唤醒、就绪</li>
</ul></li>
</ul>
<h4 id="地址变换机构">地址变换机构</h4>
<ul>
<li>通常引入快表（Cache一般用相联存储器实现，按内容寻址）
<ul>
<li>快表命中判定：要求标记位匹配且对应的页表项有效位为1，因此快表命中不用考虑缺页</li>
<li>在缺页处理完成时，不做说明，则认为快表项也得到更新</li>
</ul></li>
<li>详见计组第三章笔记</li>
</ul>
<h3 id="页框分配">页框分配</h3>
<h4 id="驻留集">驻留集</h4>
<ul>
<li>驻留集定义：给进程分配的物理块的集合</li>
<li>页面分配和置换策略
<ul>
<li>固定分配、局部置换
<ul>
<li>分配给进程的物理块固定不变</li>
<li>进程缺页时，对该进程的驻留集调用页置换算法</li>
</ul></li>
<li>可变分配、全局置换
<ul>
<li>分配给进程的物理块可变</li>
<li>操作系统维护一个全局的空闲物理块队列，进程缺页时，则从队列中取空闲物理块分配给进程</li>
<li>进程缺页且无空闲物理块时，对整个内存的所有物理块调用页置换算法</li>
</ul></li>
<li>可变分配、局部置换
<ul>
<li>进程缺页时，对该进程的驻留集调用页置换算法</li>
<li>如果频繁缺页，则增加物理块分配；如果缺页率低，则减少物理块分配</li>
</ul></li>
</ul></li>
</ul>
<h4 id="页面调入时机">页面调入时机</h4>
<ul>
<li>预调页策略：根据局部性原理，预测之后访问的页，在进程首次调入时，由系统程序员指定一次调入多个页（运行前调入）</li>
<li>请求调页策略：在运行时缺页则调入对应的一个页（运行时调入）</li>
</ul>
<h4 id="从何处调入页面">从何处调入页面</h4>
<ul>
<li>外存文件区：存放文件，离散分配，IO速度相对慢</li>
<li>外存对换区：存放对换页面，连续分配，IO速度相对快</li>
<li>三种情况
<ul>
<li>对换区充足
<ul>
<li>进程运行前把相关文件从文件区复制到对换区</li>
<li>之后全部从对换区调页（调入和换出）</li>
</ul></li>
<li>对换区紧缺
<ul>
<li>不会被修改的文件从文件区调入，不需要换出</li>
<li>会被修改的文件从对换区调页（换出和调入）</li>
</ul></li>
<li>UNIX方式
<ul>
<li>未运行的页面从文件区调入</li>
<li>运行过的页面从对换区调页（换出和调入）</li>
<li>共享文件若已在内存，无需重复调入</li>
</ul></li>
</ul></li>
</ul>
<h3 id="页置换算法">页置换算法</h3>
<p>当内存无空闲空间时，页面置换算法有</p>
<ul>
<li>最佳置换算法OPT
<ul>
<li>思想：选择最长时间不被访问的页面替换</li>
<li>特点：无法准确的预测最长时间，难以实现该算法，但可以作为其他算法的评价标准</li>
</ul></li>
<li>先进先出置换算法FIFO
<ul>
<li>思想：选择最早调入的页面替换</li>
<li>特点：存在Belady异常，即增加进程分配的物理块数，缺页次数反而可能增加</li>
</ul></li>
<li>最近最久未使用置换算法LRU
<ul>
<li>思想：选择最久没有使用的页面替换，需要用到页表项的访问字段，即距离上一次访问的时间</li>
<li>特点：性能接近OPT的堆栈类算法（OPT是向未来看，LRU是向过去看），但需要寄存器和栈的硬件支持</li>
</ul></li>
<li>时钟置换算法CLOCK（最近未用算法NRU）
<ul>
<li>所有内存页面保存在环形链表中，由指针遍历</li>
<li>需要设置使用位，当页面被访问后，使用位设置为1</li>
<li>当指针指向空闲块，将其分配给进程，使用位设置为1，指针指向下一个位置</li>
<li>当指针指向非空闲块（说明无空闲的块）
<ul>
<li>转第一圈，寻找第一个使用位为0的页，遇到的使用位是1的页面将其使用位设置为0</li>
<li>如果没找到，则第二圈的第一个页使用位肯定是0，用该内存块替换（要考虑写回），使用位设置为1，指针指向下一个位置</li>
</ul></li>
</ul></li>
<li>改进的时钟置换算法
<ul>
<li>针对写回开销大的问题改进，增设一个修改位，使用位和修改位用二元组(x,y)表示</li>
<li>当指针指向非空闲块（说明无空闲的块）
<ul>
<li>转第一圈，寻找第一个(0,0)页替换</li>
<li>如果第一圈没找到，则转第二圈，寻找第一个(0,1)的页替换，遇到的(1,x)设置为(0,x)</li>
<li>如果第二圈没找到，此时只有(0,x)，返回上面两步，一定能找到页面替换</li>
</ul></li>
</ul></li>
</ul>
<h3 id="内存映射文件">内存映射文件</h3>
<ul>
<li>含义：把<strong>磁盘文件</strong>映射到虚拟地址空间中的<strong>内存映射文件</strong>（实际上虚拟存储器可以继续将其映射到内存的某位置）</li>
<li>原理
<ul>
<li>磁盘文件最初访问按缺页处理调入内存</li>
<li>此后访问磁盘文件不需要读写磁盘，只需要访问内存中的内存映射文件即可</li>
<li>当进程退出或解除文件映射时，所有改动需要写回磁盘</li>
</ul></li>
<li>共享内存实现方式：如果多个进程映射了同一个文件，内存映射文件就是共享内存</li>
</ul>
<h3 id="工作集">工作集</h3>
<ul>
<li>工作集定义
<ul>
<li>进程一段时间内访问的页面集合</li>
</ul></li>
<li>工作集确定
<ul>
<li>由<strong>时刻</strong>和<strong>工作窗口</strong>确定</li>
<li>定义中的<strong>一段时间</strong>指，从<strong>给定时刻</strong>到过去的一段时间间隔（间隔大小由<strong>工作窗口</strong>确定）</li>
</ul></li>
<li>工作集原理
<ul>
<li>工作集可以理解是最近频繁使用的页面的集合</li>
<li>局部性越好的程序，工作集大小越小于工作窗口大小</li>
<li>驻留集大小要大于工作集，否则容易抖动（见后面一节）</li>
</ul></li>
</ul>
<h3 id="抖动">抖动</h3>
<ul>
<li>又叫颠簸，指的是进程换页的时间多于执行的时间，是频繁的换页行为</li>
<li>原因：进程频繁访问的页面数目高于分配给进程的物理页框数</li>
<li>解决方法
<ul>
<li>驻留集应大于工作集
<ul>
<li>工作集的页面需要调入驻留集</li>
<li>工作集外的页面可以调出驻留集</li>
</ul></li>
<li>进程的调入调出
<ul>
<li>若内存还有空闲，则可以再调一个进程进内存</li>
<li>若内存小于进程工作集之和，则需要调出一个进程出内存</li>
</ul></li>
</ul></li>
</ul>
<h3 id="虚拟存储器的性能影响因素和改进方式">虚拟存储器的性能影响因素和改进方式</h3>
<p>虚拟存储器的性能影响因素主要是缺页率，缺页率的影响因素如下</p>
<ul>
<li>页面大小：越大缺页率低，但页表短、页内碎片大</li>
<li>驻留集大小：越大缺页率越低，但分配的内存块过多会浪费空间，缺页率降低不明显</li>
<li>页面置换算法：LRU、CLOCK算法缺页率低，这些把未来可能访问的页面尽量保留在内存</li>
<li>程序编址方法：局部化程度越高，缺页率越低（比如按行存储时应按行访问）</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第四章-文件管理</title>
    <url>/2021/11/16/operatingSystem4/</url>
    <content><![CDATA[<h2 id="文件">文件</h2>
<h3 id="基本概念">基本概念</h3>
<ul>
<li>文件：以硬盘为载体存储在计算机中的信息集合，是用户输入输出的基本单位</li>
<li>文件系统：维护和管理文件，并向用户提供系统调用，如建立、打开、关闭、撤销、读写等</li>
<li>基本数据项：最小逻辑数据单元、原子数据，比如一个对象某个属性的一个值</li>
<li>组合数据项：多个基本数据项组成</li>
<li>记录：数据项的集合，描述一个对象的某个属性</li>
<li>文件的划分
<ul>
<li>记录式：由相似的记录组成</li>
<li>流式：看作是字符流</li>
</ul></li>
<li>文件的属性</li>
</ul>
<h3 id="文件元数据">文件元数据</h3>
<p>即文件的属性，包括</p>
<ul>
<li>名称</li>
<li>标识符：一般是数字，文件的唯一标签，用户不可见</li>
<li>类型</li>
<li>位置</li>
<li>大小：当前大小值或允许的最大值</li>
<li>保护</li>
<li>时间：创建的时间</li>
<li>日期：上次修改的日期</li>
<li>用户标识：上次访问的相关信息</li>
</ul>
<h3 id="索引节点">索引节点</h3>
<ul>
<li>文件控制块FCB：存放控制文件的有关信息（文件元数据）的数据结构，每个文件唯一对应一个FCB</li>
<li>FCB内容
<ul>
<li>基本信息：文件名、位置、逻辑结构、物理结构等</li>
<li>存取控制信息：存取权限等</li>
<li>使用信息：文件建立时间、修改日期</li>
</ul></li>
<li>文件目录：FCB的集合</li>
<li>文件目录项：即FCB</li>
<li>索引结点（inode）：因为文件检索只需要文件名，所以把FCB中的文件名信息和其他信息分开；其他信息打包成索引结点，存放在索引结点表中；文件目录项只存放文件名、索引结点编号（结点指针）</li>
<li>磁盘索引结点（磁盘inode）：包括标识符、类型、存取权限、地址、文件长度、链接次数、文件最近存取时间、索引结点最近修改时间</li>
<li>内存索引结点（活动inode）：在磁盘索引结点基础上，增加了
<ul>
<li>编号：标识内存索引结点</li>
<li>状态：是否上锁或修改</li>
<li>进程访问次数</li>
<li>逻辑设备号</li>
<li>链接指针：包括指向空闲链表的指针和指向散列队列的指针</li>
</ul></li>
</ul>
<h3 id="文件的操作">文件的操作</h3>
<ul>
<li>创建（create系统调用）
<ul>
<li>输入文件名、文件路径、大小空间</li>
<li>在外存中找到存储空间</li>
<li>根据文件路径找到目录表，在目录表中创建目录项</li>
</ul></li>
<li>删除（delete系统调用）
<ul>
<li>输入文件名、文件路径</li>
<li>根据文件路径找到目录表</li>
<li>根据文件名在目录表中找到目录项并删除</li>
<li>回收磁盘存储空间</li>
</ul></li>
<li>打开（open系统调用）
<ul>
<li>输入文件名、文件路径、打开后的操作（读或写等模式）</li>
<li>根据文件路径找到目录表</li>
<li>根据文件名在目录表中找到目录项</li>
<li>根据目录项检查打开权限</li>
<li>把文件目录项（文件属性）从外存复制到内存的<strong>打开文件表</strong>中
<ul>
<li>系统打开文件表：系统记录所有打开的文件，每一项为文件的FCB和进程数量</li>
<li>进程打开文件表：进程记录自己打开的文件，每一项为文件对应在系统打开文件表中的位置指针</li>
</ul></li>
<li>把系统打开文件表对应表项的索引指针（unix叫文件描述符，windows叫文件句柄）返回给用户</li>
</ul></li>
<li>关闭（close系统调用）
<ul>
<li>输入文件名、文件路径</li>
<li>文件打开计数器（记录多少个进程打开此文件）减1，减到0说明此文件需要关闭</li>
<li>文件修改的部分写回外存</li>
<li>将打开文件表相应表项删除</li>
<li>回收分配给该文件的内存空间</li>
</ul></li>
<li>读（read系统调用）
<ul>
<li>输入文件名（一般是打开文件表的索引）、读出数据大小、读出数据的位置</li>
<li>把文件中对应大小的数据读出到相应位置</li>
</ul></li>
<li>写（write系统调用）
<ul>
<li>输入文件名（一般是打开文件表的索引）、写入数据大小、写入数据的位置</li>
<li>把相应位置对应大小的数据写入到文件中</li>
</ul></li>
<li>重定位：文件位置设为指定值</li>
<li>截断：文件长度设为0并释放文件存储空间，其他文件属性不变</li>
</ul>
<h3 id="文件的保护">文件的保护</h3>
<h4 id="访问类型">访问类型</h4>
<ul>
<li>读</li>
<li>写</li>
<li>执行</li>
<li>添加</li>
<li>删除</li>
<li>列表清单</li>
</ul>
<h4 id="访问控制">访问控制</h4>
<ul>
<li>访问控制表法
<ul>
<li>每个文件设置一个访问控制列表ACL，规定每个用户名的允许访问类型</li>
<li>考虑表长无法预计，可以精简访问列表，文件创建时FCB中只记录文件主（文件的创建者）名、文件主所在组名（组用户和文件主权限相同）
<ul>
<li>用户类型：文件创建者、组用户、其他用户</li>
<li>访问文件的用户类型：根据访问者是否在组中，确定访问权限为组用户或其他用户</li>
</ul></li>
</ul></li>
<li>口令法
<ul>
<li>文件创建时在FCB中存入口令</li>
<li>访问文件需要提供口令</li>
<li>开销小，但口令直接保存在系统内（没有任何加密解密的过程），不够安全</li>
</ul></li>
<li>密码法
<ul>
<li>文件创建时进行加密</li>
<li>访问文件需要使用密钥</li>
<li>安全，但加密解密需要一定开销</li>
</ul></li>
</ul>
<h3 id="文件的逻辑结构">文件的逻辑结构</h3>
<ul>
<li>流式文件（无结构文件）
<ul>
<li>以字节为单位，可以看成字符流</li>
<li>比如源文件、目标代码文件</li>
</ul></li>
<li>记录式文件（有结构文件）
<ul>
<li>顺序文件
<ul>
<li>文件记录定长，按顺序排列。</li>
<li>按时间顺序叫做串结构；按关键字顺序叫顺序结构</li>
<li>批量记录修改效率高；单个记录修改效率低</li>
</ul></li>
<li>索引文件
<ul>
<li>每个文件需要一个索引表，该表本身为顺序文件</li>
<li>索引表的表项包括：索引号、长度、指针（指向逻辑文件索引号对应位置）</li>
</ul></li>
<li>索引顺序文件
<ul>
<li>把文件所有记录分组，每组的第一个记录作为索引项建立索引表</li>
<li>索引表的表项为每组第一个记录的关键字和逻辑位置</li>
<li>查找时先查索引表确定组起始位置，组内顺序查找</li>
</ul></li>
<li>直接文件（散列文件）
<ul>
<li>给定记录关键字直接确定其物理地址</li>
<li>注：这种也可以认为是物理结构，不同教材并不一致</li>
</ul></li>
</ul></li>
</ul>
<h3 id="文件的物理结构">文件的物理结构</h3>
<ul>
<li>连续结构（顺序结构）
<ul>
<li>连续分配方式，逻辑上连续的信息在物理上也连续</li>
<li>FCB中保存起始物理地址、物理块数</li>
<li>优点是可随机访问，只需要访问磁盘一次；缺点是文件连续存储，不容易动态扩充，有外部碎片</li>
</ul></li>
<li>链接结构（串联结构、连接结构）
<ul>
<li>链接分配方式（属于离散分配方式），逻辑上连续的信息在物理上离散</li>
<li>隐式链接
<ul>
<li>FCB保存文件首尾盘块的物理地址</li>
<li>文件中间盘块的后继地址用户不可见，用户只能顺序访问，需要多次访问磁盘</li>
<li>无外部碎片</li>
</ul></li>
<li>显式链接
<ul>
<li>FCB保存文件首盘块的物理地址</li>
<li>整个磁盘只设置一张文件分配表FAT（操作系统可见），表项包括盘块号和后继地址</li>
<li>FAT表项的后继地址有额外的功能，比如为-1表示无后继处于文件尾；为-2说明磁盘块空闲</li>
<li>FAT在系统启动后读入内存，顺着链查找时不用访问磁盘，可以理解为支持随机访问，检索速度快</li>
<li>无外部碎片</li>
</ul></li>
</ul></li>
<li>索引结构
<ul>
<li>索引分配方式（属于离散分配方式），逻辑上连续的信息在物理上离散</li>
<li>FCB保存文件的索引块的磁盘物理块号（块的第i行指向文件的第i个物理块的磁盘地址）</li>
<li>创建文件时，索引块指针全空；写入文件第i个块要修改文件的索引块的第i行地址</li>
<li>支持直接访问，但是需要先访问磁盘查索引块
<ul>
<li>可以将索引块读入内存缓冲区，加快后续访问</li>
</ul></li>
<li>无外部碎片</li>
<li>索引块大小通常为一个磁盘块。因为其额外占了磁盘的连续存储空间，不能太大；为了支持大文件也不能太小。解决方法有
<ul>
<li>链接索引：多个索引块链接成不连续的大索引表</li>
<li>多级索引：比如二级索引指，索引块指向二级索引块，二级索引块指向文件块</li>
<li>混合索引：以unix为例，在FCB（inode）中，保存了10个直接地址（文件物理块号）、1个一级间址（一级索引）、1个二级间址（二级索引）等，可以满足不同大小文件的需求</li>
</ul></li>
</ul></li>
<li>直接结构（散列结构）
<ul>
<li>给定记录关键字直接确定其物理地址</li>
<li>注：这种也可以认为是逻辑结构，不同教材并不一致</li>
</ul></li>
</ul>
<h2 id="目录">目录</h2>
<h3 id="基本概念-1">基本概念</h3>
<ul>
<li>文件：包括FCB和文件体</li>
<li>目录：FCB组成的集合，至少包含两个目录项，即当前目录项"."和父目录项".."</li>
<li>目录项：每个目录项都是FCB，用来描述文件或子目录</li>
</ul>
<h3 id="树形目录">树形目录</h3>
<p>又叫多级目录结构</p>
<ul>
<li>文件路径：把从根目录到目标文件的通路上所有目录名和文件名用"/"链接成字符串</li>
<li>绝对路径：从根目录出发的路径，例如"/bin/ls"</li>
<li>相对路径：从当前目录（工作目录）出发的路径，例如"./ls"</li>
</ul>
<h3 id="目录的操作">目录的操作</h3>
<ul>
<li>搜索：在目录中找到对应目录项</li>
<li>创建文件：创建后在目录中增加一个目录项</li>
<li>删除文件：删除后在目录中删除一个目录项</li>
<li>显示目录：显示目录的内容（所有文件及属性），比如linux的"ls"</li>
<li>修改目录：修改目录项（FCB）的属性</li>
</ul>
<h3 id="文件共享">文件共享</h3>
<h4 id="硬链接">硬链接</h4>
<ul>
<li>目录实现方式：
<ul>
<li>unix方式</li>
<li>即目录项包括文件名、索引结点的指针</li>
<li>索引结点包含FCB除了文件名外的其他文件属性，如文件物理地址</li>
</ul></li>
<li>文件共享
<ul>
<li>基于索引结点</li>
<li>不同用户目录的目录项的索引结点指针指向同一个文件的索引结点</li>
</ul></li>
<li>索引结点中还需要包含链接计数器count，记录被多少个索引结点指针指向
<ul>
<li>文件创建时，count=1</li>
<li>用户删除文件时，count减1，减到0才真正删除文件</li>
</ul></li>
</ul>
<h4 id="软链接">软链接</h4>
<ul>
<li>文件共享
<ul>
<li>基于符号链接</li>
<li>创建LINK类型的文件（快捷方式文件），和希望共享的目标文件同名，文件内容是目标文件的路径（即符号链）</li>
<li>其他用户先通过目标文件路径，找到对应目录项的索引结点指针，再访问目标共享文件</li>
</ul></li>
<li>目标文件的拥有者删除目标文件，其他用户无法用软链接访问</li>
<li>缺点
<ul>
<li>删除共享文件并重建一个同名同路径的文件，其他共享用户依然可以访问这个文件</li>
<li>需要根据路径多次查目录访问磁盘，速度比硬链接慢</li>
<li>LINK的索引结点要占一定磁盘空间</li>
</ul></li>
<li>优点：应用于网络共享，提供网络地址和文件路径即可</li>
</ul>
<h4 id="软硬链接共同点">软硬链接共同点</h4>
<ul>
<li>共同的缺点：每个共享文件都有自己的文件名，遍历文件系统会多次访问共享文件</li>
<li>都是静态共享方法（动态共享指的是多个进程对同一个文件的共享）</li>
</ul>
<h3 id="目录查询">目录查询</h3>
<p><em>不同于目录结构，本节关注的是，在当前路径下的目录中，查找目录项的方式</em></p>
<ul>
<li>线性表方式（线性查找）
<ul>
<li>创建新文件先检查同名，然后表尾加入目录项</li>
<li>删除文件则按名搜索，释放空间</li>
<li>具体的存储结构可以是顺序结构或链式结构</li>
</ul></li>
<li>哈希表方式（哈希查找）
<ul>
<li>优点是查找迅速，插入删除简单</li>
<li>缺点是哈希表长固定，哈希函数对表长的依赖性</li>
</ul></li>
</ul>
<p>注：目录查找时为了减少磁盘访问，可以先把当前目录复制到内存。</p>
<h2 id="文件系统">文件系统</h2>
<h3 id="文件系统的全局结构">文件系统的全局结构</h3>
<h4 id="外存中的结构">外存中的结构</h4>
<ul>
<li>磁盘整体结构
<ul>
<li>第一个扇区为MBR，其余为若干磁盘分区</li>
<li>MBR尾部是分区表，给出磁盘各个分区首尾地址</li>
</ul></li>
<li>磁盘各分区内结构
<ul>
<li>引导块PBR：第一个扇区</li>
<li>超级块：存放文件系统关键参数</li>
<li>空闲空间管理块</li>
<li>索引节点表（inode表）</li>
<li>根目录</li>
<li>文件和目录</li>
</ul></li>
</ul>
<h4 id="内存中结构">内存中结构</h4>
<ul>
<li>各资料中都未找到对应内容，<strong>待补充</strong></li>
<li>可能包括文件分配表、文件打开表等相关概念</li>
</ul>
<h3 id="文件系统层次结构">文件系统层次结构</h3>
<ul>
<li>第0级：用户调用接口
<ul>
<li>文件系统向用户提供和文件及目录有关的调用</li>
</ul></li>
<li>第1级：文件目录系统
<ul>
<li>管理文件目录</li>
</ul></li>
<li>第2级：存取控制验证模块
<ul>
<li>文件保护，验证访问控制权限</li>
</ul></li>
<li>第3级：逻辑文件系统和文件信息缓冲区
<ul>
<li>获得文件逻辑地址（逻辑块号）</li>
</ul></li>
<li>第4级：物理文件系统
<ul>
<li>获得文件物理地址</li>
</ul></li>
<li>辅助分配模块
<ul>
<li>分配和回收外存空间</li>
</ul></li>
<li>设备管理程序模块
<ul>
<li>进行设备管理，比如分配设备读写缓冲区、磁盘调度、启动设备、释放设备等</li>
</ul></li>
</ul>
<h3 id="外存空闲空间管理办法">外存空闲空间管理办法</h3>
<ul>
<li>空闲表法
<ul>
<li>操作系统把空闲盘区（即连续的空闲块）记录到空闲表中，表项为序号、空闲盘的第一个块号、空闲盘块数</li>
<li>类似于内存动态分配，可以采取首次适应策略、循环首次适应策略等</li>
<li>内存回收时考虑邻接区的合并</li>
</ul></li>
<li>空闲链表法
<ul>
<li>空闲盘块链
<ul>
<li>基本单位为一个磁盘块，盘块内尾部保存后继指针，串成链</li>
<li>操作系统保存链头指针、链尾指针</li>
<li>一个盘块的分配回收简单，分配从链头拿，回收放入链尾</li>
<li>一个文件分配空间需要多次操作</li>
</ul></li>
<li>空闲盘区链
<ul>
<li>基本单位为一个盘区，盘区内尾部保存后继指针，串成链，盘区内还保存本区的盘块数</li>
<li>操作系统保存链头指针、链尾指针</li>
<li>分配时采用首次适应，没有足够大的盘块就分配若干小盘区</li>
<li>回收时放入链尾，需要考虑合并问题</li>
</ul></li>
</ul></li>
<li>位示图法
<ul>
<li>比特位排成二维矩阵，每个比特对应一个磁盘块是否空闲</li>
<li>分配时按顺序在位示图中找0比特空闲块，根据位置确定磁盘块号，把比特位设置为1</li>
<li>回收时，根据磁盘号算出位示图的行列位置，比特位设置为0</li>
<li>注意矩阵的行列号与磁盘块号默认从1开始，也可能题目明确指出从0开始</li>
</ul></li>
<li>成组链接法
<ul>
<li>操作系统将空闲盘块（可以不相邻）分组。</li>
<li>每组第一个盘块是一张索引栈，索引下一组的所有空闲块，且保存下一组的空闲块数</li>
<li>第一组只有一个盘块（索引栈），称为超级块，在文件操作前一般先读入主存</li>
<li>分配时
<ul>
<li>如果超级块索引的第二组中，有至少2个空闲块，则按出栈顺序取1个空闲块</li>
<li>如果超级块索引的第二组中，只有一个索引栈空闲块，则把该块复制入超级块，并把该块分配出去，组数减1</li>
</ul></li>
<li>回收时
<ul>
<li>如果超级块索引的第二组的空闲块数未达到超级块的最大容量，则回收块以入栈顺序由超级块索引，放入第二组</li>
<li>如果超级块索引的第二组的空闲块数达到了超级块的最大容量，则超级块复制入回收块，并把超级块索引向该回收块，此时第二组只包含一个空闲索引块（内容是原超级块），组数加1</li>
</ul></li>
<li>该方法解决了空闲表和空闲链表过长的问题，可以结合下图理解
<img src="/2021/11/16/operatingSystem4/group.png" class title="this is group"></li>
</ul></li>
</ul>
<h3 id="虚拟文件系统">虚拟文件系统</h3>
<ul>
<li>虚拟文件系统（VFS）是用户进程和底层各文件系统（如网络文件系统、日志文件系统）之间的抽象层</li>
<li>VFS的作用是适配底层各文件系统，隐藏下层实现细节，为上层服务提供接口</li>
<li>VFS只存在于内存，在系统启动时建立，在系统关闭时消亡，是内核的软件层</li>
<li>下面是VFS的示意图 <img src="/2021/11/16/operatingSystem4/VFS.png" class title="this is VFS"></li>
</ul>
<h3 id="文件系统挂载">文件系统挂载</h3>
<ul>
<li>文件系统挂载：把新的文件系统关联到当前根文件系统</li>
<li>mount（挂载命令）：在指定目录（挂载点）附加文件系统</li>
<li>挂载点
<ul>
<li>是挂载文件系统的访问入口，必须已经存在</li>
<li>一般是不被进程使用的目录</li>
<li>挂载后的目录的原有文件临时隐藏</li>
</ul></li>
<li>unmount（卸载命令）：把文件系统和当前根文件系统移除关联</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【工作日志】 2021年2月</title>
    <url>/2021/02/13/worklog-2021-2/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误，请重试" data-whm="密码验证错误，请再试一试">
  <script id="hbeData" type="hbeData" data-hmacdigest="898fe6ba8ff26f743a394c08dff2ad075b0e27edcba8adcdbe3438a44b211dae">ad43cd26d5b7026203cb76ab857976b3fae4deb41e0851382517be9714c0e85281a42a274ec64c4cc38b248380dda8539c06d3336768f30899c83624044ccf9684499cd58829388e2408621dc6540770fc25b2efc207e6d1a0658d675cff6ccb83e40d7f7adc1514728c9b0ecd9c5a561ac8fb3cee0432291506671907fdb9d875743e2d91b0f3301045ed61d6caa3c5ddda5b89d252b7bea136ca52cd0c5af0f5d0a282ba3ab9047ad13c9d396a4d8c0034b1f092b59f48a3f33601e1fba865a469d8666596d1f54c87c33f64cdedc92e7a63ee879b29c861d2ae5543adab87ed7177aae70a0ab41808062ea6aa082928e5cc1af20583fc82a4d75626308b823e517973d890e6b13c3e0f486bfc037bbe9577e37290b681c8095e7dede5601ab9de23a96c0fdab4208b8ce617ecdd6843e79c715596e8dd2b96df408f19ad8b36b94744d11544fbd51d90df63bbd7c34f73070ec20ff8da1e4e77227c59122f14c31fa449011e0b356fb5c2153b2ccd8d1c1dce1304d3e89de262534bb21a809f5654de7dff45b0d8a7357f5a86bf3f194bd2f0f254c781e4fa56d1a4b5ade92e08adcf2def4badf5e9810049487cee79338d95ead68d191d1e41eba4c5ea079d2560c4abfe3d83e7b77081fa73fb187c465ff5f2cbcb5e2f75be10a8ecc5b9240e115e49afdf9d8635ae5a65e39f65424e73b1698a014511f1a35cc377a2b28650a109efde8f6ae93c31c5ed1a43d15895bd0b281ef4d21e2be3decd86e3043f05ebb1a030552671eaeea69fdd53ac3a01a190f13f0f57eafd3ec65e1938996bcdaee6ada2e5c69d27f397930ead5a2b81814b8ea045c71bab1c7544fb63d66f98ed382511550a117e51e4e1b868145c838546d5cee840d5a7576813d82eab00ad77bf43f7604feb5bc80a266b396e93d8a9bd665f20ab177a6aad5add4f9faedd645501b0fe99c3afa71fab016bf7327a410e9b5cd6900365be2d44e1d918b204ce2c594ff7140f3f86b7d584173d54999d4bffd55a3c7ae23f60096707720f6cf9648c006d0bf69ce79ee952c903d59c06b4821de0e967d352809336267b4b69c87f9778f2c4bc63d51e13ef3ed2dff49137f506096efc4fe4f90caa89959973dfb67c1286e284de136118f74daef298d3f121b334293cecb06ba80ebf4311eb8872d6fac51ed7830bc72b56e16c1cd50aed27e493089a794b1879dfe4d67eedabc78145a9c6c3bee9a168bd2e3b42f94a8fb8bf20c832e3b879bd434fb2072883722e564ab5fe4b5a8d9ad02bed54541d7230da7e596664b76c9c123922a453f4ae3dbb0b80a4a5027f8ee622b1f1442696490b761f37113502566d9d5ca8cc241f27c212410a6ec70418b7b294d570c5261c7fd47d31528b0348f6b2e99a87c88956dd9b021becfe3823ebc76cf86709a03da247c74555d9f9c61369bba75ebad373854ccda05cd48075a63405684f7d6f3036aa3669cbca03847b63c516ffb7d0c1903e4d0ec57cbd68242b16f6cdb9110061fe1872545c1b7537d40b7e7aecae377d715f11a59e76a62a84399fa951852b30f92d60cb7edad9c1f2242809ebb2a575ad464b56e2203baff0c0ad82bf7a2693a7f1ea7268300978eadf0e156cf5b11502afada46bbf9c9c8fc087f7e494c2a0ff0ac1fe2d5749bf53296f51d37bbc00eccd321a9e0f3e8de8078028fc7f37ddc2a8c4160dc9190b4b3a950b646fc6b9b0fd5a463dfd8596995539ff22ad091beccf3d072932f441482b724d37f4201481e7b16a9f43447d754ee7a77969a5442d8162ee0207f2adcab6914c03282fd3f669a249b758edbdf92c41f6e8ba9a85bcc55d1c142d44965c6e2fd4695b3f905a2eaae11d0f78fbfafcedd4c5fc2b27fdd1bebdea8690c4569ce92102f9fdfdf4fa2283b0ba30c7b98444208dcb003625f3ab50e2b7db1c90fd030ad04ed4b8d00bd9a28c8da8bb2ba2197b24b55b5965965073397170d8cc75362d8eb9b8dd4cb203141a9d3ae766e02792be555ee8cda4a7ff55a963deb2045a5de240ab429b1327d6286ecb4470caeb157a0c73650422af40fe7cb4da169951d4e6d5e8708d11a6cd9bde84620d3dfac478c5d174ffb5853e5cc52c0ab418fd55a5e74fd330ebd135b208584c42e5b2d550671b4b092a50b831bb9e7c3b508c9ad4232421ed6fd1bb4f766366899f99bf5c6885350733e99a0a5c7e210db35fee6c2c987a49f095490828667111c0575b21be6a85feb2f399e6a6b0e897e474bbb278618b8980319d50fde1e5460e95004cf3fb458ba4ad2c07beaf10e0e33879e5c47fea33691816f58f887cf92c2c4265b6defa24fbd58db6cfef6032185a7f9f444d3c55edbf7799c8d4808ac2e647850d181458bc18cc2fe6285cd3d2bd40cfa89b1e11547f620f2e32c6497ee440c223d160429c90e2b56eb2ffdaee176f4ee6da64385715bf02b18e08f9b53957fd261c9afe9ca6c37b50b209a64f927b6595d6bb31fb71c6d116bd713a69f45e65bd0c1ba020ec43517bb1e49efd9299f534b0b213a763b9e9212ced7626f2298668e09f0e872f29e15558b18d2090becabf488021fca6620b17e1efa2a6c6c4faf50f7b1d35894db6f6a8dd2fd4461cd1347d7b14850f2b4919a2ca9732c628c216d3eefb6cfd63ed9d351d340fca51172a5084b923d87b6a83d81962cf1bbd343859a8a9f4ce0e75501be726df4642e6e666fc89ce4eafc21764e86c2fd1b9985656c73cf1f33e76d7c0751b8352932134361416fd93d4fd425dc6f769769afb1dd015b356a8cf88c3510c62c377f3e4a63e0a92712dc67870c446e529a7581f2febc3da1192f71b7dde15b9b7553338403c0ca0634870464b76ea93c5b2491be277e134c56cc195242699ae7e651af52bdc1bbaefef147a0cc48f6aa0c8cc9e8cd1da99dc6d65b174b91834ca9148c45220ea759d013ae4ba308f131c33d5b04c6944440f92ac428a3031880b3b7d94f9802988a478c3050796914d7f2f17468237bdbc5585c7f3fb66e3a20c93a957b7667f79cc12a953ca3892c6a4ecb83e0005f9c9312fdd8d98fa6385d4eebe48c2e4048bb11ea2699bc7e44c7f8f0fb7ee1d09f50b84f3ec5b8648175221baa4287773231e6f236089d0da8b8293f025f99532185e75f3d2886cf87e15031ad9c821c1a389a2e0f046a3f70af7c320436f533014754ee795705893378370c84c774b8cf43d4ef06354b006140c697ffd754e1b6b8a1b7fbfb122892dfc448aac549a74e92a7450c5c27f57c06c3847b1f79d503291b47b80db38400798717afcc4b69ce0140e1c9eafde3190a7e6b1907f98c3a760fb883696302004b0bf0151b8510cff06c2190c0b7082a415f5e471b857cb0b129f286b4fbda14fcba870d476fa5c5536834de9dab61062a5b9ea94b90652688d7a16b116fc1934dce75c866e96cb075f25405989b50e5056d389a16641c2141975908e44dd55dba09f24681a7d03890985ff52b083fb7749ed2318b13d27b137273b45eb3db3cdacb26fcd7e5dd11b6285a6734b9e78f9819aee190058a3baaa4e99ba0a9dfc130e461215bbb395440ee3cf7239c9a27e1325848d31e7da51018444dcbb1b827771cf7af517b317ab076d2b35aabd99042a9d05d24bddd60d2774daee8cb0f9b8ef487a1a594b7740a6ca5319c3d50931bd2e9554ccdca2d0ced824112725d5a9a081ed5b79f9b27cbd9f012dbb7f40f318afdcb4d2b7a0f1909d237bb078e713fbb6578677080f2e36ac36466ad4184e7db488d390a5afca905c232fd3abb4bcb5c275797d96d1991081b6d73110a192f404a9a6b79be94234b5eca3f429ab753050c374d73f08b8d4147dc983698bee7cbbd8e3e1d64310ea122eab13997d28a114f460a169dacb137f2c424a2007364d85113660f1fb85489ecc5560289448b4f08e71038a112d074696731f6ab48a0bb6624d1d919ffcf44eb97dc782202637a3f2b6bbc6c42726b19a579c2e68bcddcb2c1a00257a033b9eb59fcfb506f05063d3f1b08f55bf4fb731ac8d2817926af18e374096ad2a04f35abccc151a055226d17eec55007c2669bc2086d829ba00e490ee84edc1469c3e506df61a6189fff4061a9180dcf03fff9a59ff35d32f924ede3ae25837fa4a7a901f511787ec3fab619fffb5bf3a42ac489e5fbfc643dfa78ff9840eca78294c4b2b83a592bb8087ef45c1434770d4f4c4d48af452601ce2ccf429f75bd1b9c0e128eba32b318138fc66d6284b4e6a47d573cd189da414b877e7edec95227e59764c1a9a8e3b9b3f67bef726e802d92535c817705b9841b2c14c91ae49206adef82a068a6bd28d471555e2e5b48cdcffa50235733d7e04fc015caee30009e0f2e0e2f04336d3f14dbcfc78a231f7960283db8c19697ae90df6b9b581925de54af85609fc49b37f64077f3a38d50997cdb882d6c7caed1a3bf5b765262e30a3adedb941440d218c20c625d33d42759ffbe3296e303a2f9bc44e631b38b4f36552e87c6d63f902a1bf35db7780c3bb9d94eab8660d58c469c1775d6e4bd72bd63deecf91d41e213b120dad45ea9c72ac2b7f11c5922cc49332f95f775618d9f20af8b801bddc1449c2b9481502777b908a1cf58e7524ce90c6718ba60f781a77baa65c267f8762adf76d17ed02319a9a0577c0ea9433be5cdc0c0e2eeb944361c3bde2eae7a3bd8e22a01035414ad14c3e6bc6881a298f747c7a8310aeb2ac1e666690fa4819f789a400700953ecbaa7314a52bdaf0dacfd7a2b4370fb74d9feb6b91ac854fc5c13b5b7efed6d49e4fd75b166d3accde00b127b921d8453a2ce97efcd252af55535c008079a48f0b155ec562e1524f08fd6baa71ced2a2ce4405831e50dc6f148c08c8e52ea41653c7a6bab0ce72203133f298aa275cce6e11a124d799c43a9ab1591c8b58e92b14a45c9ba6dbf3d786638e1d737590e85e5c7e985d11500a2b17e89d444e5335fa06ce51da333ff8e65dd858dc967d2d2ce5df43e1bb0380c7303ed19d2d56ec437f29d608b8451496ab335d8e594aaf59bf77af14f410e9f5d12a8b73f7337f2cf15259f579d6eec06c099d8bf48ed16f5f8f7df09839f25f56272d69cce97db22352e492987f9fc6cf3741f7af7ff0baa78a7247e6e2236bdb78c13aedcc83cdfa5e4d1276dd8b41864534212825becad87cf712b9332da7158114e4e912bca60875d02548744b9d94ceee20de17d10c77a5d9123f6279df33b86cdece81cebd965c63bf1533b267f7858adf8feb811946a29e6c106eadf39728ca3fe866a96995332fde7ccc9d11265b7d84ad4daabbc046d82a4e8c9768ecbd6c15f091902f9cfad924391f79887df7d0ac219f14ba43746a8a8bf9b943b8f342a9d71cc01e1f6f3a09b880499b211bdc59179e1aa5575a3a5bd8c41895ab4385d009850e8cfade472d9f10967d731520d3a0c23b8d72ca2d88d0d88f7f2e9c3c0cb8e554878778c4f79b405ac7f3a235fc81033d670adee44f55e08239befd51204d37fe6b66ed01908da898a046ff066365894918c9457ab75cd8b62da020b2c2765cd663500e693692e62ceab312f1e680aaba24ad32679a4f476a78724e4e89acfe9081d6d49f54492f1518889dcb18230699f0f273f3fbd048c40755fc5216edaf3bb0ff2e863d9e4549323e27511eb290b23f68ba8f7db3b0a7f3c464c97e28662313afdbb257f21b82ba2c2436bda0d31779fb0a41cf6a0d82bb5830f31acecb691857be43a5ab24be0b2f01f213cce01207c9ea3948b711173f824ec4c8f0e6487f1ac9ed28ec0efbcf58c62d78c571b192d43365767ab6cff3a861d20744e8cac37f8da23ad5ab37d00c651911793dce010534d4d9ea7f7cee378ff313c9578a27b69a46a0e344074cfafe7b6157fb16b4630ee499bf98d7f47da56db4cc5630b2be7a0c9d3b70fd7c2350e8cfd81da6011514ceb9aa82b9259b9b89924896b84dbab8a1a1144374970ff41be73529d18bd77014dc307b3f420c837b77005dd39397827021c0b9d725efbada513466626179c227bd745eb98ed16a49e26e45d9fae0b6638d7510b62680d97001e2caab9bf12fb7b100059884d882dc3d0fd977411fea89cbc04d7ff8eea02e7b3ed58a6ff138ae6b14ec8add128b75b7ca1836255c66058348d8f0e3cbf5e411a4a6b54a2b4b5a3cd703a5b4525f14f6fce7bd085cce01601ba32a7f707a0cd397c7b3205abba9d1e16245c5f7a493c3fb4a40e6053a0c347b11598686971b069e1ad1a39afb427758701f7c56120171d44bf39eb466397cb7949e36c00ef73e5cdfc0a91ab2966ea93366992bb4c0f01d85c083575cbfa4a10e7e79e831b12ee06f65c5236a7efd488fd6d7f7954bc7f447de1f9d27c960ce0ea6a08367aa98c7f23e64d0770c6e3c7ea0cea9fb126b514db8baf634d2d8c97440da752ea68ca2b75e449034f5003f950e56cb48d77e8a8bc5e4ba954a413f143f27e8e5d798625b6a6c5c03faca72b421cdbb410e4a27af50e132fbf32a025cea3c3d508e79321659f38514abe22d4b8e4be01748fbf4d2d659df6d9162d0b52d092d31d2698b48a52b1c364e25e3621c6613730b01a1edfa2e0cc78fec6bea0bd1448b0f768b5ac05f3ecb9214d31e418fc848f9e25d3e0d0a66c3d8c6de17992364e5c37c8370d1a1820b6032970bcc4c01c014d44b7b9c6c297faed6dafc14289426f032260c692c2d962f03338666afed786468d4f8a91741ee4a5272f100e6166</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-xray">
      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">请输入访问密码查看非公开内容</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>Working Logs</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第五章-输入输出管理</title>
    <url>/2021/11/18/operatingSystem5/</url>
    <content><![CDATA[<h2 id="io管理基础">IO管理基础</h2>
<h3 id="设备">设备</h3>
<ul>
<li>详见计组第7章的基本概念、外部设备、IO接口</li>
<li>补充：IO设备的分类
<ul>
<li>按功能分类
<ul>
<li>人机交互设备：打印机、显示器、鼠标、键盘</li>
<li>存储设备：磁盘、磁带、光盘</li>
<li>网络通信设备：网络接口</li>
</ul></li>
<li>按传输速率分类
<ul>
<li>低速设备：键盘、鼠标</li>
<li>中速设备：打印机</li>
<li>高速设备：磁盘、磁带、光盘</li>
</ul></li>
<li>按信息交换单元分类
<ul>
<li>块设备：磁盘</li>
<li>字符设备：打印机、键盘</li>
</ul></li>
</ul></li>
</ul>
<h3 id="io控制方式">IO控制方式</h3>
<ul>
<li>详见计组第7章的IO方式</li>
</ul>
<h3 id="io软件层次结构">IO软件层次结构</h3>
<ul>
<li>用户层IO软件
<ul>
<li>和用户交互的接口</li>
<li>通过系统调用获取操作系统IO服务</li>
</ul></li>
<li>设备独立软件
<ul>
<li>执行设备的公有操作
<ul>
<li>设备分配回收</li>
<li>逻辑设备映射到物理设备</li>
<li>设备保护</li>
<li>缓存管理</li>
<li>差错控制</li>
</ul></li>
<li>向用户层提供接口</li>
</ul></li>
<li>设备驱动程序
<ul>
<li>实现系统对设备的操作指令，驱动设备工作的程序</li>
<li>每个设备一个驱动程序</li>
</ul></li>
<li>中断处理程序
<ul>
<li>保存被中断进程现场</li>
<li>转入中断处理程序</li>
<li>处理完恢复被中断进程现场，返回被中断进程</li>
</ul></li>
<li>硬件
<ul>
<li>包括IO接口（设备控制器、适配器）和设备本身</li>
</ul></li>
</ul>
<h3 id="输入输出应用程序接口">输入输出应用程序接口</h3>
<h4 id="字符设备接口">字符设备接口</h4>
<ul>
<li>字符设备
<ul>
<li>以字符为单位传输数据</li>
<li>不可寻址、顺序存取、速度慢</li>
<li>一般为中断驱动方式，如键盘、打印机</li>
</ul></li>
<li>get操作：从缓冲区获得字符</li>
<li>put操作：输出字符到缓冲区</li>
<li>in-control指令：包含很多参数，每个参数表示一个具体设备的特定功能</li>
<li>打开和关闭操作：实现互斥</li>
</ul>
<h4 id="块设备接口">块设备接口</h4>
<ul>
<li>块设备
<ul>
<li>以数据块为单位传输数据</li>
<li>可寻址，速度快</li>
<li>一般为DMA方式</li>
</ul></li>
<li>接口隐藏了磁盘的二维结构，线性一维编址</li>
<li>将上层的设备打开、读写、关闭等抽象命令转换为设备可识别的具体操作</li>
<li>内存映射接口提供内存字符数组，以访问磁盘，不提供读写操作</li>
</ul>
<h4 id="网络设备接口">网络设备接口</h4>
<ul>
<li>一般为网络套接字接口Socket</li>
<li>本地应用程序通过套接字接口的系统调用，创建本地套接字，连接远程应用程序创建的套接字，实现数据收发</li>
</ul>
<h4 id="阻塞和非阻塞io">阻塞和非阻塞IO</h4>
<ul>
<li>阻塞IO：用户调用IO操作，进程被阻塞，IO操作完成后唤醒进程</li>
<li>非阻塞IO：用户调用IO操作，进程不阻塞，IO调用返回错误返回值。轮询方式查询IO操作是否完成</li>
<li>目前大多数操作系统采用阻塞IO</li>
</ul>
<h3 id="io调度">IO调度</h3>
<ul>
<li>指的是确定IO请求的执行顺序，不一定按照系统调用顺序</li>
<li>目的是减少IO平均等待时间，完善整体性能</li>
<li>后面外存管理的磁盘调度算法就是一种IO调度</li>
</ul>
<h2 id="设备独立软件">设备独立软件</h2>
<h3 id="缓冲区管理">缓冲区管理</h3>
<h4 id="磁盘高速缓存">磁盘高速缓存</h4>
<ul>
<li>本质是Disk
Cache，磁盘内容的备份，逻辑上属于磁盘，物理上属于内存</li>
<li>两个实现方法
<ul>
<li>在内存开辟大小固定的空间</li>
<li>利用内存空闲空间作为缓冲池</li>
</ul></li>
</ul>
<h4 id="缓冲区">缓冲区</h4>
<ul>
<li>本质是Buffer，CPU可以直接和缓冲区快速交换信息，解决CPU和IO设备速度不匹配的问题，提高了并行性</li>
<li>两个实现方法
<ul>
<li>硬件缓冲器：成本高，仅关键部位使用</li>
<li>采用内存缓冲区</li>
</ul></li>
<li>特点：为空时只能传入数据，直到充满；充满后只能传出数据，直到为空</li>
<li>缓冲技术分类（设T为输入缓冲时间，M为输出缓冲时间，C为处理器处理时间）
<ul>
<li>单缓冲
<ul>
<li>含义：一个单向的缓冲区</li>
<li>周期（定量计算）：max(C,T)+M（讨论T和C的大小）</li>
</ul></li>
<li>双缓冲
<ul>
<li>含义：两个同向的缓冲区，一个缓冲区输入时，另一个缓冲区输出</li>
<li>周期（定量计算）：max(C+M,T)（讨论T和C+M的大小）</li>
</ul></li>
<li>循环缓冲
<ul>
<li>含义：多个等大小的缓冲区首尾相连构成环，同时配备in指针、out指针</li>
<li>使用（定性机理）：输入时in指向第一个空缓冲区；输出时out指向第一个满缓冲区</li>
</ul></li>
<li>缓冲池
<ul>
<li>含义：包含多个缓冲区，维护三个缓冲区队列和四个缓冲区</li>
<li>三个缓冲区队列：空缓冲区队列Q1；满数据输入缓冲区队列Q2（从设备到进程方向）；满数据输出缓冲区队列Q3（从进程到设备方向）</li>
<li>收容输入缓冲区B1：从设备接收数据</li>
<li>提取输入缓冲区B2：发送数据到进程</li>
<li>收容输出缓冲区B3：从进程接收数据</li>
<li>提取输出缓冲区B4：发送数据到设备</li>
<li>设备到进程（定性机理）：从Q1取缓冲区作为B1，装满后插入Q2；从Q2取缓冲区作为B2，用完后插入Q1</li>
<li>进程到设备（定性机理）：从Q1取缓冲区作为B3，装满后插入Q3；从Q3取缓冲区作为B4，用完后插入Q1</li>
</ul></li>
</ul></li>
</ul>
<h4 id="高速缓存和缓冲区对比">高速缓存和缓冲区对比</h4>
<ul>
<li>相同点
<ul>
<li>都介于高速设备和低速设备之间</li>
</ul></li>
<li>不同点
<ul>
<li>存放的数据：高速缓存存放的是低速设备的备份数据；存放的是高低速设备之间传输的数据</li>
<li>是否直接访问低速设备：高速缓存找不到数据时，直接访问低速设备；缓冲区则不会直接访问低速设备</li>
</ul></li>
</ul>
<h3 id="设备分配和回收">设备分配和回收</h3>
<h4 id="设备固有属性">设备固有属性</h4>
<ul>
<li>独占式设备
<ul>
<li>设备释放前不允许其他进程使用</li>
<li>比如打印机</li>
</ul></li>
<li>分时式共享设备
<ul>
<li>分时交替，提高利用率</li>
<li>比如磁盘IO操作，各进程分时共享</li>
</ul></li>
<li>虚拟性设备
<ul>
<li>SPOOLing假脱机方式，在磁盘中开辟输入输出井来虚拟化低速外部设备，类似于Buffer</li>
<li>因为磁盘是高速外部设备，所以这是空间换时间的策略</li>
</ul></li>
</ul>
<h4 id="数据结构">数据结构</h4>
<ul>
<li>设备控制表DCT：和设备一一对应，表项为设备属性，包含指向COCT的指针</li>
<li>控制器控制表COCT：和控制器（IO接口）一一对应，包含指向CHCT的指针</li>
<li>通道控制表CHCT：对应多个COCT，因为通道对应多个设备控制器（IO接口）</li>
<li>系统设备表SDT：整个系统一张表，记录连接到系统的物理设备情况（设备类、设备标识、DCT、驱动程序入口等）</li>
</ul>
<h4 id="设备分配策略">设备分配策略</h4>
<ul>
<li>分配原则：提高使用效率；避免死锁</li>
<li>分配方式
<ul>
<li>静态分配
<ul>
<li>作业执行前一次性分配设备，作业撤销前独占设备</li>
<li>无死锁但效率低</li>
<li>独占设备一般采用静态分配</li>
</ul></li>
<li>动态分配
<ul>
<li>执行过程中确定设备分配，使用完立刻释放</li>
<li>效率高，但要考虑死锁</li>
<li>共享设备一般采用动态分配</li>
</ul></li>
</ul></li>
<li>分配算法：常用的是先请求先分配、优先级分配</li>
</ul>
<h4 id="安全性">安全性</h4>
<p>安全性指的是设备分配中防止死锁 + 安全分配方式 *
进程发出IO请求后被阻塞，不保持资源，IO操作完成唤醒进程 *
缺点：CPU和IO设备串行工作 + 不安全分配方式 *
进程发出IO请求后继续运行，仅当请求设备被其他进程占用，才阻塞当前进程。 *
缺点：可能产生死锁</p>
<h4 id="分配流程">分配流程</h4>
<ul>
<li>分配设备
<ul>
<li>进程请求IO</li>
<li>查SDT，找DCT</li>
<li>根据DCT判断设备是否繁忙
<ul>
<li>繁忙则把进程PCB挂到设备队列</li>
</ul></li>
<li>判断安全性
<ul>
<li>安全则分配设备</li>
<li>不安全则把PCB挂到设备队列</li>
</ul></li>
</ul></li>
<li>分配控制器
<ul>
<li>在DCT中找到COCT</li>
<li>根据COCT判断控制器是否繁忙
<ul>
<li>繁忙则把进程PCB挂到控制器队列</li>
<li>否则分配控制器</li>
</ul></li>
</ul></li>
<li>分配通道
<ul>
<li>在COCT中找CHCT</li>
<li>根据CHCT判断通道是否繁忙
<ul>
<li>繁忙则把进程PCB挂到通道队列</li>
<li>否则分配通道</li>
</ul></li>
</ul></li>
</ul>
<h4 id="设备独立性">设备独立性</h4>
<p><em>之前的分配流程都是对具体的物理设备，未考虑设备独立性</em></p>
<p>设备独立性的实现如下 +
应用程序使用<strong>逻辑设备名</strong>请求<strong>设备分配</strong>和<strong>IO操作</strong>
+
设置逻辑设备表LUT（可以系统全局一张LUT；也可以每个用户一张LUT，存入进程PCB）
*
请求设备分配：建立LUT表项，包括逻辑设备名、物理设备名、设备驱动程序入口地址，
* 请求IO操作：LUT表完成逻辑设备名到物理设备名的映射</p>
<h3 id="假脱机技术">假脱机技术</h3>
<ul>
<li>又叫SPOOLing技术，把独占设备改造成共享设备，实现虚拟设备</li>
<li>输入设备数据路径
<ul>
<li>数据经过内存的输入缓冲区，到磁盘的输入井</li>
<li>进程需要输入时，输入井的数据送入内存</li>
</ul></li>
<li>输出设备数据路径
<ul>
<li>数据送到磁盘的输出井</li>
<li>设备空闲时，数据经过内存的输出缓冲区到输出设备</li>
</ul></li>
<li>实例：共享打印机
<ul>
<li>用户进程请求打印</li>
<li>输出进程在输出井申请空间，传入数据</li>
<li>输出进程为用户进程申请并填写<strong>用户请求打印表</strong>，插入请求打印队列</li>
</ul></li>
</ul>
<h3 id="设备驱动程序接口">设备驱动程序接口</h3>
<ul>
<li>不同设备的驱动程序与操作系统的接口相近
<ul>
<li>方便设备驱动程序的添加和编写</li>
</ul></li>
<li>操作系统为每种设备类型（如磁盘类型）定义驱动程序支持的函数
<ul>
<li>比如磁盘的读、写、格式化</li>
<li>驱动程序包含一个表格，包含支持的函数的指针</li>
<li>驱动程序装载时，操作系统记录表格的地址</li>
<li>操作系统调用函数时，通过表格间接调用</li>
</ul></li>
<li>设备作为命名对象出现在文件系统，文件保护规则也适用于IO设备</li>
</ul>
<h2 id="外存管理">外存管理</h2>
<h3 id="磁盘">磁盘</h3>
<h4 id="磁盘结构">磁盘结构</h4>
<ul>
<li>磁头：用于读数据，和磁道一样宽</li>
<li>磁道：磁盘上的同心圆，分为多个扇区</li>
<li>扇区：即一个盘块，通常为512B
<ul>
<li>按角度划分，内道比外道密度大</li>
<li>磁盘存储能力受限于最内道的最大记录密度</li>
</ul></li>
<li>柱面：多个磁盘组成磁盘组时，各磁盘同一个磁道在一个柱面上</li>
<li>磁盘地址：柱面号、盘面号、扇区号（块号）</li>
<li>磁盘安装在磁盘驱动器内</li>
<li>按磁头是否固定于磁盘
<ul>
<li>固定头磁盘</li>
<li>活动头磁盘</li>
</ul></li>
<li>按磁盘是否固定于驱动器
<ul>
<li>固定盘磁盘</li>
<li>可换盘磁盘</li>
</ul></li>
</ul>
<h4 id="磁盘调度方法">磁盘调度方法</h4>
<p>磁盘调度解决的是多个磁盘读写请求的服务顺序 + 磁盘读写时间 *
寻找（道）时间<span class="math inline">\(T_s\)</span> -
启动磁臂时间<span class="math inline">\(s\)</span> - 跨过<span class="math inline">\(n\)</span>条磁道时间<span class="math inline">\(m\times n\)</span> - <span class="math inline">\(T_s=s+m\times n\)</span> * 旋转延迟时间<span class="math inline">\(T_r\)</span> - 转速<span class="math inline">\(r\)</span> - 一般取转半圈的时间<span class="math inline">\(T_r=\frac{1}{2r}\)</span> * 传输时间<span class="math inline">\(T_t\)</span> - 读写<span class="math inline">\(b\)</span>字节，一个磁道<span class="math inline">\(N\)</span>字节，转速<span class="math inline">\(r\)</span> - <span class="math inline">\(T_t=\frac{\frac{b}{N}}{r}=\frac{b}{rN}\)</span> +
磁盘调度算法（主要考虑减少寻道时间） * 先来先服务算法FCFS -
最早请求的优先处理 - 公平简单；性能差 * 最短寻道时间优先SSTF -
与当前磁头最近的磁道对应请求优先处理 - 比FCFS性能好；但有饥饿现象 *
扫描算法SCAN（电梯调度算法） -
在当前磁头移动方向侧，最近的磁道对应请求优先处理 -
初始时需要告知磁头方向 - 性能好；但不利于某一端的访问 *
循环扫描算法C-SCAN -
在SCAN基础上要求只能单向扫描，扫到磁盘端点则快速返回另一端 -
使得磁道两端的请求处理比较公平 * LOOK和C-LOOK -
一般默认SCAN和C-SCAN在变向时都需要扫描至磁盘端点，可以改进为只扫描到最靠近端点的请求
- 当然也可以默认SCAN和C-SCAN就是LOOK和C-LOOK * 减少延迟时间 -
同盘面不同扇区交替编号 - 不同盘面错位编号 -
比如盘面1编号：02413，盘面2编号：30241</p>
<h4 id="格式化和分区">格式化和分区</h4>
<ul>
<li>低级格式化（物理分区）
<ul>
<li>一个空白磁盘划分出柱面磁道，每个磁道划分成多个扇区</li>
<li>由硬盘生产商进行</li>
</ul></li>
<li>逻辑分区
<ul>
<li>一个物理盘分成多个逻辑盘分区，比如分成C盘，D盘</li>
<li>每个分区由若干柱面组成</li>
</ul></li>
<li>高级格式化（逻辑格式化）
<ul>
<li>简单来说：操作系统在硬盘上的初始化</li>
<li>具体来说：创建文件系统，把初始时的数据结构（比如空闲空间、已分配空间、空目录）存储到磁盘上</li>
</ul></li>
</ul>
<h4 id="逻辑地址到物理地址">逻辑地址到物理地址</h4>
<ul>
<li>磁盘物理地址（从<span class="math inline">\(1\)</span>开始）
<ul>
<li>当前的柱面<span class="math inline">\(C\)</span>号、磁头号<span class="math inline">\(H\)</span>、扇区号<span class="math inline">\(S\)</span></li>
</ul></li>
<li>转换需知的一些量
<ul>
<li>起始扇区柱面号<span class="math inline">\(C_1\)</span>、磁头号<span class="math inline">\(H_1\)</span>、扇区号<span class="math inline">\(S_1\)</span></li>
<li>硬盘每个磁道的扇区数<span class="math inline">\(N_S\)</span>、每个柱面的磁头（道）数<span class="math inline">\(N_H\)</span></li>
</ul></li>
<li>磁盘逻辑编址（从<span class="math inline">\(0\)</span>开始）
<ul>
<li>前面块设备接口小节提到过，逻辑上一维编址</li>
<li>先变扇区、再变磁头、最后变柱面（因为寻道需要移动机械臂，耗时最长）</li>
<li>物理到逻辑地址
<ul>
<li><span class="math inline">\(LS=(C-C_1)(N_H\times
N_S)+(H-H_1)N_S+(S-S_1)\)</span></li>
</ul></li>
<li>逻辑到物理地址
<ul>
<li><span class="math inline">\(C=C_1+(L_S\ div\ N_S)\ div\
N_H\)</span></li>
<li><span class="math inline">\(H=H_1+(L_S\ div\ N_S)mod \
N_H\)</span></li>
<li><span class="math inline">\(S=S_1+(L_S\ mod\ N_H)\)</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="固态硬盘">固态硬盘</h3>
<ul>
<li>主要内容见计组第三章，此处补充两点</li>
<li>读写性能特性
<ul>
<li>不使用磁头，寻道时间几乎为0</li>
<li>采用闪存为存储介质，读取速度快</li>
<li>持续写入速度远快于机械硬盘</li>
</ul></li>
<li>磨损均衡
<ul>
<li>是基于SSD主控芯片的内置平衡机制</li>
<li>作用是均衡SSD内部各个区块闪存颗粒的使用程度，延长整体使用寿命</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【工作日志】 2021年3月</title>
    <url>/2021/03/01/worklog-2021-3/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误，请重试" data-whm="密码验证错误，请再试一试">
  <script id="hbeData" type="hbeData" data-hmacdigest="342506be3a3964a20fcd3e000b7519adbac0d29bae9205ccd65806361a1058e1">ad43cd26d5b7026203cb76ab857976b3fae4deb41e0851382517be9714c0e852eee40e9d9dea7d566842c084141ddf2c753ab152704dfd05ba6a33024b991c386ead436920a8fd87978624ba3a33dd40cd4b07344fb6bccd103834826cf8c861a8941f4f7ae9022fcbb5920af76a1d2fed7b33d5f732f58d36f091715c4f1fd0096f0c313c099bc7ce4ebd707406afa79cfc3dcdb976e0359b2d008c0b5dd391809173e503da3447edc8e1f82dc91d4699b4087b52753e063770ecc1080e930b8b58ddc2a7f5bbbcc6ab1f2433894ee10c37010e91a88dc38c91d2aada1d792dcf25f4a4de0f6131125be2ffd80f6a9d0b034dab8f2f9a922745fd0a36c510394b0c3ce4b7784b8711eb63b811de286bef222c9b79aa8fcce6b1cc1fdd2026ec6ae37997fe3ca012f1cc5dd798146e98067a13ceba59a1e8f5e41f6dd1ae20dc4c4edd1d9f500cee5f6ef7fdefab4e414b36390a7c3521c74fb10674c1783ee8deed4a6b12e8b62fbec1af64fa9f0da01ac6e6558949455aa5be0a94b396aeaa6fc1c8ed26ea1703ee1660c9e4ac2ae15d1dceb592eb97681a0c9263424890eb0fc94e95dcf5c5daadcaa3c680851b8a7845bf584ec25340016143cd00a3d377373330f7d06df117816b68a981c343f45d193003bba93cb3baa2105ef84ef8343f191fdd27e4e5da2897bda94eb1bed5f1788a4eb305cb717a949c75e9e6bdb124ad81dd093d05d5733a5ce7f15d7f0085f9ea265f147027ac5214cf4c9f2ccff8d8885d6426c491e9417ddc446885950453a0a9ed172e9042ea24bc4aaba0bd04ed22a4d3e1940e898bda4d7e8561a2355d91e27a991611b8a784f9625030441cd2be9f01b21ce76dd1166631cdb5b086b672a56ad39b6a13af02c47af6242e2711b49b8ffd129d87f1bbcf03a231d2fa7bc2d4b290aafa64e198fe2c682be902f4b3aa6a191c8f5b7847e8d5cd4cfb3d1ec2e9fcecf25033db43fca392ab3bff47663bac463bccc4a4fa87ca525a3337516bc6842719e8bf5a5fe9e7d27a17ab23cf6a3b9c16ec506c125450c1298aeae5953fd970e6a879d3735fe0513e11e890883f1b09a77fc9626f92c8ad125eda7d3052a9be993632b64808a5b9e001ba0c7b7ea60f1bc44f035d2068d9f915881a0a7771399746443377093be07bcd482b7222436a5807301ec8c38d451015a8b60d753b44e5378e0e8f92cdf858e483c97063c5d5161d92f65855e74c8d9548db7f5fe9248f17943941c8455a67563b739d687b6dbe890115f0b9ea55d6134e112ac966a683e5ca89cf2d1ee5007c5da5fb55a76941c4b0a5d7fc6c081baf633babc06edb619123134b811ca167c4be3a16ae333233a796c34d955cfe6fe268a276e25cce124abc2d943201a03db1638cddaebbbba2b225353d4b868b80095439f2fd05c060b4d25bb172db4395510fd0fbad3eb4551ba2e6f18a34a975415f7d7be40b8b3ea330634727ce8e1588eb4a214238592fd92fc82791f1648e3fc3e9ebf54e56bb03224f0da75684a1d9830b652aafc65ac7cb0102ee55a7ab59b6b906b9b533236315021049b718076e7df2438399dab1c512f2021dca5346e45ce7c783f360bee9bb7deca4a203c87d0efc5b5adaa6dd100e6ac2b3a23030cfc889ab8d328675b244436a85ea90bfab5edf438e2d5adc922fae90848600783db7978b52e2c3672478af7bb9366e47a98a7db5b1c60b017dc500fed89060eca9f7d65365f9344e5deabf7496c9374343bf08b23e40054ce29ec5e762390f5aa18c522eac1baa304e90a901d49f9971cd9fd6cc94fc62eedc54c4abc5a5c9894408a7643b0c9c9376075ab41d802e29c9342e33765d16fbbe7ee9d35ebf3ac7ef5240ee73941b46f048301b681955ef5a344b5547eb01cb302a9fabb4eb0f2e6bbb3c2c55492e3365ab32c936009bf4fa09933422aa82d63041fa4875dda653eb110038da12d42d9846b0d2affa933a75eaf7e8b321f807975294c3b8344444812d9c2ad7de6662b0247ae6423e0000355ad29529c796fc3f1d1b1f5f4a430ba5b6448dc5d302dc4f10b4873eac184201debe7bd27f072f4f02eb10bd85d79ad4632c6defc3937e81aa9b53fd92b7a323ef788d9baa4974c78b6c807f1a8ebc8588b0003a6125b9c8c4acb19f4491a826051ff5b2d8a4f21bf6a41b8ac01716bd0af38f0784002e578b79b66d493502189371528601ac8c8ad4d8cd66fdda7d593dcfbefa1f32698b6d8155d4e5ef95a4587b202995af0c298ffe7cb6e5b7fa96d630a2ec2221eaac56b07d32cd73b11c71be3c2d92552d8f207ee5578423c2a7aa7548293e5cb39fabf09da1e19ab415690a0008a63f6f5b1b06b23af7e127ed672463e4d5104c60194075e53e300fb0dc7c1d5393b84bc84341eb7646acfd3b456c2be81d9c89c398d82e86f52ec0d89bec1e7845c08c421e87c0a3655e18da6ffe81f9d73f5be030417677b0b77ac67cb110d5ccadf2effaf52700a13a5beba650abd7470110029a37854d24b2f8588525bd0b54107a9747954bc85230abce258689334d5e5ab095e26bfba51eee0a9943862672791914fca5cc8aafcb5e3063c15e68db2e51ab025d904e2cb6e8a43e98195764c43093440574e11194b83b669d46be8bd0067e6499c93d5109de2e9edf99d9ba970275b791a3b9dd765a4a217c2f6c328f4505fc8a13aef97d20e5aa42000c5c733329e20b0634074da945da4c6e6e6350030bb07888d2bfacf1cea7e9e4c8f587b4fc94235c8691696eb30d39fdf0651d8e43d60ead201c9651f2e0d82e7312dab695e818be4464fe92885edada8b9b3bc3bcbc79def36f775f44a00aeadeeed52399a404afb9a0f67ab5bc75bddc57332f6dd4f5fe02b43cba976fda7ac3bbdd54ada2c057b747f78bf3db1e77f107d4a2d48dd06baf9d9966ff5c15c88de209b57238550d318f61dda7e6a48b6498261fe9c6e756463dd635e44174c697a474827b3159df5018ce81a29be9fb1350d9a7b0398d334cf06449ff417521b1c301860411cc4510fb0f141995db6aaddf603471eeb76f8ecaf2bc565da32e2a22d74ca7be7d0408b24fc00bb18cedf7a7c87b3880bad35f7b296d17c2ee85f00154398ca38c3cb209c1ccc25af7869e4ab3e9e900e3a21217fbe8dd5b292d4c6697f37aa5d25b42517b17768fb5a38870552c42ad8a069c94ae37bd8c3b385297dec58fd5c10fc078bcfd0ce4b53b747b0959b8f8b514fbcaba7ef73407c44680b67e3677cd30235efb4e9e2f9c9312153bc6d9e0ad224a840fee51e26409b36a766704ed8eb163b4b243bfa2aea664251af4b5e254cc74fae7cd222698e7c54602748e24148af96d5a4ecd62c3065d8dc285507e54035507457db138e4bc0966ed56ddec3a02870c2aaa2a15db47f2fbf7464f0981882b63a2c4466faef27e05d9118e49aefc23c6b03b256d1aaac7e366fc808f7d17a2fd1f8297e4292372bee83e4c11c7ec20dd08c49d4ad17b4b2cf090b4f923551fa56143d9820acd46194315bdb548c10e59a36c2da018f0879be224d7f911371ce6cc9d3862460c857b316c0b5043063a7074a479c9b1e453141542df53a4ef41a1ab2a14ed8e3b00d5a50a1b78318b105d4a7b62d8827d392a37a5dfbaea266b1fcc04ceb4c31f61ec55721eede5309cf351473436aa510ff80424d44cccaa1c3b4e3ead013184e3d4268606e07bf0062909da43c98388d690c5b47304a0afc3221ec636d8c332ed75a1b189fc6a40140160e7e000928e10838d64643f8f8fd9523878e46feca7f5e0f9afefa5ae96eb9c8f2d9067ae2771640f2677051f0b35888613cad51b73fb2ea4e2921778426bfc08abd61a9fa994ce98e7e32e30b183407feaede14a4c5bfe1b0c664a4e739eb283b3570c6de00295cb6952394f91560875fd167c0f3f899ecec8ab581c77e57cf42777c0130f9af26c5064f61a8bb7427d461e163d60ac6f4d6714f7b105708ed74082ffc1e88ceb78e6467bede023acc1b11a90cc4f9785d57a238320ef27645249dd3cc5c431a5a8e694b5dc59d5b0370b66ceda72c41c1cddf32c957aac66f29029818036892e17bc0ab565f55050b86328473a6f3787feb200545098bae85c0ee80fa479611a3b9d5438ec23373fce450999a2ab4954135ec5accdb3e2c2890a2bfd37e81b3d0983ed2192974d76944518a458b32d27155aec7da429605311f0f516565da54400760214236ef327ca0a3cb9e13c0d73170f4ce4954584f6e9399cd5bc2cb4d730e351faf0a6d9293aa318bc0cab6f735c2fa78ba101c19fcc7ef933a5b47640a430e9f185f3291cdeca8c7c000506a1c4bede949db4fa44ef12fce88374a6ff9cc4cc714542d04ff282041986e1c7ee88352e9b33f5e961a56d13a6cc522faa1274875c5e36731054fea34e8bf4d36439d0b4d3c379162ea8fae2174c68acd14943213df18606f09368b87e5a00cd4edf021603d454ebf2f580cf06f3536cce31d4de474b5ce8b5fc684eb740bac174e451df7e1962250b961a1cc1744777db5795350b95c1280d2c0159cc41374bcafa5070cd5f11c097b55d007e3e20c6e899c7a86a72bb820bb7e2d3bc2fa63d0cd4fc6637f058cca0d285e3b5a1113154e0c380842b3ae674e53b174c9706d53b3edd651e4d4f7a0b69430230a49f901ca98e291d12e25e0c4eb936e022734c740bb38269f08bb60d00a64350d1e82b476189a051351d91a5bdfff27209a3f63d2ea1ee685a6e62e958f82383c983443ff7c2d454682cd45ce38a361edd851c5b22099ae4f088ce04fafe5e3a6bc5dc7d1c41d7ddcee1417e33952821b1ebb11eb5ed306fa25ea149585d4922f0609685fef78f6cb374a2361827ab33bc442510b6158542896e7cf032d84e0949c406cdd4ebffa69e2f97b627b6d4dddce4959397e15379e86a7a3036acf90878be9b685e92a59efc615512c075eba46d42b5b98aa115b323350618680ec249ca25ca61ae92f6b014c83d4dbc372e5dd1a1778e7180a4a698359b210bdc9028be672712c582d0c5fd8108714a51873dd52293c1253233e1c821b944204043c1243c21412e8b74ac504d70b93ae712</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-xray">
      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">请输入访问密码查看非公开内容</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>Working Logs</tag>
      </tags>
  </entry>
  <entry>
    <title>【工作日志】 2021年4月</title>
    <url>/2021/04/13/worklog-2021-4/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误，请重试" data-whm="密码验证错误，请再试一试">
  <script id="hbeData" type="hbeData" data-hmacdigest="58f137fda252118849f14d2de3e7907c3d9d0a1773602df7796521dc28e5eb8b">ad43cd26d5b7026203cb76ab857976b3fae4deb41e0851382517be9714c0e8526a1a63054d11a7376f760aa95b411871a68bc55284202266b8474b1d69f152d01d90e225f2d369026dcf6e6f3501cb2774eb96f845e6ede35f5ade0d47fc74c265c62d90155a5f3371d8d279ad6c489529c8642f361230f5de25521f76102786657fbd3e6eb61049d9a73a12b8d08bd334b605b91348db42169f3837cea8688466fdb6af00d7f25b73e79769ef13055991375b0385396a0238db13d1342b3d1c5377be3941e3b9deaa8f07b1feef9def2226fcbc4e6c3d9e5f24102aac7326b1eedef89ebbf1e5f4da486c331e281b1e84205688fe9a01551372c2dc8876cb9ec98811b092f6a22366ea7dd23f5ff404e0ee9288a3ed23579b3759e96eb9749a5207e5c5aea6663ce8021eba26785b2910048d59d9d2fdbfb7c5134a3a98755be18c6f504ec00e67f6e92e0cc599796d5f4a0958899b255b84c7b20c692e581692f91c9987cf8fff47c646c7360a1c2782005bc218225255ea33605664a1a5b368928349b99ab75d3ff7993c947a76732314d4c7865067350b89517dc9e2f7e02ffde7e99046cedca3ec02fe61fa49fb5add3ab70e1799b0396a255ace85cbd97760beff07abd0022390e8a0616cc1dec39c83f972bac977a9e712fef396643112cf18c1c1ab5a3ba95c6407abf4cefc027b88d835f56e590bd6a7861c79cf98380d69bd23a69092bf634b888ff64866f151b104fff05e6000ab4933f63869d7c7538e8b2d1ca6692bda0e15f3e448d99c1a19bc7cadeee5e6640b64414432f40588f27e736a58f34a8edf9b26c624d4f24715979b633f0491cdeb0436590cc8bfd49a7535d31035ed1ec62b76fa08fac0c76ba5ca4464f2e72c08c050cab8eb5b97fc3dd308614a4650db8a3dbe811c67a58bb2db5f14789806fbba9dee53f1dae4a2b9f7cfb075271a395dd31e23a6e7d20ef69a7ca8bf4f6d0799452e0c27c61c503af94b6e24430f794a1cdbf86ae66af6ea2a6e853e4c900aba05e99ab0f30f40d40376f2f7bc5b71d6a2529abe311e0b645364103fe14a58f3e9303c45d5ebccb539765148684dc6199d7bff3dae459927d7dc0da411132913357ec8df9e8b517de03ab9485a619718c7ce67ccdcdf8700f9dab9aa6c9d03ca5cbd5f255e1d8b2e84246712fa45266ba0e4f6e868694771c5c21ef3a8e3ece1026714df9ceb98e0dd315e265e5fce813a08fa0c89c70460161c6cc8a32c5f1cdf8bf7d67455a61e4c9ee66edf1ab77119042b71e59217b3623de0dae808e593db02829b1dd8013b68cde4ba63c68ce4e34cf8a6815106a6a42ffdcadffe577feb730561ce70f311314ffeef478d652a4403c99b58c82c2aecd00799da5920880d7e57010ec99b039c579246fb9517ae181003635a62dc5e8033030f2e628a539c4b2a9669c80d79e20a1d7f5aedb59c6673e83dc2b1ca088211ad6d594cb4c2bd8b77d4c3a155e02e83bb56337511d2be90bb32cb5a47844ca90bdc1f21ee1518818cfd0613834830b4819c2b1b19736edd55666c5b5937d42e440dd3e7980b93ace1768ddf7cf67679f0803e327ca264822b22e8a5e7988c2c88b84ba4f6cae16cd0b5f6d2a9b5274fa9ba7329ef0bd48f1402665c7b504e190443c277dc47f79e02ca3d10c71cf71c81df24c012d26511906ec4a1e47cdd6bd9d79d675465eee40d4e0931198f7d6cd58bf01364f5419c3b3ae12215cb937cf863d65d046a346e49ab8b18c10abff360c309daae8c2df2b279d9e12ae64d41697bf1550a3439e5cac738889ec65a7ed1474fa78375b034c6e4756d6329faa55d1620cc0d0e24539f35c9a2cbd45ff1d89bfbd9fca323a98a2e54d6978a3c0b05ed5a70109a826598fedb0f5e474d21001c6402a354c058056abd68ad88929779d25a7971cbad9b2369dc1f5a27b80424ecb166d52369e7f40f4ea1aef1c00b25b391bd66926af995c37bc09fea0ebf622b3e65a81b06954da3012c6656289fb6268dc2d976542952c9a52bf18ad0b0a25db4dc98daa4992f3f96494e652737bc05244a4b5ba403df788cf0b7d4b3ff44a32aa9f64aa6253be03eb44a12d2d14925fac2f1a9b2841cba9bfff11846fc21549e16fac47037ee0a204ea632bdec0b092a49d547506161a0f0b3dc4e38971edb42dff840ef86f4ee368e6bba932a625e58a50dc8426d3ef5d72a74343a61eecc5ad79a2f4ca653aa19787da70b3cedd6e7da096bd35d38619c7293e0488c1efb780e648ae2bc90e16c217f6d1a3e3c33b7d0f487d7e6a6d3fdbf499d962673fcf94859883e8af3d8bd0beff3f58f3603cf8f170df10a424a7c72d8090f76c337d607a6181e38965a388fdfd046e4a952868d9c06568d48157afbbd2679478ed38a462f669af1d05479d924dfe7fbcf35ddbb709c7cc4d89de880a2cc4d19740db9ed3237a702dec4302e41f94b7f202ad4729fa9b2857904118133a91e57838b48220e65ebc618784633cf3ae512f2a12df14909295207348c4cd614ba2b97395a826d58cd2d1b9ddd8c7cc727d34f1abe0002221f328d42158d55812579c375b37dbbcc8a0f63b224c0d4cbc5db3a636e32f3a58bad08ea62a352bb04af85bdccf0a9a70febdaac13153b3538f37509b551b307c9c06f7caca66c9fb5e999cd6ad7e39ed3343a0629380db4fc98b3d4dbc781977e888165bb634923c280d27bf688a1ee55adda8eda2c8921ec62bb2214b78c4fb350293032060e37d09c9df4050623b257d886aa0333016066e2d4bd47891734919dcdefbecf0c8a5a377c9b335957603fdb44b9238c4ea10e3d56b5b9ab06b3d52b34a773717f8b54ec3d51e40ba601ca926d9824ba2b75143c54bdd84236287ba8101199a32ffe0563a3fe8bf63f91b4693aa429edb089079a10e34cee95ab4e36d353b3e22a6398040156c2d2fb9be483ab66c3939f060654ff6c9b58d475931f8521f7d47ad1978376e908aabec548f5de759f87cbed502c6f2e34ac025ac12e0f820ccc05605c94a3a7b9bf1616917cd1ed60971be30b337b00f537f803d99d72bb746d897fafb54b08805ff66065adf3ac284969dc5118badfa7adff1dbcd1648b11a7c1ee5d0abeffe0f8453aadf4fdd220419ec2d298c3fc5c896ded8ec233857e709c3f0b82054122f4cf3965655dd4d315670a7d10f4e5dfb193458324451adb05a2659a5d074988eb5adb1214816dbbd52a880bbbe091bb63c15894ee2985e18047d9a904c2d4e74484387d160ea4da1f54b6410b0b22f2c52901b595e3874abdcb1438eae4ea3c61d82f6b7648d7b723b2327b0287a59574d958c4378fd7fa3901eabe3057387596b5acd7c394e103acf7f4cf3cf4679f8ac9c7183ba266cdd9b937e28d919e445b8012c1f2517dd0c2fc4ca0b886b1d63177484854f38385b11f898553d82f2ebc24d80b1f5f1afece13956e116aafca04919988bc27d26ba926b17cae46a60efc9650e1d01f6dfbe8238403fd35d366007513ee1a28c008d1fd4607a22652602f0f83c609621f4ed9a3753187d2164728ac4c6a9fdb2945c590fd9f91e16920228347eac7c5e403502db367ebf2b6bfa9e368af5da23da7a9e8d741645c256720b2cfcfb85dbf612397a6b458a03b9665b018ccdbd192920a66e4f38771e2e8b2b2196d0c5e0e4e30a21cab6049c64974feef4668146d9c6b632295718ddabde3bbea5bf50ea14694c405382b94d885d8e6ac87c23425251f86e0407bbec448087a8e914cdc3dd1a69dcf49709e61267a7e0fe68ac687ef3c22d9c7c9cfc348d34b413cc6f6902212ad735a8e4f3c9b880768fc639a5e15c8c246b9861ab482a557794abe277691ed0ede85a149e8dca9c878067de7f125f06958d2bcad01b242080b70263a711764b339571201eb4aa409da349c6b2bc4fb6016c39d9c8ae738e4630031a381519d097d9fae45504b3ac6f85eff017fa2a1854caa665d02eaf8b02d61ef93ee5ebed32a0ef82c20d555e2efe26cd6fc3faf84f50022b8f27230059966d59d4634fe8226bbe50cc88a651b90cc860de8e023ff74e6ee91d38a65aa6c2e97f8f83279d2a331f5b71ac5b0111f0060db110a51faab53a999f0055f3ec6a5435c3a6b48f6f059a3c73080e76b60c20658389975ae7acf7a0c1ef6d3f817ca5c5ce5eff9066ec2f84c5ee25a755011e98e019e82918cc804a7382c82c4c00370cb9c8ceb8f68b7faaad4010c834284ee11f666c0135df9a181ccfad549391d9654461bd971dcbc05ec64acb22cd364aa57c300776a53b652ea718dedf325ef9c5072d8cc43a6feafa0ab65505aa7269ff52ae460f2f71fc422c182dca43700e760a8603f72cf692ececd57596b8e4356ef3d435c0c2f739f842310b105030ac3ddbac50f505136cf91fce4d5382a8b27223ad74c5326a67211b1b4e9642bdec0e07c5abf1d5faadcc7b90cfd67776f657384b8eff8846e04cd14118ae6b7a5d0a85fbc9a2b195b3ce7b422943033206508ccf2487022d17fe0afc0286e77bcf6708d9ee9539e38ddd95022104cdd65523ae7c14bcc786dc9085619ee0d54d7c5f71f0e0dab2faa0385c494b15bca654ab5b5f190cf6eccb5bf5a5335a6d5a4a7097f021a55f28e4cf3207a052da34c40a75b5efc8715991d403e8a4a31912f7f236b21b52c2bdd2b78e8e209deffc3022de993f5647f2d74a6d44e716be8d3bed825c941b3f514fadc290a7ed85c6ac8d240aab783f6d4b443a7286de100f994c5f67689734f76d611f6ed53375701d30f6b695836d34c6ec894fdd203bca68c31879b7edeb8a1b206cdbc44f500a8cdc45908d2df9db5f97a9c8cdde1c82500eeba235f0622ef6e0d980ce433630f868ae64ef9fecd5b9850f2609b3a88642be2d3167c8e4de81efbdfb8c10dfb48fe21e91bd1d771f67ced44815644539b64f09627978378305ade221bc367e65d381e22f32cb5c06792fa13cba42a533beb760b4e2351cd186494b400e8a70a9fe93ccc138ca7c483471cbfee81143a7d9f6aaede1a932f7b0c0d9fd022dd2d2f0474cac9f0396935c93c8f2d63c112a997cfc1f06f97f8d3f59571d7117c4a7bfff72e1a5ad381e78ba892fceb1913c880b340e2394c86469348d4ee8064ed3e0e4c3fc2806ed8f53ea818fb6f74031a4aad4a8f485ff103de976208a0095a3c596297ed45c70081941121bfa24492a70db836a1e8628bed81e0788dac78e3dbe88e60d9a29f4451061f8b70421678db1ad1d1ab6e068d4bd8a335d1b90c92c124c70715a726f15c9e22a3e93a825b2474ffa186dd035341fc54aa48a1e91ac74af4281d45cfbb2a2eb02dc0a48e883333bc69938846cfee420fc2c88e99ea6d8d95a75ec06e40ad03d85cdc3c77716805d17b99e0ee496f62978e1ba51df2ceab059634c931b2949e0e25f66abf6f0ce9993ea4963f6a32691198b5bdc0a41c6977a3d6994424b5a6719d13370db2f144b986f6c3cf47d41d25d48bb08c3ac7eb5e6969be04e28fc85dc65b0fe7175ae513a6c9d339c1161dbc3fbadd2d5213553dde8443308b149a1270d606e596937d92e66387ca6f312055f846c93afb92160995736a2a1a40f7b51006edc5d272f0e13de810b3d5590f6176b5c01fe4ae2f087127dee9af00870abf3ad8976e5f0d9d62f188cf1b3d9fde2caff561d98ea540407fed6b658563a74e86a3cb96e3cc01705e62144b2ce7b8ef91e55c856db72e75e4f58518acc9b3ec70c709f77b66921edc2b2c432df2743c150c1e96e18cbb607ad47098fc9fa6f183741a0b503fbdcd8cd33158bc08540c83e8a177543457eab2a59b25e5bf7dc9094fa4883d5b91700abe1fc64719ce36c566afd22838d048c5ec87e6f11ad6da4f99efc99cc58907ea26959a6268a917b9b0b37c2a3c065cc54088d59505aa5b93340a6efdfeec16f17bf9982d3c80d22906e7ba671a95a44a8c253383b07ea160d13443eedd8d7a</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-xray">
      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">请输入访问密码查看非公开内容</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>Working Logs</tag>
      </tags>
  </entry>
  <entry>
    <title>【工作日志】 2021年5月</title>
    <url>/2021/05/07/worklog-2021-5/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误，请重试" data-whm="密码验证错误，请再试一试">
  <script id="hbeData" type="hbeData" data-hmacdigest="042bd86336380cded67da41887622d5c72ef9292ab8523071373301fd9f7e23d">ad43cd26d5b7026203cb76ab857976b3fae4deb41e0851382517be9714c0e8528e031dcacdbc50232911186f8e4fe407158307011eaf64306330ed89245891e114eba602193afd87840ce82f9d61bd644ce3b3d19bfac560fb5a220790a2950110c3baaeaffcf3239a8be57df4d1b43544b9e7e8091d02ab24b2ba46f0bcb39b2c29c504753b9d645119f2ddc5957966932291c4edc50035b8bca9d3247582754f1f008f7fda4ba3af1141ad079464d471c7b0abf35a2f1ea05b33203cd6f2e375257781eba40fa15563b76336fbcab1e1a7f3453e14d5e41ba7ddb6629038c1e0384c4d89a133dec97de681880be385d00537e993e7476d53c8e89bdf604e8355354ba2f56bc459a0cc53433a1135ab2c815618ec203a6deb35705877fa10fca94cf83cce7815c09cbc5c661929b65ff3dd6610fbee33691fa235d65b7dcb5b6bb9bdc36b6ee847873dc281e35965ca98abc44a66db9d52994becd0cc19fdbf2fb8f80e73aca4fcb67b2136bf1ae10b653d057d096bcaba504b979556fa19260e3cb1fb288620aa5d5cfe802edb448da14eb4a6b8e8debac9c6b2060c13d98dd79f740190c5a86009b0739112a4b7df34a8385aac78e94a7adbc4e89a79ac73d51da3a545cbf30cf74918d50279d1888c4ee275cb652c421dff3db1e5a0e4a64664f23df431d2ca197ee0737c3b4c28f74a619f03d6d6f2b77fc281b482984d959fbf70c697fc08d7de7704121d7ad1e0263a29cb2343e007bfe674e5dd4d4bbeec2a99a57de2ba6a3418d045fdf6d2f1b87dcc16c66755ca95fc1a28165ea62d78b5f8c6be851bee7e10cc190f9cc4679f0848ec8ab1129e97a03090bbbbe7643c93138a397ec5c4bf883c3e037b9c18e8cf506184ef4e9db7b0d15d7b8f28757b2d407608d84821c38dfbca0d303e614ac3bb2a1502dcb35fa4b3aa8290a92117d24c43ccbca0d72c77993a2078b8617a06440318c3a8994d24624b0acfe8c4a230e58a21be3ca53083e8f88097f1233d19dffea8a378f73cf6bbf7e4b9b23cf4c928d792d3fd9e2d6fc54c8b2678f3397ce6bcd17ab7f5c5560cbbc987e46085641003bf437879df318781da7344e12e149bf8ea275704b9e7881411ba1eb64412e4e020019c1646dbe6589b3711cea32fbfdc6979db8128c9a84022fedbe6cae6c7669d041426077d356413f63e1bc1eec4e74adc3ece2ce28211bb823f46c3c93b1026159b22812e553bbf934a5c72ebc733eeec6311274bedc945dbb477adfd155d0d71258301d23d14053f0b6812a2ba7034b4126da029889b22bb7d87100c17e18fc93259743c58f44bf16647fa39c98caa7eb578adddf6779d087d38a80c2ef21138da0d5485d0a3175d637a7a7095e9a21c50b1e70ffc7bbb50a4910c0b4aca4d0cfd55cd08f9624bdbbbf303a37b82c29970a44bf3c415c4ce384d194b887ff6fde38358611f5b7529f7e933bf8b299699c30b4a2e361ea8d758eb8dd6bf559b6ef7cefb46e63419437c7a4a3754687d58cb9c874a6f3b4b94853f9d120f4f865275b4f0066b484f1747c9be87fe38d033e6106d973b46b12b68199d08372c70f9fc9dd62bdcb87eb666420c9d5f62671f1631fccb8d611a80b35f73ef24041f6fef23099ffa959e378e1a8f0b93ec283dc6ddfce6413c37a0ba246ffa6ccafbecaafdc6461b2de1d0033269f6b60c90603e97f95ca64cec38a8409c7bdf978f38210a78f88d11b80dc3b93621f632d94787d4b7a594aba0647b151d6b2665aba2633482279fac6b83c147771c742f9138a5ec369e2a5ed8d8c594bc9007de2eb1fc4a3a504c381cbedbd4dad73c8d819b8a829b89ed96a5eecc8fcc2156ae8e9728fd8e826b2cb8e57e6602ccabe6a1d5f245f95e1ef0496cff54eb12680d9593fb7b1f1ef1437f31aa232f7c9e8f688cba8d18c4e3140dec5aa08cd1e9f94bd82cd5dbdf18e6655803c29931a675b340dff85798f22535882d28a88dba3572376d2c644ae7dbdc16dda3ce8af41548388ef8db7bd96fa8361f6492d45718e72c6f3825159978bd7d203df985a8fcbb8d9a95f93c316192715c34474ca03480b232e09ae125c8ca5087df59c4bfb7c9e2febc59ec115ab147d0a95c68857af29f32dda01cd5840d78b23963428e86b9b9537139cb88c2afae2155defc960289e0fed82c3bfafebceb4446cc8ebd8b6f8c9af161d3cc0778c18511b521e38577a5bab9534216099e0b9193cd6b82ed78ddcd24d20aa15e53a1ac5ca7619381e788304e8abc082131433aa0d167a142850ea04870bb2834f2e72fee2a1ac8ae1846958f0f10fd5249968b6c94cc89694b32dcbc2aa53c5529a1934e101f7ed02f8ebb0b5ee830967e24a3e07537336a84a29b2aa290fa3e5d40d6a9d337f74ded616a2539005e0a783353400f7da8de796397a03bc4f379ecfe9aba383e2bb44de4559817e68fa10952c3bef7ab969d87d054eec232c7667667e62b4dc45ae4f94180a5a927ef8b4d043ba5e2c30f7a4fb5b2729730f928c8deeb9124824f4036b715c2aa3897380f10cdb4c3ab8d7c58652c4456dfd9fd7394860e0ce32973a16dc6b6e114c496c7430c96de7116f499153a81d0f317dba6f5fd447287f706128e4c23138ed4a4544a55aed4e3a347f7978397f6ef81e5c4ad77f6753dc7754dcd631e3ef9f9b6a146635777e637b5ba69aaadb475e0455c9cf710d383a8bc3b4f2861f81fbb2fc0d1e8e5c5e9363306365cf8f23c5052e231acdcd191ae052d5d7bfbe3d38fb8a0b62c1d79805b049a57b1862449a2862e1ae0080ddea40d9daff253a67651163fd0194b9d9b256760dfbae7402991a875256e6a302f0ee74bc904bb5012c64a17d8675dd72ca3c16dd094708c667d554149540e7b99126b617685d2541bc5e6b40cfdfcc5e016164fa6e7de8d3b7a5fe8658b3a0572ab4363d35d2f9966a5526f667a75779fedc9e24949ec81cb090e2d267ee9822232f9877726fed90d54ff874e2cbba8be281eaa9105e6aec0a930fae04488adf2127de8b69c11987871993cbe6b7bbdb65682e83a0843b85c97dcddced26374d29bd2b5d9034778b0e2e93c4f65a29d785245d37d85d7a7350a04482649b7a7f2000339b879d2bb33d6e19900ace7ba501e0fa457b305e20e6cf205073f6ca9fd7d355b2710e9e4493f50485c79ecb0a67854faee7a1f7481d322dc851f5ac32309165ef72a5b1ebd7f52c54572299ad4cc30cfe1e1243e6bc25a0d023752428c719c56a1730d16c62b3abb70ee3c49957b34c5af98300db6f72de3ee638a566e5e85916091571615123015d468a7f2467108464761489504e9e7bf6a440d578cc2d4dad85ebf7d17557ddfd27aa59e11061244a4b184905cfcba58b1a703da6427e6632fdeac9f59e3ac5b16eca2e0fd007183925ee2c46a8365c21daf8176595bc4365d623feaabc53dbcfbfee5c530403f4f84af4749123c1eedcfd99fd4ae65a3db88c97063a068266fb40ff582666334296cdb5c3cd58fd1ec61dd08f024b9d25552d9eb6ffbd3cbe49b061dc962596b89e8771d42505b8466c8a5358228bb96236a736689c0d3f10b422faeda07dd2f99013fc19d462d6726ff58260c8ab1fbaeac46dadf54b5e08162e1</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-xray">
      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">请输入访问密码查看非公开内容</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>Working Logs</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第二章-数据的表示和运算</title>
    <url>/2021/10/23/ComputerOrganization-2/</url>
    <content><![CDATA[<h2 id="数制与编码">数制与编码</h2>
<h3 id="进位计数制和数据间转换">进位计数制和数据间转换</h3>
<p>计算机内部用二进制编码信息的原因</p>
<ul>
<li>成本方面：二进制两种状态，用有两个稳定状态的物理器件表示，制造成本低。</li>
<li>功能方面：二进制的两种状态，对应逻辑值“真”和“假”，方便计算机实现逻辑运算、进行逻辑判断</li>
<li>实现方面：二进制编码和运算简单，通过逻辑门电路很容易实现</li>
</ul>
<p>进位计数值</p>
<ul>
<li>常用的有十进制、二进制、八进制、十六进制等</li>
<li>基数：进位计数法中每个数位用到的数码个数，每满基数则向高位进位</li>
<li>r进制数(<span class="math inline">\(K_nK_{n-1}\cdots K_0K_{-1}\cdots
K_{-m}\)</span>)可以表示为<span class="math inline">\(K_nr^n+K_{n-1}r^{n-1}+\cdots+K_0r_0+\cdots+K_{-m}r^{-m}\)</span>，其中<span class="math inline">\(K_i\)</span>是数码，<span class="math inline">\(r\)</span>是基数，<span class="math inline">\(r^i\)</span>是位权</li>
<li>十六进制的基数16，每一位可以取0-9，A-F（代表10-15）中的任意一个，4位二进制数码对应1位十六进制数码</li>
</ul>
<p>不同进制数的互相转换</p>
<ul>
<li>二进制数转八进制（十六进制）：从小数点起，分别向左向右，每3位（4位）一组，高位或低位不足可补0</li>
<li>八进制（十六进制）转二进制数：每位展开成3位（4位）二进制串即可，展开后必要时去掉高位和低位的0</li>
<li>任意进制转十进制：各个位数码和该位权值的乘积和，即按权展开法</li>
<li>十进制转任意进制数：对整数部分除基数取余（相当于对应进制的整数右移溢出最后一位）；对小数部分乘以基数取整（相当于对应进制的小数左移，溢出第一位）</li>
<li>不是每个十进制小数都能转换成准确的二进制；每个二进制小数都可以转换成准确的十进制</li>
</ul>
<h3 id="定点数的编码表示">定点数的编码表示</h3>
<p>从下面<strong>数的划分</strong>中清晰的展现了知识脉络</p>
<ul>
<li>真值：用户使用的进位计数值编码的各种进制数</li>
<li>机器数：计算机内部使用的数值数据，根据小数点位置是否固定分为
<ul>
<li>定点数
<ul>
<li>无符号：直接用真值的二进制形式表示的数</li>
<li>有符号
<ul>
<li>通常用二进制最高位作为符号位，放在数字前面（原码表示）</li>
<li>具体的编码方式有原码、补码、反码、移码</li>
<li>每种编码方式都分为定点纯整数和定点纯小数的编码</li>
</ul></li>
</ul></li>
<li>浮点数：一定有符号</li>
</ul></li>
</ul>
<p>原码、补码、反码、移码详细定义 + 原码 *
纯整数：最高位是符号位，0为正，1为负，其余位为绝对值 *
纯小数：最高位即小数点左1位是符号位，其余位为绝对值 + 补码 *
纯整数：正数表示同原码，负数表示为其绝对值原码的取反加1。补码的符号位可以看作位权是<span class="math inline">\(-2^n\)</span>，这里n表示非符号的数字位数 *
纯小数：正数表示同原码，负数表示为其绝对值原码的取反加1（加到最右边的小数位）
+ 反码 * 纯整数：正数表示同原码，负数表示位其绝对值原码的取反 *
纯小数：正数表示同原码，负数表示位其绝对值原码的取反 + 移码 *
n位移码是在真值上加一个偏置<span class="math inline">\(2^{n-1}\)</span>
* 0的移码是<span class="math inline">\(100\cdots\)</span>，共<span class="math inline">\(n-1\)</span>个<span class="math inline">\(0\)</span> * 真值的移码和补码仅符号位不同</p>
<h2 id="运算方法和运算电路">运算方法和运算电路</h2>
<h3 id="运算器">运算器</h3>
<ul>
<li>运算器组成
<ul>
<li>ALU：核心部件，完成各种算术和逻辑运算</li>
<li>ACC：常用部件，可以提供源操作数，同时作为运算结果的目的操作数存放地</li>
<li>PSW：重要部件，存放状态标志位，包括
<ul>
<li>CF：进位或借位标志，无符号数运算是否超过范围</li>
<li>OF：溢出标志，带符号数运算是否超过范围</li>
<li>SF：符号标志，负为1，非负为0</li>
<li>ZF：零标志，运算结果是否为零</li>
<li>PF：奇偶标志，运算结果低8位中1的个数是否位偶数，是则1，否则0</li>
</ul></li>
<li>通用寄存器组：必要部件，用户编程可用，暂存参与运算的操作数和结果，存取快，数量少</li>
<li>专用/特殊寄存器组：用户编程不可使用，运算器内部寄存器</li>
</ul></li>
<li>运算器结构
<ul>
<li>单总线结构：1条总线，3个周期（存源操作数1、存源操作数2、存计算结果），操作慢，电路简单</li>
<li>双总线结构：2条总线，2个周期（存源操作数1和源操作数2、存计算结果），操作较快，电路较复杂</li>
<li>三总线结构：3条总线，1个周期（存源操作数1和源操作数2并计算结果），操作快，电路复杂</li>
</ul></li>
</ul>
<h3 id="基本运算部件">基本运算部件</h3>
<h4 id="加法器">加法器</h4>
<p>不带标志位的加法器，只能无符号数使用</p>
<ul>
<li>一位全加器
<ul>
<li>输入<span class="math inline">\(A_i,B_i,C_{i-1}\)</span>，输出<span class="math inline">\(S_i,C_{i}\)</span></li>
<li><span class="math inline">\(S_i=A_i\oplus B_i \oplus
C_{i-1}\)</span></li>
<li><span class="math inline">\(C_i=A_iB_i+(A_i\oplus
B_i)C_{i-1}\)</span></li>
</ul></li>
<li>串行加法器
<ul>
<li>只有一个全加器，数据逐行串行送入加法器</li>
<li>n位操作数要进行n次操作，每次产生1位和</li>
<li>成本低，运算慢</li>
</ul></li>
<li>并行加法器
<ul>
<li>由多个加法器组成，位数和机器字长相同，并行运算</li>
<li>运算时间主要是由进位的传递时间决定，加法器本身是次要因素</li>
<li><span class="math inline">\(C_i=A_iB_i+(A_i\oplus
B_i)C_{i-1}\)</span></li>
<li>记<span class="math inline">\(G_i=A_iB_i\)</span>为进位产生函数</li>
<li>记<span class="math inline">\(P_i=(A_i\oplus
B_i)\)</span>为进位传递函数</li>
<li>串行进位（波进位）：n个全加器串接，低位进位产生时间影响高位运算，位数越多延迟越多</li>
<li>并行进位（先行进位）：把高位进位在表达式上转化成最低位进位
<ul>
<li><span class="math inline">\(C_1=G_1+P_1C_0\)</span></li>
<li><span class="math inline">\(C_2=G_2+P_2C_1=G_2+P_2G_1+P_2P_1C_0\)</span></li>
<li>以此类推</li>
<li>这种进位和字长无关，是快速的</li>
<li>但位数太多时电路非常复杂</li>
</ul></li>
<li>分组并行进位：把n位全加器分成若干组，组内并行进位，组间串或并行进位
<ul>
<li>单级先行进位：组内并行（例如4位先行进位电路CLA），组间串行</li>
<li>多级先行进位：组内并行（例如组内修改成4位成组先行进位电路BCLA），组间并行（CLA）</li>
</ul></li>
</ul></li>
</ul>
<h4 id="算术逻辑部件">算术逻辑部件</h4>
<ul>
<li>带标志加法器
<ul>
<li>溢出标志<span class="math inline">\(OF=C_n\oplus
C_{n-1}\)</span>，标志供有符号数使用</li>
<li>符号标志<span class="math inline">\(SF\)</span>：和的符号</li>
<li>零标志<span class="math inline">\(ZF\)</span>：和为0</li>
<li>进位/借位标志<span class="math inline">\(CF=C_{out}\oplus
C_{in}\)</span>，前者即<span class="math inline">\(C_n\)</span>，后者加法为0，减法为1，标志供无符号数使用</li>
</ul></li>
<li>算术逻辑单元ALU
<ul>
<li>能实现多种算术运算和逻辑运算</li>
<li>核心是带标志加法器</li>
<li>输入包括
<ul>
<li><span class="math inline">\(A、B\)</span>两个n位操作数，</li>
<li><span class="math inline">\(C_{in}\)</span>进位输入</li>
<li>ALUop操作控制输入</li>
</ul></li>
<li>输出包括
<ul>
<li><span class="math inline">\(C_{out}\)</span>进位输出</li>
<li><span class="math inline">\(F\)</span>输出</li>
<li>各种标志位</li>
</ul></li>
</ul></li>
</ul>
<h3 id="加减运算">加减运算</h3>
<p>补码加减运算器可以实现无符号数和带符号数的加减操作，原理如下</p>
<ul>
<li>减法看作是加上相反数（以补码的规则<strong>按位取反加1</strong>）</li>
<li>在加法器基础上，增加一个2选1多路选择器，根据<span class="math inline">\(sub\)</span>控制信号来选择加还是减
<ul>
<li>如果选加则直接输入，如果选减，则减数<strong>按位取反</strong></li>
</ul></li>
<li><span class="math inline">\(sub\)</span>控制信号作为<span class="math inline">\(C_{in}\)</span>输入加法器，<strong>表示减数加1</strong></li>
<li>ZF零标志对于有符号无符号数都有意义</li>
<li>CF进/借位标志，等于<span class="math inline">\(sub\oplus
C_{out}\)</span>，无符号数使用</li>
<li>OF溢出标志，有符号数使用，判定方法有
<ul>
<li>单符号判定法：输入两个正数输出负数，或输入两个负数输出正数</li>
<li>双符号判定法：两个符号位不一致则溢出，较高位为实际符号</li>
<li>进位判定法：符号位进位和最高数位进位相同则没有溢出（异或运算）</li>
</ul></li>
</ul>
<h3 id="乘除运算">乘除运算</h3>
<h4 id="乘除运算基本原理">乘除运算基本原理</h4>
<ul>
<li>原码1位乘法
<ul>
<li>原理：符号位单独运算，数值部分进行类似于笔算的步骤，从被乘数的低位开始，反复做加法和右移</li>
<li>算法：设<span class="math inline">\([X]_原=x_s.x_1x_2\cdots
x_n,[Y]_原=y_s.y_1y_2\cdots y_n\)</span>
<ul>
<li>符号位为<span class="math inline">\(x_s\oplus
y_s\)</span>，数值取绝对值进行计算</li>
<li>部分积取双符号位，初值为0</li>
<li>从乘数最低位<span class="math inline">\(y_n\)</span>开始判断：为1则部分积加<span class="math inline">\(|X|\)</span>，为0则部分积加0。</li>
<li>部分积右移1位</li>
<li>重复n次判断</li>
</ul></li>
<li>分析：累加n次，移位n次</li>
</ul></li>
<li>补码1位乘法（Booth算法）
<ul>
<li>原理：
<ul>
<li>符号位参与运算</li>
<li><span class="math inline">\([X\cdot Y]_补=[X]_补\cdot
[0.y_1y_2\cdots y_n]-[X]_补\cdot y_s\)</span></li>
<li>即<span class="math inline">\([X\cdot
Y]_补=[X]_补\cdot[(y_1-y_s)+(y_2-y_1)\cdot2^{-1}+\cdots+(y_{n+1}-y_n)\cdot2^{-n}]\)</span></li>
</ul></li>
<li>算法：设<span class="math inline">\([X]_补=x_s.x_1x_2\cdots
x_n,[Y]_补=y_s.y_1y_2\cdots y_n\)</span>
<ul>
<li>符号位参与运算，数取补码表示</li>
<li>部分积取双符号位，初值为0</li>
<li>从乘数最低位的差值<span class="math inline">\(y_{n+1}-y_n\)</span>开始判断（这里<span class="math inline">\(y_{n+1}\)</span>是最低非0位后面的第一个0）：为1则加<span class="math inline">\([X]_补\)</span>，为0则加0，为-1则加<span class="math inline">\([-X]_补\)</span></li>
<li>部分积右移1位</li>
<li>重复n次判断（判断至<span class="math inline">\(y_2-y_1\)</span>）</li>
<li>判断最后一次<span class="math inline">\(y_1-y_s\)</span>，为1则加<span class="math inline">\([X]_补\)</span>，为0则加0，为-1则加<span class="math inline">\([-X]_补\)</span></li>
</ul></li>
<li>分析：累加n+1次，移位n次（因为最后一次不需要移位）</li>
</ul></li>
<li>原码除法（恢复余数法）
<ul>
<li>原理：
<ul>
<li>符号位单独运算</li>
<li>数值部分进行类似于笔算的步骤，只考虑被除数和除数都非0的情况，从被除数的高位开始，反复做减法和左移，注意余数不够减时需要恢复到减之前的余数</li>
</ul></li>
<li>算法：设<span class="math inline">\([X]_原=x_s.x_1x_2\cdots
x_n,[Y]_原=y_s.y_1y_2\cdots y_n\)</span>
<ul>
<li>符号位为<span class="math inline">\(x_s\oplus
y_s\)</span>，数值取绝对值进行计算</li>
<li>先用被除数减除数，得到余数</li>
<li>余数为正，上商“1”，左移余数后减除数（即<span class="math inline">\(R&gt;0\Rightarrow R=2R-|Y|\)</span>）</li>
<li>余数为负，上商“0”，先恢复到减之前的余数，再左移余数后减除数（即<span class="math inline">\(R&lt;0\Rightarrow R=2(R+|Y|)-|Y|\)</span>）。</li>
<li>商的小数点后面需要上n个数，若末位上1，即余数为正则算法结束；若末位上0，即余数为负，需要恢复到减之前的余数，即余数加上<span class="math inline">\(|Y|\)</span></li>
</ul></li>
<li>分析：n+1次减法，每次减法都有可能需要恢复余数（0到n+1次加法），n次移位</li>
</ul></li>
<li>原码除法（不恢复余数法/加减交替法）
<ul>
<li>原理：
<ul>
<li>符号位单独运算</li>
<li>数值部分计算几乎和恢复余数法相同，只是对余数恢复步骤进行了优化</li>
</ul></li>
<li>算法：设<span class="math inline">\([X]_原=x_s.x_1x_2\cdots
x_n,[Y]_原=y_s.y_1y_2\cdots y_n\)</span>
<ul>
<li>符号位为<span class="math inline">\(x_s\oplus
y_s\)</span>，数值取绝对值进行计算</li>
<li>先用被除数减除数，得到余数</li>
<li>余数为正，上商“1”，左移余数后减除数（即<span class="math inline">\(R&gt;0\Rightarrow R=2R-|Y|\)</span>）</li>
<li>余数为负，上商“0”，左移余数后加除数（即<span class="math inline">\(R&lt;0\Rightarrow R=2R+|Y|\)</span>）。</li>
<li>商的小数点后面需要上n个数，若末位上1，即余数为正则算法结束；若末位上0，即余数为负，需要恢复到减之前的余数，即余数加上<span class="math inline">\(|Y|\)</span></li>
</ul></li>
<li>分析：n+1次减法，最后一次减法后可能需要恢复余数（0或1次加法），n次移位</li>
</ul></li>
<li>补码除法（加减交替法）
<ul>
<li>原理：
<ul>
<li>符号位参与运算</li>
<li>被除数和除数都用补码表示，商和余数也用补码表示</li>
<li>商用单符号，被除数、除数、余数都用双符号表示</li>
</ul></li>
<li>算法：设<span class="math inline">\([X]_补=x_s.x_1x_2\cdots
x_n,[Y]_补=y_s.y_1y_2\cdots y_n\)</span>
<ul>
<li>被除数和除数，如果同号则被除数减除数；如果异号则被除数加除数</li>
<li>余数和除数，同号则商上“1”，余数左移1位再减除数；异号则商上“0”，余数左移1位再加除数</li>
<li>重复上一步n次，再把末位置1</li>
</ul></li>
<li>分析：n+1次减法，n次移位，商末位恒设置为1</li>
</ul></li>
</ul>
<p>注： +
从原理上，乘法把两个n位数变为2n位；除法用2n位数除以n位数得到n位数 +
前面的原理总结是关于纯小数的乘法和除法，而整数的乘法除法基本差不多步骤，需要注意的是被除数高位或低位补0使得变为2n位
+
记忆：乘法右移n次，除法左移n次，原码乘法加n次，补码乘法加n+1次（符号位参与运算，相邻位作差），原码恢复余数除法减2n+1到4n+2次，原码不恢复余数法减2n+1到2n+2次，补码加减交替除法减2n+1次（符号参与运算，同号上1减，异号上0加）</p>
<h4 id="乘法电路和除法电路基本结构">乘法电路和除法电路基本结构</h4>
<p>32位无符号乘法运算电路基本结构 <img src="/2021/10/23/ComputerOrganization-2/unsign_mul.png" class title="this is unsign multiply circuit"></p>
<p>32位补码一位乘法运算电路基本结构（对应Booth算法） <img src="/2021/10/23/ComputerOrganization-2/complement_mul.png" class title="this is complement multiply circuit"></p>
<p>32位除法运算电路基本结构（对应原码的不恢复余数法/补码加减交替法）
<img src="/2021/10/23/ComputerOrganization-2/div.png" class title="this is div circuit">
可以看出，如果该图的控制逻辑中考虑除数的符号，则对应补码的加减交替法</p>
<h3 id="移位运算">移位运算</h3>
<ul>
<li>逻辑移位
<ul>
<li>操作数视为无符号数</li>
<li>不丢失有效数值位的情况下，左移等价于乘以2，右移等价于除以2</li>
<li>空位补0</li>
</ul></li>
<li>算术移位
<ul>
<li>操作数视为有符号数</li>
<li>不丢失有效数值位的情况下，左移等价于乘以2，右移等价于除以2</li>
<li>由上一条易知，负数补码右移时空位补1，负数反码左移右移空位都补1，其他情况空位补0</li>
</ul></li>
<li>循环移位
<ul>
<li>小循环左移：不带CF的循环左移，CF不参与循环，CF=MSB，LSB=MSB</li>
<li>小循环右移：不带CF的循环右移，CF不参与循环，CF=LSB，MSB=LSB</li>
<li>大循环左移：带CF的循环左移，CF参与循环，CF=MSB，LSB=CF</li>
<li>大循环右移：带CF的循环右移，CF参与循环，CF=LSB，MSB=CF</li>
</ul></li>
</ul>
<h2 id="整数的表示和运算">整数的表示和运算</h2>
<h3 id="无符号整数的表示和运算">无符号整数的表示和运算</h3>
<ul>
<li>直接表示为二进制串</li>
<li>无符号整数的加法、乘法、除法前面都提到过，基本和带符号正数的原码运算规则类似</li>
<li>无符号整数的移位对应逻辑移位</li>
</ul>
<h3 id="带符号整数的表示和运算">带符号整数的表示和运算</h3>
<ul>
<li>通常用补码表示</li>
<li>补码的加法、乘法、除法规则前面都提到过</li>
<li>带符号整数的移位相当于算术移位</li>
</ul>
<h3 id="整数的类型转换">整数的类型转换</h3>
<ul>
<li>带符号数和无符号数的转换：不改变机器码的二进制串，但是改变机器码的解释，因此真值改变</li>
<li>不同字长数的转换
<ul>
<li>大字节转小字节：直接截断</li>
<li>小字节转大字节：不改变机器码的解释，因此不希望真值改变，从而根据机器码类型补0或1</li>
</ul></li>
</ul>
<h2 id="浮点数的表示和运算">浮点数的表示和运算</h2>
<h3 id="浮点数的表示">浮点数的表示</h3>
<ul>
<li>浮点数表示为<span class="math inline">\(N=r^E\times
M\)</span>，其中底数r通常是2，E和M都是带符号定点数，前者是阶码，后者是尾数</li>
<li>阶码一般用移码或补码表示，尾数一般用原码或补码表示</li>
<li>规范化浮点数：尾数最高位是1</li>
<li>左规：尾数算术左移1位，阶码减1，可能需要多次</li>
<li>右规：运算溢出时（双符号位01或10），则尾数算术右移1位，阶码加1，只需要一次</li>
<li>浮点数范围：从小到大分别为，负上溢、负数范围、负下溢、0、正下溢、正数范围、正上溢</li>
<li>规格化后的运算结果超过浮点数范围则为溢出，浮点数下溢时计算机通常当0处理</li>
<li><strong>IEEE754标准</strong>
<ul>
<li>单精度浮点数float（1位符号S、8位阶码E、23位尾数M、共32位）表示为<span class="math inline">\((-1)^s\times 1.M\times
2^{E-127}\)</span>，符号S取0或1，阶码E取1-254</li>
<li>双精度浮点数double（1位符号S，11位阶码E，52位尾数M，共64位）表示为<span class="math inline">\((-1)^s\times 1.M\times
2^{E-1023}\)</span>，符号S取0或1，阶码E取1-2046</li>
<li>阶码的移码偏置是127/1023，因为可以空出全1表示无穷大</li>
<li>尾数含有隐藏的1在小数点前面，尾数只保存小数点后面的值</li>
<li>0用全0表示，根据符号位可以分为+0和-0</li>
<li>无法规范化的数称为非规范化数，即阶码全0。此时偏置为126或1022，即阶码0和1对应值相等，同时非规范化数的尾数不包含隐藏的1，这样设置阶码和尾数的目的是为了平滑的从规范化数过渡到非规范化数</li>
<li>非规范化数提供了一种表示0的方式，但0不是非规范化数，最小的非规范化数是非0的</li>
<li>阶码全1，尾数全0，表示无穷大，根据符号位分为正无穷负无穷</li>
<li>阶码全1，尾数非全0，表示NaN（Not a
Number），即用于无意义的数或在初始化时使用。</li>
</ul></li>
<li>同样数值位长度的浮点数和定点数相比，表示范围增大，但精度降低</li>
</ul>
<h3 id="浮点数加减运算">浮点数加减运算</h3>
<ul>
<li>对阶：小阶向大阶对齐，即阶码小的尾数（算术）右移阶加1，直到两个数阶码相等。右移时舍掉有效位会影响精度。计算时可以先算阶码的差<span class="math inline">\(\Delta E\)</span></li>
<li>尾数求和：对阶后的尾数按定点数补码加减运算处理，带上双符号位，减法等于加补码对应的负数</li>
<li>规格化:左规或右规至补码最高数值位和符号位不同</li>
<li>舍入：右规造成的低位丢失，可以0舍1入，也可以末尾恒置1。前者的“1入”情况如果造成上溢，需要再右规一次，后者根据末尾原先的情况，可能造成结果变大或变小</li>
<li>溢出判断和处理：规格化尾数后，根据阶码是否超过范围来判断溢出情况，即补码表示的双符号位不一致（10下溢，01上溢）。</li>
</ul>
<h3 id="浮点数类型转换">浮点数类型转换</h3>
<ul>
<li>int转float，不会溢出；可能有数据舍入从而丢失精度</li>
<li>int或float转double，不会溢出；且保持精度</li>
<li>double转float，可能溢出；可能有数据舍入从而丢失精度</li>
<li>double或float转int，可能溢出；可能有数据截断从而丢失精度</li>
<li>以上类型转换尽量保持真值不变，但由于编码方式不同，因此存储的二进制串会有改变</li>
<li>溢出主要看编码的表示范围</li>
<li>精度主要看编码的有效位数和表示范围的相对关系
<ul>
<li>同样的有效位数，表示范围约大，精度越低，比如float和int都是32个有效位，float范围大，精度低</li>
<li>同样的表示范围，编码有效位数越多，精度越高</li>
<li>注意到double相比float和int，即使表示范围更大，但因为有效位数更大，精度更大</li>
</ul></li>
</ul>
<h2 id="数据的存储和排列">数据的存储和排列</h2>
<h3 id="大端方式和小端方式">大端方式和小端方式</h3>
<ul>
<li>用最低有效字节LSB和最高有效字节MSB表示数的最高位和最低位</li>
<li>大端方式：按MSB到LSB的顺序存储数据</li>
<li>小端方式：按LSB到MSB的顺序存储数据</li>
<li>注意：一个地址内（一个字节）的数据无论按大端或小端存储，其机器级代码的文本形式中都是以实际值方式呈现</li>
</ul>
<h3 id="边界对齐">边界对齐</h3>
<ul>
<li>以<strong>32位存储字长的机器</strong>为例</li>
<li>字节：8位二进制长度，每个地址对应存储单元的大小</li>
<li>半字：半个存储字长，对应16位、2字节</li>
<li>字：存储字长，对应32位、4字节</li>
<li>边界对齐方式
<ul>
<li>半字地址一定是2的整数倍，字地址一定是4的整数倍</li>
<li>数据无论是字节、半字、字都可以一次取出</li>
<li>不满足上述条件可以通过填充0满足条件，浪费空间但提高取指令和取数的速度</li>
</ul></li>
<li>非边界对齐方式
<ul>
<li>充分利用存储空间</li>
<li>半字长和字长的数据可能在两个存储字中，需要两次访存，还要对高低字节进行位置调整和连接，影响指令执行效率</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第四章-指令系统</title>
    <url>/2021/10/29/ComputerOrganization-4/</url>
    <content><![CDATA[<h2 id="基本概念">基本概念</h2>
<ul>
<li>程序：由一系列有序的指令构成</li>
<li>指令：指示计算机硬件完成指定的基本操作的命令</li>
<li>指令系统
<ul>
<li>又叫指令集，是一台计算机所有指令的集合</li>
<li>位于软件硬件交界面上</li>
<li>计算机的主要属性，指出计算机有哪些基本的硬件功能</li>
</ul></li>
<li>指令系统应具备的特征
<ul>
<li>完备性：功能齐全</li>
<li>高效性：编写的程序占据空间小，执行速度快</li>
<li>规整性
<ul>
<li>对称性：所有寄存器和存储单元可同等对待；所有指令可使用各种寻址方式</li>
<li>匀齐性：可以支持各自数据类型</li>
<li>一致性：指令格式和数据格式一致</li>
</ul></li>
<li>兼容性：系列机各种机型有相同的基本机构和共同的基本指令集</li>
</ul></li>
</ul>
<h2 id="指令格式">指令格式</h2>
<h3 id="基本格式">基本格式</h3>
<ul>
<li>操作码+地址码</li>
<li>操作码指出操作的类型</li>
<li>地址码给出被操作的信息的地址</li>
<li>指令长度指的是一条指令的二进制代码长度
<ul>
<li>取决于操作码长度、地址码长度、地址码个数</li>
<li>可能大于、等于或小于机器字长，如双字长指令、字长指令、半字长指令</li>
<li>指令系统的所有指令长度相等，称为<strong>定长指令字结构</strong>，执行快，结构简单</li>
<li>指令系统的指令长度随指令而异，称为<strong>变长指令字结构</strong>，一般是字节的整数倍（考虑主存按字节编址）</li>
</ul></li>
<li>根据操作数地址码的个数，指令分为
<ul>
<li>零地址指令
<ul>
<li>不需要操作数的指令。如空指令、停机指令、关中断指令</li>
<li>涉及堆栈的运算指令。</li>
</ul></li>
<li>一地址指令：
<ul>
<li>单操作数指令。如自增、自减、求反、求补，形式为<span class="math inline">\(OP(A_1)\rightarrow A_1\)</span></li>
<li>隐含的双操作数指令。一般另一个操作数由ACC（累加器）提供，运算结果也存到ACC中，形式为<span class="math inline">\((ACC)\ OP\ (A_1)\rightarrow ACC\)</span></li>
</ul></li>
<li>二地址指令：比如常用的逻辑运算，算术运算，形式为<span class="math inline">\((A_1)\ OP\ (A_2)\rightarrow A_1\)</span></li>
<li>三地址指令：比如常用的逻辑运算，算术运算，形式为<span class="math inline">\((A_1)\ OP\ (A_2)\rightarrow A_3\)</span></li>
<li>四地址指令：形式为<span class="math inline">\((A_1)\ OP\
(A_2)\rightarrow A_3\)</span>，<span class="math inline">\(A_4\)</span>是下一条指令的地址</li>
</ul></li>
</ul>
<h3 id="定长操作码指令格式">定长操作码指令格式</h3>
<ul>
<li>在指令高位分配固定长度的若干位表示操作码</li>
<li><span class="math inline">\(n\)</span>位操作码字段可以表示<span class="math inline">\(2^n\)</span>个指令</li>
<li>定长操作码简化计算机硬件设计，提高指令译码识别速度，当计算机字节为32位和更长时，这是常规用法</li>
</ul>
<h3 id="拓展操作码指令格式">拓展操作码指令格式</h3>
<ul>
<li>当指令字长有限时，为了丰富指令种类，可以采用可变长度操作码</li>
<li>拓展操作码是最常用的可变长操作码，操作码长度根据地址码的减少而增加
<ul>
<li>一般全1留作拓展操作码使用</li>
<li>比如0000 - 1110是4位操作码；11110000 -
11111110是8位操作码；111111110000 - 111111111110是12位操作码</li>
</ul></li>
<li>除了拓展操作码，还有其他的拓展方法，比如哈夫曼编码的思想，给高频指令短的操作码</li>
<li>拓展编码必须是前缀码，即不存在短码是长码的前缀，且各指令操作码不重复</li>
</ul>
<h3 id="指令的操作类型">指令的操作类型</h3>
<ul>
<li>数据传送
<ul>
<li>寄存器之间的传送 MOV</li>
<li>从内存读数据到CPU寄存器 LOAD</li>
<li>从CPU寄存器写数据到内存 STORE</li>
</ul></li>
<li>算术和逻辑运算
<ul>
<li>算术运算：ADD（加）、SUB（减）、CMP（比较）、MUL（乘）、DIV（除）、INC（自增1）、DEC（自减1）</li>
<li>逻辑运算：AND（与）、OR（或）、NOT（非）、XOR（异或）</li>
</ul></li>
<li>移位操作
<ul>
<li>算术移位</li>
<li>逻辑移位</li>
<li>循环移位</li>
</ul></li>
<li>转移操作
<ul>
<li>无条件转移 JMP：任意条件都会转移</li>
<li>条件转移 BRANCH：满足条件才会转移</li>
<li>调用
CALL：调用指令需要保存下一条指令的地址，方便调用结束后返回。</li>
<li>返回 RET：完成调用后根据之前保存的地址返回</li>
<li>陷阱 TRAP</li>
</ul></li>
<li>输入输出操作：用于CPU和外部设备交换数据、传送控制命令和状态信息</li>
</ul>
<h2 id="寻址方式">寻址方式</h2>
<h3 id="有效地址的概念">有效地址的概念</h3>
<ul>
<li>指令中的地址码字段并不代表操作数真实地址，而是形式地址</li>
<li>形式地址需要结合寻址方式，算出操作数在存储器中的真实地址，即有效地址EA
<ul>
<li>若考虑虚拟存储机制，有效地址本质上是段内偏移量，即线性地址等于段基地址加有效地址。</li>
<li>本章内容除非特殊说明，默认先不考虑虚拟存储，即段基地址从0开始，且不采用分页机制，此时有效地址就是真实的物理地址</li>
</ul></li>
</ul>
<h3 id="指令寻址和数据寻址">指令寻址和数据寻址</h3>
<ul>
<li>指令寻址
<ul>
<li>含义：寻找下一条需要执行的指令地址</li>
<li>分为
<ul>
<li>顺序寻址：程序计数器PC加1</li>
<li>跳跃寻址：通过本条转移指令算出下一条指令地址，可能跳跃到绝对地址（根据标记符），也可能跳跃到相对地址（距当前的指令偏移量），算出后修改程序计数器PC</li>
</ul></li>
</ul></li>
<li>数据寻址
<ul>
<li>含义：根据指令中操作数的形式地址得到其有效地址</li>
<li>数据寻址方式很多，通常在指令中设置一个字段（即寻址特征），用以指明寻址方式的类型</li>
<li>指令的格式为：操作码、寻址特征、形式地址A</li>
</ul></li>
</ul>
<h3 id="常见寻址方式">常见寻址方式</h3>
<ul>
<li>隐含寻址
<ul>
<li>不显式给出所有操作数地址，指令中隐含操作数的地址</li>
<li>比如累加器ACC作为第二个操作数的地址，结果也存放到ACC中</li>
<li>优点是缩短指令长度；缺点是需要增加存储隐含地址的硬件</li>
<li>访存0次</li>
</ul></li>
<li>立即（数）寻址
<ul>
<li>地址字段指出的是操作数本身，称为立即数</li>
<li>数据用补码形式存放</li>
<li>优点是不需要访问内存；缺点是立即数的位数收到指令长度限制</li>
<li>访存0次</li>
</ul></li>
<li>直接寻址
<ul>
<li>地址字段就是操作数的真实地址</li>
<li><span class="math inline">\(EA = A\)</span></li>
<li>优点是寻址简单，只需要访问一次内存；缺点是寻址范围受指令位数限制，地址也不容易修改</li>
<li>访存1次</li>
</ul></li>
<li>间接寻址
<ul>
<li>指令中给出操作数真实地址所存放位置的真实地址</li>
<li><span class="math inline">\(EA = (A)\)</span></li>
<li>间接寻址可以是一次，也可以是多次
<ul>
<li>如果内存寻址得到的内容第一位是1，表示多次间接寻址，需要继续寻址</li>
<li>如果内存寻址得到的内容第一位是0，表示得到的就是操作数的地址</li>
</ul></li>
<li>优点是扩大了寻址范围，EA位数大于A的位数；缺点是需要多次访存（至少2次）</li>
<li>这种寻址方式不常用，通常使用<strong>寄存器间接寻址</strong>扩大寻址范围</li>
<li>访存至少2次</li>
</ul></li>
<li>寄存器寻址
<ul>
<li>指令中给出操作数所在的寄存器编号</li>
<li><span class="math inline">\(EA = R_i\)</span></li>
<li>优点是不访问主存，且地址码很短（因为寄存器不多）；缺点是寄存器价格贵，个数有限</li>
<li>访存0次</li>
</ul></li>
<li>寄存器间接寻址
<ul>
<li>指令中给出操作数真实地址所存放的寄存器编号</li>
<li><span class="math inline">\(EA = (R_i)\)</span></li>
<li>特点是比<strong>间接寻址</strong>快，但仍需要访问主存</li>
<li>访存1次</li>
</ul></li>
<li>相对寻址
<ul>
<li>指令中给出的是偏移地址（可正可负），基地址在PC中</li>
<li><span class="math inline">\(EA = (PC)+A\)</span></li>
<li>操作数地址不是固定的，广泛应用于转移指令</li>
<li>注意
<ul>
<li>转移指令取出后，PC会立刻更新到下一行指令的位置，此后再计算相对偏移量。</li>
<li>比如转移指令2个字节，转移指令地址为X，则执行完后，<span class="math inline">\(PC=X+2+A\)</span></li>
</ul></li>
<li>访存1次</li>
</ul></li>
<li>基址寻址
<ul>
<li>指令给出偏移地址，基地址在基址寄存器BR中</li>
<li><span class="math inline">\(EA =(BR) + A\)</span></li>
<li>面向操作系统的寻址方式，基址寄存器由操作系统管理，用户程序运行时通常BR不可变</li>
<li>该寻址方法扩大了寻址范围，用户不需要考虑编程的地址范围；缺点是偏移量的位数短</li>
<li>访存1次</li>
</ul></li>
<li>变址寻址
<ul>
<li>指令给出基地址，偏移地址在变址寄存器IX中</li>
<li><span class="math inline">\(EA =(IX) + A\)</span></li>
<li>面向用户的寻址方式，变址寄存器用户可以更改，指令中的A一般不变</li>
<li>该寻址方法扩大了寻址范围，常用于数组（A为数组地址，IX存放元素偏移量）、循环；缺点是偏移量的位数短</li>
<li>访存1次</li>
</ul></li>
<li>堆栈寻址
<ul>
<li>堆栈是存储器（或专用寄存器组）中特定的按后进先出原则管理的存储区</li>
<li>该存储的读写一般通过栈顶指针寄存器SP</li>
<li>分为
<ul>
<li>硬堆栈：寄存器堆栈，成本高，不适合大容量堆栈</li>
<li>软堆栈：主存中划分一块区域作为堆栈，划算且常用</li>
</ul></li>
<li>本寻址方式一般指令中都无操作数，操作数隐含在堆栈中，在读写堆栈的单元前后会相应对SP内容进行增减</li>
</ul></li>
</ul>
<h3 id="x86汇编指令入门">x86汇编指令入门</h3>
<h4 id="相关寄存器">相关寄存器</h4>
<ul>
<li>8个32位的通用寄存器，分别为
<ul>
<li>EAX 累加器（Accumulator）</li>
<li>EBX 基地址寄存器（Base Register）</li>
<li>ECX 计数寄存器（Count Register）</li>
<li>EDX 数据寄存器（Data Register）</li>
<li>ESI、EDI 变址寄存器（Index Register）</li>
<li>EBP 堆栈基指针（Base Pointer）</li>
<li>ESP 堆栈顶指针（Stack Pointer）</li>
</ul></li>
<li>功能上作为程序计数器PC的寄存器：IP或EIP，只能使用控制指令修改</li>
<li>字母表示可以大写也可以小写，第一个字母E表示Extended（拓展的）</li>
<li>为了兼容性，EAX、EBX、ECX、EDX的低两个字节可以单独使用，以EAX为例
<ul>
<li>EAX低2字节称为AX</li>
<li>AX的高字节和低字节分别称为AH和AL</li>
</ul></li>
<li>除了EBP和ESP，其他寄存器的使用实际上是任意的</li>
</ul>
<h4 id="寻址模式">寻址模式</h4>
<ul>
<li>如果是两个地址参数，第一个为目的地址，第二个为源地址</li>
<li>中括号<span class="math inline">\(\[\]\)</span>内是地址，整体表示取括号中地址对应的存储空间</li>
<li>计算地址最多只能用<strong>2个</strong>32位寄存器和<strong>1个</strong>32位有符号常数<strong>相加</strong></li>
</ul>
<h4 id="内存分配">内存分配</h4>
<ul>
<li>汇编语言中声明内存大小，显示的使用
<ul>
<li>DB：Data Byte，单字节</li>
<li>DW：Data Word，双字节</li>
<li>DD：Double Word，四字节</li>
</ul></li>
<li>对于常数的分配空间大小，可以使用标识符
<ul>
<li>BYTE PTR：常数以单字节形式</li>
<li>WORD PTR：常数以双字节形式</li>
<li>DWORD PTR：常数以四字节形式</li>
</ul></li>
<li>指令可以有后缀指明空间大小，以传送指令mov为例
<ul>
<li>movb：传送单字节</li>
<li>movw：传送双字节</li>
<li>movl：传送四字节</li>
<li>movq：传送八字节</li>
</ul></li>
</ul>
<h4 id="常用指令">常用指令</h4>
<ul>
<li>以&lt;reg&gt;、&lt;mem&gt;、&lt;con&gt;分别表示操作数为寄存器、内存、常数的情况。如果reg和con后带数字则表示指定了位数。</li>
<li>以&lt;label&gt;表示标签，放在指令的前面，表示指令的地址</li>
<li>数据传送指令
<ul>
<li>mov指令：将第二个操作数复制到第一个操作数。要求目的操作数不为常数，且不能从内存到内存
<ul>
<li>mov &lt;reg&gt;,&lt;reg&gt;</li>
<li>mov &lt;reg&gt;,&lt;mem&gt;</li>
<li>mov &lt;reg&gt;,&lt;con&gt;</li>
<li>mov &lt;mem&gt;,&lt;reg&gt;</li>
<li>mov &lt;mem&gt;,&lt;con&gt;</li>
</ul></li>
<li>push指令：ESP值减4后把操作数压入栈中，可以看出栈增长方向是从大地址到小地址
<ul>
<li>push &lt;reg32&gt;</li>
<li>push &lt;mem&gt;</li>
<li>push &lt;con32&gt;</li>
</ul></li>
<li>pop指令：把操作数弹出栈后ESP加4
<ul>
<li>pop &lt;reg32&gt;</li>
<li>pop &lt;mem&gt;</li>
</ul></li>
</ul></li>
<li>算术和逻辑计算指令
<ul>
<li>add/sub指令：第一个操作数加上/减去第二个操作数，结果保存在第一个操作数位置
<ul>
<li>add/sub &lt;reg&gt;,&lt;reg&gt;</li>
<li>add/sub &lt;reg&gt;,&lt;mem&gt;</li>
<li>add/sub &lt;reg&gt;,&lt;con&gt;</li>
<li>add/sub &lt;mem&gt;,&lt;reg&gt;</li>
<li>add/sub &lt;mem&gt;,&lt;con&gt;</li>
</ul></li>
<li>inc/dec指令：操作数自增1/自减1
<ul>
<li>inc/dec &lt;reg&gt;</li>
<li>inc/dec &lt;mem&gt;</li>
</ul></li>
<li>imul指令：带符号整数乘法指令。第一个（目的）操作数必须是寄存器；可以有一个或两个源操作数；一个源操作数时不使用常数，其与目的操作数的积放到目的操作数；两个源操作数时使用常数，把积放到目的操作数；如果溢出则OF=1
<ul>
<li>imul &lt;reg32&gt;,&lt;reg32&gt;</li>
<li>imul &lt;reg32&gt;,&lt;mem&gt;</li>
<li>imul &lt;reg32&gt;,&lt;reg32&gt;,&lt;con&gt;</li>
<li>imul &lt;reg32&gt;,&lt;mem&gt;,&lt;con&gt;</li>
</ul></li>
<li>idiv指令：带符号除法指令。一个操作数表示除数。被除数为EDX:EAX。结果商存入EAX，余数存入EDX。
<ul>
<li>idiv &lt;reg32&gt;</li>
<li>idiv &lt;mem&gt;</li>
</ul></li>
<li>and/or/xor指令：逻辑与/或/异或，结果放在第一个操作数
<ul>
<li>and/or/xor &lt;reg&gt;,&lt;reg&gt;</li>
<li>and/or/xor &lt;reg&gt;,&lt;mem&gt;</li>
<li>and/or/xor &lt;reg&gt;,&lt;con&gt;</li>
<li>and/or/xor &lt;mem&gt;,&lt;reg&gt;</li>
<li>and/or/xor &lt;mem&gt;,&lt;con&gt;</li>
</ul></li>
<li>not指令：取反（位翻转）指令
<ul>
<li>not &lt;reg&gt;</li>
<li>not &lt;mem&gt;</li>
</ul></li>
<li>neg指令：取负指令
<ul>
<li>neg &lt;reg&gt;</li>
<li>neg &lt;mem&gt;</li>
</ul></li>
<li>shl/shr指令：逻辑移位指令，结果存放在第一个操作数，第二个操作数为移位的位数
<ul>
<li>shl/shr &lt;reg&gt;,&lt;con8&gt;</li>
<li>shl/shr &lt;mem&gt;,&lt;con8&gt;</li>
<li>shl/shr &lt;reg&gt;,&lt;cl&gt;</li>
<li>shl/shr &lt;mem&gt;,&lt;cl&gt;</li>
</ul></li>
</ul></li>
<li>控制流指令
<ul>
<li>jmp指令：控制IP转移到label指示的地址执行
<ul>
<li>jmp &lt;label&gt;</li>
</ul></li>
<li>cmp指令：第一个操作数和第二个操作数比较，根据结果设置处理机状态字条件码
<ul>
<li>cmp &lt;reg&gt;,&lt;reg&gt;</li>
<li>cmp &lt;reg&gt;,&lt;mem&gt;</li>
<li>cmp &lt;reg&gt;,&lt;con&gt;</li>
<li>cmp &lt;mem&gt;,&lt;reg&gt;</li>
</ul></li>
<li>jcondition指令：根据处理机状态字进行条件转移
<ul>
<li>je &lt;label&gt; 等于时跳转</li>
<li>jne &lt;label&gt; 不等于时跳转</li>
<li>jz &lt;label&gt; 等于0时跳转</li>
<li>jg &lt;label&gt; 有符号大于时跳转</li>
<li>jge &lt;label&gt; 有符号大于等于时跳转</li>
<li>jl &lt;label&gt; 有符号小于时跳转</li>
<li>jle &lt;label&gt; 有符号小于等于时跳转</li>
<li>ja &lt;label&gt; 无符号大于时跳转</li>
<li>jae &lt;label&gt; 无符号大于等于时跳转</li>
<li>jb &lt;label&gt; 无符号小于时跳转</li>
<li>jbe &lt;label&gt; 无符号小于等于时跳转</li>
</ul></li>
<li>call/ret指令：用于函数的调用和返回。call把当前指令地址入栈后，无条件转移到标签处；ret从栈中弹出之前保存的地址，无条件转移回之前的地址位置
<ul>
<li>call &lt;label&gt;</li>
<li>ret</li>
</ul></li>
</ul></li>
</ul>
<h2 id="数据对齐和大小端存放">数据对齐和大小端存放</h2>
<p>详见第二章笔记中，“数据的存储和排列”小节</p>
<h2 id="cisc和risc的基本概念">CISC和RISC的基本概念</h2>
<ul>
<li>复杂指令系统计算机（CISC）
<ul>
<li>增强原有指令的功能，设置更复杂的新指令，使软件功能硬件化实现</li>
<li>比如X86架构计算机</li>
</ul></li>
<li>精简指令系统计算机（RISC）
<ul>
<li>减少指令的种类、简化指令的功能，使指令的速度提高</li>
<li>比如ARM、MIPS架构计算机</li>
</ul></li>
</ul>
<h3 id="复杂指令系统计算机">复杂指令系统计算机</h3>
<p>CISC的特点如下：</p>
<ul>
<li>指令系统：复杂庞大</li>
<li>指令数目：一般在200条以上</li>
<li>指令字长：不固定。指令格式多，寻址方式多</li>
<li>可访存的指令：不受限制</li>
<li>各指令使用频度：差别大，遵循28定律（20%的指令使用频率80%，80%的指令很少使用）</li>
<li>各指令执行时间：差别大，大部分需要多个时钟周期</li>
<li>CPU中通用寄存器数量：较少</li>
<li>控制器控制方式：大多数采用微程序控制。有些指令很复杂，无法用硬连线控制。</li>
<li>目标代码优化：难以用优化编译生成高效的目标代码程序</li>
<li>指令流水线技术：可以通过一定方式实现</li>
<li>软件兼容性：比较好，高档机可保护低档机全部指令并加以扩充</li>
</ul>
<h3 id="精简指令系统计算机">精简指令系统计算机</h3>
<p>RISC的特点如下：</p>
<ul>
<li>指令系统：选取使用频率高的简单指令，复杂的指令由简单指令组合实现</li>
<li>指令数目：一般在100条以下</li>
<li>指令字长：固定。指令格式少，寻址方式少</li>
<li>可访存的指令：只有LOAD/STORE（取数存数）允许访存。其余指令的操作在寄存器之间进行</li>
<li>各指令使用频度：都经常使用</li>
<li>各指令执行时间：大部分指令在一个时钟周期内完成</li>
<li>CPU中通用寄存器数量：非常多</li>
<li>控制器控制方式：以硬布线控制（组合逻辑控制）为主，基本不用微程序控制</li>
<li>目标代码优化：特别重视编译优化工作，以减少程序执行时间</li>
<li>指令流水线技术：一定采用</li>
<li>软件兼容性：大多数RISC不能和老机器兼容，但因为实用性强，是未来的发展方向</li>
</ul>
<h2 id="高级语言程序与机器代码之间的对应">高级语言程序与机器代码之间的对应</h2>
<h3 id="编译器汇编器和链接器的基本概念">编译器、汇编器和链接器的基本概念</h3>
<p>详见第一章笔记“高级语言程序与机器语言程序转换”小节</p>
<h3 id="过程函数调用的机器级表示">过程（函数）调用的机器级表示</h3>
<p>假设P调用Q，则步骤如下</p>
<ul>
<li>P保存现场：当需要保留<strong>调用者保存寄存器</strong>（包括EAX、ECX、EDX）的值，进行此步骤</li>
<li>P压参数：把调用参数按从右到左的顺序压入栈中（如果寄存器数量充足，也可能把部分参数用寄存器保存）</li>
<li>P执行CALL指令
<ul>
<li>存旧PC：把返回地址（调用指令后一条指令的位置）压栈</li>
<li>更新PC：修改PC至跳转处，此后Q过程开始执行</li>
</ul></li>
<li>Q准备阶段
<ul>
<li>存原栈底：将EBP（P的栈底）压栈（此时ESP为栈顶，所指位置存放P的栈底）</li>
<li>更新栈底：更新EBP为ESP位置（即Q的栈底中存放P的栈底）</li>
<li>更新栈顶：修改ESP，为自己分配栈空间（一般减去大小为16字节的倍数，以便对齐）</li>
<li>保存现场：如果需要用<strong>被调用者保存寄存器</strong>（包括EBX、ESI、EDI），进行此步骤</li>
</ul></li>
<li>Q过程体阶段
<ul>
<li>局部变量空间分配：一般按低地址到高地址的顺序使用栈空间（和栈增长方向相反）</li>
<li>通常按小端存放，考虑对齐</li>
<li>结束时设置返回值（通常是放到EAX寄存器中）</li>
</ul></li>
<li>Q结束阶段
<ul>
<li>Q恢复P的现场</li>
<li>Q执行leave指令
<ul>
<li>恢复栈顶：修改ESP等于EBP，以释放Q的栈空间</li>
<li>恢复栈底：弹出Q的EBP所指向P的EBP的值给EBP，即恢复P的栈空间</li>
</ul></li>
<li>Q执行ret指令
<ul>
<li>恢复PC：弹出此时ESP所指向的返回地址给PC，以返回P执行</li>
</ul></li>
</ul></li>
<li>P恢复现场</li>
<li>P继续执行CALL指令的下一条指令</li>
</ul>
<p><strong>注：关于一个过程P的栈帧</strong> +
P栈帧头：P过程EBP指向空间（存放P过程的调用者的旧EBP） +
P栈帧尾：下一个过程Q的EBP指向空间（存放的是P的EBP）的前一个空间（存放的是P的返回地址）
+ 栈帧是周期性的，P的栈帧尾后面就是Q的栈帧头</p>
<h3 id="选择结构语句的机器级表示">选择结构语句的机器级表示</h3>
<h4 id="条件码">条件码</h4>
<ul>
<li>即标志位寄存器，包括
<ul>
<li>CF 进位标志：用于无符号数</li>
<li>ZF 零标志：最近运算是否为0</li>
<li>SF 符号标志：最近运算结果的符号</li>
<li>OF 溢出标志：用于带符号数</li>
</ul></li>
<li>cmp和sub对条件码的行为一致</li>
<li>test和and对条件码行为一致</li>
<li>jcondition指令结合条件码的ZF和SF可以实现跳转</li>
</ul>
<h4 id="if语句">if语句</h4>
<ul>
<li>可以利用if-goto语句分析从高级语言到汇编的过程</li>
<li>如果if条件不满足，则goto跳转</li>
<li>然后把if-goto转换到对应的汇编中，使用cmp/test、jcondition
Label的方式</li>
</ul>
<h4 id="switch语句">switch语句</h4>
<ul>
<li>相比于if语句多次条件判断来跳转，switch是多路选择，一次直接跳到某个条件处的语句执行</li>
<li>需要用到跳转表
<ul>
<li>段属性为只读，即.section .rodata</li>
<li>跳转地址在4字节边界上，即align 4</li>
<li>跳转表的头设置一个标记Label，头之后的每一行（项）都是一个标签Labeli，i=0，1，...，7</li>
<li>给出一个例子
<ul>
<li>设switch输入10、12、14、15、17分别对应情况L2、L3、L4、L1、L3，其他输入对应情况L5</li>
<li>跳转表Label标签后面的每一行分别表示情况10、11、12、...、17需要跳到的标记Labeli，即L2、L5、L3、L5、L4、L1、L5、L3</li>
<li>汇编代码中，首先把判断的输入减10，记为t。</li>
<li>比较t和7的关系（条件码设置按无符号减法）。</li>
<li>如果大于7（根据无符号数运算，这里包括t是负数的情况），跳转到L5</li>
<li>否则根据t作为索引查跳转表对应表项标签Labelt，跳转到跳转表此项对应的标签位置执行即可</li>
</ul></li>
</ul></li>
</ul>
<h3 id="循环结构语句的机器级表示">循环结构语句的机器级表示</h3>
<ul>
<li>高级语言转汇编可以借助if-goto作为中间代码，方便分析转换</li>
<li>循环结构有三种情况
<ul>
<li>do-while循环：一次goto即可</li>
<li>while循环：相当于在do-while前先判断条件一次。需要两个goto</li>
<li>for循环：相当于while语句前先做一个初始化语句，可以先转成while循环。需要两个goto。</li>
</ul></li>
<li>最后把if-goto转换到对应的汇编中，使用cmp/test、jcondition
Label的方式</li>
</ul>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第五章-树</title>
    <url>/2021/10/18/DataStructure-5/</url>
    <content><![CDATA[<h2 id="树的基本概念">树的基本概念</h2>
<h3 id="树的定义">树的定义</h3>
<ul>
<li>树是n(<span class="math inline">\(n\geq
0\)</span>)个结点的有限集</li>
<li>n=0为空树</li>
<li>有且只有一个称为根的结点</li>
<li>n&gt;1时，其余结点可分为m(<span class="math inline">\(m&gt;0\)</span>)个互不相交的有限集<span class="math inline">\(T_1,\cdots,T_m\)</span>，每个集合也是树，称为根的子树。</li>
</ul>
<h3 id="树的特点">树的特点</h3>
<ul>
<li>根没有前驱，其他点有且只有一个前驱</li>
<li>所有点都可以有零或任意多个后继</li>
<li>n个点的树有n-1条边（数学归纳法易证）</li>
</ul>
<h3 id="基本术语">基本术语</h3>
<ul>
<li>祖先：根到结点a唯一路径上任意结点都是a的祖先</li>
<li>子孙：结点是其祖先的子孙</li>
<li>双亲：根到结点a唯一路径是最接近a的结点是a的双亲</li>
<li>孩子：结点是其双亲的孩子</li>
<li>兄弟：双亲相同的结点互为兄弟</li>
<li>树结点的度：孩子的个数（和图中度有区别）</li>
<li>树的度：树结点度的最大值</li>
<li>分支节点（非终端结点）：度大于零的点</li>
<li>叶子结点（终端结点）：度等于零的点</li>
<li>结点的层次：从根开始为第1层，逐层增加</li>
<li>堂兄弟：双亲在同一层</li>
<li>结点的深度：从根结点向下逐层累加</li>
<li>结点的高度：从叶结点向上逐层累加</li>
<li>树的高度（深度）：树中结点最大层数</li>
<li>有序树和无序树：有序树的结点从左到右是有次序的树，互换后变成不同的树。</li>
<li>路径和路径长度：两个结点的路径是由两个结点所经过结点序列构成的，路径长度是路径上边的个数（一般来说认为分支有向，路径只能是从上往下的）</li>
<li>树的路径长度:树根到每个结点路径长的总和</li>
<li>森林：m个（<span class="math inline">\(m\geq
0\)</span>）互不相交的树的集合</li>
</ul>
<h3 id="树的性质">树的性质</h3>
<ul>
<li><strong>结点数等于所有结点的度数和加1（即边数加1）</strong></li>
<li>度为<span class="math inline">\(m\)</span>的树的第<span class="math inline">\(i\)</span>层最多有<span class="math inline">\(m^{i-1}\)</span>个节点，(<span class="math inline">\(i\geq 1\)</span>)</li>
<li>高度为<span class="math inline">\(h\)</span>的<span class="math inline">\(m\)</span>叉树最多有(<span class="math inline">\(\frac{m^h-1}{m-1}\)</span>)个结点</li>
<li>具有n个结点的m叉树的最小高度是<span class="math inline">\(\lceil
log_m(n(m-1)+1) \rceil\)</span></li>
</ul>
<h2 id="二叉树">二叉树</h2>
<h3 id="二叉树的定义">二叉树的定义</h3>
<ul>
<li>或者为空树，n=0</li>
<li>或者由根结点和两个互不相交的左右子树组成，左右子树都是二叉树</li>
<li>注意，二叉树是有序树，左右子树顺序不能随意交换</li>
<li>与度为2的有序树的区别
<ul>
<li>二叉树可以为空</li>
<li>即使只有一个孩子，二叉树也要区分左右子树，而有序树这种情况不需要区分顺序</li>
</ul></li>
</ul>
<h3 id="几个特殊的二叉树">几个特殊的二叉树</h3>
<ul>
<li>满二叉树：每层含有做多的结点</li>
<li>完全二叉树：编号与满二叉树完全对应（约定编号从1开始）
<ul>
<li>重要特征：度为1的结点必然是只有左孩子</li>
<li>其他特征：只有左孩子的结点编号后的结点都是叶子结点</li>
</ul></li>
<li>二叉排序树：左子树关键字小于根关键字小于右子树关键字，左右子树也是二叉排序树</li>
<li>平衡二叉树：树上任一结点左右子树深度差不超过1</li>
</ul>
<h3 id="二叉树的性质">二叉树的性质</h3>
<ul>
<li>非空二叉树上的叶子结点数等于度为2的结点数加1</li>
<li>非空二叉树第k层至多有<span class="math inline">\(2^{k-1}\)</span>个结点</li>
<li>高度为h的二叉树最多有<span class="math inline">\(2^h-1\)</span>个结点</li>
<li>具有n个(<span class="math inline">\(n\geq
0\)</span>)结点的完全二叉树的高度为<span class="math inline">\(\lceil
log_2(n+1)\rceil\)</span>，(原理是<span class="math inline">\(2^{h-1}-1&lt;n\leq 2^h-1\)</span>)</li>
</ul>
<h3 id="二叉树的存储结构">二叉树的存储结构</h3>
<ul>
<li>顺序存储
<ul>
<li>利用数组，数组下标为i的位置存储编号为i+1的结点</li>
<li>适合满二叉树或完全二叉树</li>
<li>对于一般的二叉树需要添加树中并不存在的空结点，以反映二叉树结点的逻辑关系</li>
</ul></li>
<li>链式存储
<ul>
<li>解决了顺序存储中空间利用率低的问题</li>
<li>每个结点除了数据域，还有左右子树的指针域</li>
<li>n个结点的二叉链表中，有n-1个非空链域，2n个链域，n+1个空链域</li>
<li>后面提到的线索链表中将利用这些空链域</li>
</ul></li>
</ul>
<h3 id="树转换为二叉树">树转换为二叉树</h3>
<ul>
<li>结点的孩子放到左子树</li>
<li>结点的兄弟放到右子树</li>
</ul>
<h2 id="二叉树遍历和线索化二叉树">二叉树遍历和线索化二叉树</h2>
<h3 id="二叉树的遍历">二叉树的遍历</h3>
<ul>
<li>遍历：对二叉树的结点按某种顺序排队</li>
<li>先序遍历：先访问根，再访问左子树，再访问右子树，递归遍历</li>
<li>中序遍历：先访问左子树，再访问根，再访问右子树，递归遍历</li>
<li>后序遍历：先访问左子树，再访问右子树，再访问根，递归遍历</li>
</ul>
<h3 id="二叉树遍历的非递归算法栈实现">二叉树遍历的非递归算法（栈实现）</h3>
<ul>
<li>中序遍历
<ul>
<li>(1)：沿着根的左孩子，依次入栈，直到左孩子为空</li>
<li>(2)：栈顶元素出栈并访问，若该元素有右孩子，将右子树转(1)进行；否则继续执行(2)</li>
</ul></li>
<li>先序遍历
<ul>
<li>(1)：访问根，沿着根的左孩子，依次访问再入栈，直到左孩子为空</li>
<li>(2)：栈顶元素出栈，若该元素有右孩子，将右子树转(1)进行；否则继续执行(2)</li>
</ul></li>
<li>后序遍历（较复杂的一种情况）
<ul>
<li>(1)：沿着根的左孩子，依次入栈，直到左孩子为空</li>
<li>(2)：读栈顶元素，若该元素有<strong>未访问过的</strong>右孩子，将右子树转(1)进行；否则栈顶元素出栈并访问，再继续(2)</li>
<li>麻烦的地方是(2)中需要判断是从左子树返回的还是从右子树返回的，可以在结点中加一个标记，记录有无访问过。</li>
</ul></li>
</ul>
<h3 id="层次遍历">层次遍历</h3>
<ul>
<li><ol type="1">
<li>根进队列</li>
</ol></li>
<li><ol start="2" type="1">
<li>当队列不空，弹出结点，访问结点，结点如果有子结点，则从左到右依次进队列</li>
</ol></li>
<li><ol start="3" type="1">
<li>返回(2)继续判断</li>
</ol></li>
</ul>
<h3 id="由遍历序列构造二叉树">由遍历序列构造二叉树</h3>
<ul>
<li>先序序列和中序序列
<ul>
<li>先序序列第一个为根节点</li>
<li>该点把中序序列分成左子树中序序列和右子树中序序列两部分</li>
<li>根据两部分长度可以把先序序列分成左子树先序序列和右子树先序序列两部分</li>
<li>递归构造左右子树即可</li>
</ul></li>
<li>后序序列和中序序列
<ul>
<li>后序序列最后一个为根节点</li>
<li>该点把中序序列分成左子树中序序列和右子树中序序列两部分</li>
<li>根据两部分长度可以把后序序列分成左子树后序序列和右子树后序序列两部分</li>
<li>递归构造左右子树即可</li>
</ul></li>
<li>层序序列和中序序列
<ul>
<li>层序序列第一个为根节点</li>
<li>该点把中序序列分成左子树中序序列和右子树中序序列两部分</li>
<li>两层遍历，把层序序列剩余点分成左子树层序序列和右子树层序序列（看层序序列点在中序序列左子树部分还是右子树部分）</li>
<li>递归构造左右子树即可</li>
</ul></li>
<li>先序序列和后序序列：二叉树不唯一
<ul>
<li>但是如果先序序列有XY，后序序列有YX，说明X是Y的祖先</li>
</ul></li>
</ul>
<h3 id="线索化二叉树">线索化二叉树</h3>
<h4 id="基本概念">基本概念</h4>
<ul>
<li>利用二叉树n+1个空指针域存放遍历的前驱后继信息，即构造出线索化二叉树</li>
<li>线索化二叉树加快了查找结点前驱和后继的速度</li>
<li>如果没有左孩子，则左指针域存放结点前驱位置</li>
<li>如果没有右孩子，则右指针域存放结点后继位置</li>
<li>还要在结点中增加两个布尔标记变量，记录左右指针域存放的是孩子的位置还是前驱后继的位置
<ul>
<li>这样的结点构成的链表叫做线索链表</li>
<li>这样的结点构成的二叉树叫做线索二叉树</li>
<li>如果指针域指向了前驱和后继，该指针称为线索</li>
</ul></li>
</ul>
<h4 id="中序线索二叉树">中序线索二叉树</h4>
<ul>
<li>构造
<ul>
<li>本质就是中序遍历一次</li>
<li>附设pre和p两个指针，指向上一个和当前访问的结点</li>
<li>p的左指针为空则指向pre</li>
<li>pre的右指针为空则指向p</li>
</ul></li>
<li>遍历
<ul>
<li>FirstNode函数：第一个节点为最左下方的结点（不一定是叶子），不断访问左孩子即可（如果有左孩子）</li>
<li>NextNode函数：访问当前结点后
<ul>
<li>如果其右指针不是右孩子，则右指针为后继</li>
<li>如果其右指针是右孩子，则后继为右子树的最左下方的结点，需要调用FirstNode函数</li>
</ul></li>
<li>LastNode函数：最后一个节点最右下方的结点（不一定是叶子），不断访问右孩子即可（如果有右孩子）</li>
<li>PreviousNode函数：访问当前结点后
<ul>
<li>如果其左指针不是左孩子，则左指针为前驱</li>
<li>如果其左指针是左孩子，则前驱为左子树的最右下方的结点，需要调用LastNode函数</li>
</ul></li>
</ul></li>
</ul>
<h4 id="先序后序线索二叉树">先序后序线索二叉树</h4>
<ul>
<li>构造
<ul>
<li>本质还是先按先序或后序遍历一次</li>
<li>附设pre和p两个指针，指向上一个和当前访问的结点</li>
<li>p的左指针为空则指向pre</li>
<li>pre的右指针为空则指向p</li>
</ul></li>
<li>遍历
<ul>
<li>先序线索树找后继
<ul>
<li>如果有左孩子，左孩子为后继</li>
<li>如果没左孩子有右孩子，右孩子为后继</li>
<li>如果没孩子，右指针为后继</li>
</ul></li>
<li>后序线索树找后继
<ul>
<li>如果为根，则无后继</li>
<li>如果是双亲的右孩子，则后继为双亲</li>
<li>如果是双亲的左孩子，且双亲没右孩子，则后继为双亲</li>
<li>如果是双亲的左孩子，且双亲有右孩子，则后继为双亲右子树后序遍历第一个结点</li>
<li>可以看出后序线索树找后继还需要知道双亲结点，因此要采用带双亲标志域的三叉链表</li>
</ul></li>
<li>先序线索树找前驱
<ul>
<li>如果为根，则无前驱</li>
<li>如果是双亲的左孩子，则前驱为双亲</li>
<li>如果是双亲的右孩子，且双亲没左孩子，则后继为双亲</li>
<li>如果是双亲的右孩子，且双亲有左孩子，则前驱为双亲左子树先序遍历最后一个结点</li>
<li>可以看出先序线索树找前驱还需要知道双亲结点，因此要采用带双亲标志域的三叉链表</li>
</ul></li>
<li>后序线索树找前驱
<ul>
<li>如果有右孩子，右孩子为前驱</li>
<li>如果没右孩子有左孩子，左孩子为前驱</li>
<li>如果没孩子，左指针为前驱</li>
</ul></li>
</ul></li>
</ul>
<h2 id="树和森林">树和森林</h2>
<h3 id="树的存储结构">树的存储结构</h3>
<h4 id="双亲表示法">双亲表示法</h4>
<ul>
<li>利用结点双亲的唯一性</li>
<li>采用连续顺序存储</li>
<li>记录双亲在数组的位置</li>
<li>类似于静态链表</li>
</ul>
<h4 id="孩子表示法">孩子表示法</h4>
<ul>
<li>数据元素为链表的数组</li>
<li>每个结点的孩子都用一条链串成线性的结构</li>
<li>类似于邻接表的结构</li>
</ul>
<h4 id="二叉树表示法孩子兄弟表示法">二叉树表示法（孩子兄弟表示法）</h4>
<p>该数据结构很适合实现前面二叉树部分的笔记提到的树转换成二叉树。其中二叉树的每个结点包含：
+ 结点值 + 第一个孩子的指针 + 第一个兄弟的指针</p>
<p>该结构的缺点是找双亲开销比较大</p>
<h3 id="树森林和二叉树的转换">树、森林和二叉树的转换</h3>
<h4 id="树到二叉树">树到二叉树</h4>
<ul>
<li>每个结点的左指针指向最左边的孩子</li>
<li>每个结点的右指针指向右边第一个兄弟</li>
<li>根没有兄弟，因此根在二叉树上没有右孩子</li>
</ul>
<h4 id="森林到二叉树">森林到二叉树</h4>
<ul>
<li>将森林的每个树转换为二叉树</li>
<li>森林的树之间看作兄弟，即二叉树之间用根的右指针链接</li>
</ul>
<h4 id="二叉树到森林">二叉树到森林</h4>
<ul>
<li>二叉树的根和其左子树为第一颗树</li>
<li>二叉树的根的右子树为森林剩下部分，递归拆分树</li>
<li>把拆分后的每个二叉树还原为树</li>
</ul>
<h3 id="树和森林的遍历">树和森林的遍历</h3>
<h4 id="树的遍历">树的遍历</h4>
<ul>
<li>类似于二叉树的遍历</li>
<li>树的先根遍历：先访问根，再依次先根遍历子树，<strong>即普通树的二叉树表示的先序遍历</strong></li>
<li>树的后根遍历：先依次后根遍历子树，再访问根，<strong>即普通树的二叉树表示的中序遍历</strong></li>
<li>树的层次遍历：类似于二叉树层次遍历，用到队列</li>
<li>普通树一般不考虑中序遍历</li>
</ul>
<h4 id="森林的遍历">森林的遍历</h4>
<ul>
<li>先序遍历森林
<ul>
<li>先访问第一棵树的根结点</li>
<li>再先序访问第一颗树去掉根的子树森林</li>
<li>最后先序访问森林剩余部分</li>
<li><strong>即森林的二叉树表示的先序遍历</strong></li>
</ul></li>
<li>中序遍历森林
<ul>
<li>先按照中序遍历访问第一颗树去掉根的子树森林</li>
<li>再访问第一棵树的根结点</li>
<li>最后中序遍历访问森林剩余部分</li>
<li><strong>即森林的二叉树表示的中序遍历</strong></li>
</ul></li>
<li>有时也把中序遍历森林称为后续遍历森林，不同教材称呼不同</li>
</ul>
<h3 id="树的应用之并查集">树的应用之并查集</h3>
<p>假设全集合为S，里面有若干元素。并查集支持三个操作：</p>
<ul>
<li>初始化集合S的每个元素自成一个单元素子集合（构成了一个划分）</li>
<li>将两个互不相交的子集合合并</li>
<li>查询S中的元素x所在的子集合</li>
</ul>
<p>并查集结构</p>
<ul>
<li>通常是根树，结点包含双亲的位置</li>
<li>存储一般是顺序存储，根结点的双亲位置标记为-1</li>
</ul>
<p>并查集优化</p>
<ul>
<li>加权“并”：每次合并时将结点数少的集合挂到结点数多的集合的根上</li>
<li>路径压缩“查”：每次查完一个结点，把该结点到根上所有的结点都直接挂到根结点上</li>
</ul>
<p>并查集性能</p>
<ul>
<li>假定并查集包含<span class="math inline">\(n\)</span>个元素，同时指向长度为<span class="math inline">\(l\)</span>的并和查指令序列</li>
<li>普通并、普通查，复杂度<span class="math inline">\(O(nl)\)</span></li>
<li>加权并、普通查，复杂度<span class="math inline">\(O(n+l\ log\
n)\)</span></li>
<li>加权并、路径压缩查，复杂度<span class="math inline">\(O((n+l)log^\star n)\)</span>，其中<span class="math inline">\(log^\star\)</span>的定义基于超指数函数，增长非常慢，可以近似认为，复杂度是<span class="math inline">\(O(n+l)\)</span></li>
</ul>
<h2 id="二叉树的应用">二叉树的应用</h2>
<h3 id="二叉排序树bst">二叉排序树(BST)</h3>
<ul>
<li>定义
<ul>
<li>左子树非空，则左子树值小于根值</li>
<li>右子树非空，则右子树值大于根值</li>
<li>左右子树都是BST</li>
</ul></li>
<li>查找
<ul>
<li>如果根值和目标值相等则找到</li>
<li>如果目标值较小则进入左子树继续找</li>
<li>如果目标值较大则进入右子树继续找</li>
</ul></li>
<li>插入
<ul>
<li>如果二叉排序树为空，则直接插入</li>
<li>否则如果关键字较小，则插入左子树</li>
<li>如果关键字较大，则插入右子树</li>
<li>插入时一定是作为叶子结点</li>
</ul></li>
<li>构造：从空树开始依次插入结点即可</li>
<li>删除
<ul>
<li>如果是叶子结点可以直接删除</li>
<li>如果删除结点只有左子树或只有右子树，则让该子树直接成为删除结点的子树</li>
<li>如果删除结点有左右子树，则用删除结点的直接前驱或直接后继代替删除结点，该前驱和后继原先一定是叶子结点，代替后删除该叶子结点。</li>
</ul></li>
<li>查找效率
<ul>
<li>平衡二叉排序树，平均查找长度是O(log n)</li>
<li>普通二叉排序树，最坏情况查找长度O(n)</li>
<li>和二分查找类似，但二分查找表是静态的，判定唯一，二叉排序树根据元素插入顺序不同，不唯一</li>
<li>在插入删除时，为了维护表的有序性，二叉排序树平均开销O(log
n)，二分查找的有序顺序表平均开销O(n)</li>
</ul></li>
</ul>
<h3 id="平衡二叉树avl-tree">平衡二叉树(AVL Tree)</h3>
<ul>
<li>定义
<ul>
<li>任意结点左右子树高度差不超过1的二叉树</li>
<li>该高度差叫做平衡因子（只能是-1，0，1）</li>
</ul></li>
<li>插入
<ul>
<li>每插入一个结点，检查最小不平衡子树T，假设T的根为A</li>
<li>此时A是插入路径上平衡因子绝对值大于1的最接近插入点的结点（否则和最小平衡树矛盾）</li>
<li>设A,B,C是插入路径上从上到下的三个结点</li>
<li>LL型：B是A左孩子，C是B左孩子，进行右单旋转，用B代替A，A是B的右孩子，B原右孩子变成A左孩子</li>
<li>RR型：B是A右孩子，C是B右孩子，进行左单旋转，用B代替A，A是B的左孩子，B原左孩子变成A右孩子</li>
<li>LR型：B是A左孩子，C是B右孩子，先左单旋转，用C代替B，B是C的左孩子，C的原左孩子变成B的右孩子；再右单旋转，用C代替A，A是C的右孩子，C的原右孩子变成A的左孩子</li>
<li>RL型：B是A右孩子，C是B左孩子，先右单旋转，用C代替B，B是C的右孩子，C的原右孩子变成B的左孩子；再左单旋转，用C代替A，A是C的左孩子，C的原左孩子变成A的右孩子</li>
</ul></li>
<li>删除
<ul>
<li>按普通二叉排序树删除</li>
<li>从删除点向根找第一个不平衡点，对于该点和该点较高子树路径上的三个点，执行类似的LL、RR、LR、RL旋转</li>
<li>如果由于旋转操作造成不平衡点上面有新的不平衡点，则继续的向根调整</li>
</ul></li>
<li>查找
<ul>
<li>过程和普通二叉树查找相同</li>
<li>假设<span class="math inline">\(n_h\)</span>表示深度为h的平衡树最少需要的结点数,显然<span class="math inline">\(n_0=0,n_1=1,n_h=n_{h-1}+n_{h-2}+1\)</span>，该结论可以解决问题：给定结点数求平衡树的最大深度问题</li>
<li>可以证明平衡二叉树最大深度是<span class="math inline">\(O(log
n)\)</span></li>
</ul></li>
</ul>
<h3 id="哈夫曼树和哈夫曼编码">哈夫曼树和哈夫曼编码</h3>
<ul>
<li>哈夫曼树定义
<ul>
<li>树的带权路径长度定义为<span class="math inline">\(WPL=\sum_{i=1}^nw_il_i\)</span>，其中<span class="math inline">\(w_i\)</span>为第i个叶结点的权值，<span class="math inline">\(l_i\)</span>为根结点到第i个叶结点的路径长度</li>
<li>哈夫曼树是带权路径长度最小的树，最优二叉树</li>
</ul></li>
<li>哈夫曼树构造
<ul>
<li>将n个结点分别作为单结点二叉树，构造森林F</li>
<li>取F中最小两个权值的树，作为左右子树，构造一个新结点，权值为左右子树权值和</li>
<li>用新树代替刚刚的两棵树加入F中</li>
<li>重复前两步骤直至F中只有一棵树</li>
</ul></li>
<li>哈夫曼树特点
<ul>
<li>所有初始结点最后都成为叶结点，权值小的结点到根的路径长度更大</li>
<li>构造过程新建了n-1个结点，哈夫曼树总结点数为2n-1</li>
<li>哈夫曼树不存在度为1的结点</li>
</ul></li>
<li>哈夫曼编码
<ul>
<li>如果对字符用等长的二进制位表示，则是<strong>固定长度编码</strong></li>
<li>如果对不同字符用不同长度的二进制表示，则是<strong>可变长度编码</strong>，好处是可以给高频词短的编码，给低频词长的编码，从而缩短平均编码长度，实现数据压缩</li>
<li>如果没有一个编码是一个编码的前缀，则这样的编码叫做前缀码，前缀码的优点是解码简单，识别出第一个编码就可以翻译为原码</li>
<li>很容易从哈夫曼树构造出哈夫曼编码，字符作为独立结点参与哈夫曼树构造，成为叶结点。字符的编码就是从根到该字符的路径边标记序列（如向左孩子标记为0，向右孩子标记为1）</li>
<li>哈夫曼树的带权路径长度就是哈夫曼编码的平均二进制编码长度</li>
<li>哈夫曼树不一定唯一，编码也不一定唯一，但WPL一定是相同且最优的</li>
</ul></li>
<li>推广的哈夫曼树
<ul>
<li>如果是多叉树（n叉树），需要保证每个结点的孩子数都是n，做法是补若干权值为0的结点</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【阅读笔记】 Enhancing the Reliability of Out-of-Distribution Image Detection In Neural Networks</title>
    <url>/2021/02/20/ODIN/</url>
    <content><![CDATA[<h2 id="abstract">Abstract</h2>
<p>本文考虑神经网络中图像的OoD的检测问题。作者提出了ODIN方法，这个方法的好处是不用对训练好的网络进行任何的更改。本文的理论基于两个手段————<strong>temperature
scaling</strong>和<strong>input
perturbation</strong>。这两个手段可以加大ID和OoD的softmax分布的差异，有助于检测。作者通过一系列的实验证明ODIN的方法对于各种网络结构和数据集都是兼容的，并且性能远好于baseline，可以称得上是一个state-of-the-art的方法。例如，设置网络架构为DenseNet，数据集为CIFAR-10和Tiny-ImageNet，ODIN相比于baseline把<strong>FPR
at 95% TPR</strong>从34.7%降低到4.3%。</p>
<h2 id="introduction">Introduction</h2>
<p>现代神经网络在训练集和测试集样本来自同一个分布的时候效果很好。但现实世界部署的时候，往往测试集的分布是不受控制的。最近的工作表明，即使是输入不相关的数据，神经网络的预测结果也会偏高。对于分类器来说，遇到没见过的输入时给出一个不确定的反馈非常重要。因此，精确的检测OoD样本在视觉识别任务的实践中非常重要。</p>
<p>一个看上去比较直接的OoD检测方式就是扩大In-Distribution集合和Out-of-Distribution集合的规模。而OoD的数据往往是很有限的，这让再训练变得昂贵且难以处理。此外，为了确保神经网络在准确的给ID进行分类的同时，也能正确的检测出OoD,可能需要很大的神经网络架构，这使得训练过程更加复杂。</p>
<p>Hendrycks &amp;
Gimpel提出一个baseline方法检测OoD,且不需要重训练网络。这个方法的提出基于一个观察，那就是训练好的网络倾向于给ID样本一个相对更高的softmax
scores。在本文，工作进一步被开展。作者发现，使用temperature
scaling在softmax函数中，并且给输入进行小的扰动，即input
perturbation，那么ID和OoD的softmax分布就会增大差异。本文展示了，这两个方法可以提高检测性能。比如，对于训练好的DenseNet网络，用CIFAR-10作为ID,TinyImageNet作为OoD，本文的方法把<strong>FPR
at 95%
TPR</strong>这个指标从34.7%下降到4.3%。本文的主要贡献总结如下：</p>
<ul>
<li>提出一个简单而有效的方法，ODIN(<strong>O</strong>ut-of-<strong>Di</strong>stribution
detector for <strong>N</strong>erual
networks)，不需要重训练神经网络，且容易在任意现代网络结构中执行。</li>
<li>在先进的网络结构(如DenseNet和Wide
ResNet)中，用不同的数据集对作为ID和OoD。实验表明ODIN的方法可以显著的提高检测性能，并且始终比baseline的表现好得多。</li>
<li>结合实证分析了参数的设置如何影响性能，并提供了简单的分析以帮助直观了解本文方法。</li>
</ul>
<p>本文的脉络大概是：第一部分为介绍；第二部分提供必要的定义和问题陈述；第三部分介绍ODIN方法；第四部分展示性能结果；第五部分实验性的分析ODIN方法并进行评估；第六部分总结相关工作和未来的方向；第七部分总结全文。</p>
<h2 id="problem-statement">Problem Statement</h2>
<p>本文中，作者考虑了在训练好的神经网络中区分ID和OoD图片输入的问题。令<span class="math inline">\(P_{\pmb{X}}\)</span>和<span class="math inline">\(Q_{\pmb{X}}\)</span>表示定义在空间<span class="math inline">\(\chi\)</span>上的两个不同的数据分布。假定神经网络<span class="math inline">\(\pmb{f}\)</span>的训练数据是抽样于<span class="math inline">\(P_{\pmb{X}}\)</span>的，那么<span class="math inline">\(P_{\pmb{X}}\)</span>就成为In-Distribution，而与之不同的<span class="math inline">\(Q_{\pmb{X}}\)</span>就是Out-of-Distribution。在测试中，我们从一个混合分布<span class="math inline">\(P_{\pmb{X}\times
Z}\)</span>抽取新的图像，其中条件概率分布<span class="math inline">\(P_{\pmb{X}|Z=0}=P_{\pmb{X}}\)</span>表示In-Distribution,
而<span class="math inline">\(P_{\pmb{X}|Z=1}=Q_{\pmb{X}}\)</span>表示Out-of-Distribution。我们考虑下面的问题：给定一个从混合分布<span class="math inline">\(P_{\pmb{X}\times Z}\)</span>中抽取的图像<span class="math inline">\(\pmb{X}\)</span>，如何分辨这个图像是否来自于<span class="math inline">\(P_{\pmb{X}}\)</span>？</p>
<p>在本文中，作者关注OoD图像的检测。然而，把一个ID图像正确分类也同样重要。但这个比较容易，因为一旦检测出图像不是OoD,就可以直接把原始图像丢进网络中就可以分类。因为，作者不改变神经网络对于ID图像的预测结果，仅仅聚焦于提高OoD图像的检测性能。</p>
<h2 id="odin-out-of-distribution-detector">ODIN: Out-of-Distribution
detector</h2>
<p>在本节，作者提出了ODIN方法，来检测OoD样本。检测器由两个组件构成：temperature
scaling 和input preprocessing。接下来是两个组件的细节。</p>
<h3 id="temperature-scaling">Temperature Scaling</h3>
<p>假定神经网络<span class="math inline">\(\pmb{f}=(f_1,...,f_N)\)</span>是N类分类器。对于每个输入<span class="math inline">\(\pmb{x}\)</span>，神经网络的输出标签<span class="math inline">\(\hat{y}(\pmb{x})=arg\ max_i\
S_i(\pmb{x};T)\)</span>,其中 <span class="math display">\[\begin{equation}
S_i(\pmb{x};T)=\frac{exp(f_i(\pmb{x})/T)}{\sum_{j=1}^{N}exp(f_j(\pmb{x})/T)}
\end{equation}\]</span> <span class="math inline">\(T\in
R^{+}\)</span>是temperature
scaling的参数，训练时设置为1。对于给定的输入<span class="math inline">\(\pmb{x}\)</span>,我们称softmax向量中最大的概率值，即<span class="math inline">\(S_{\hat{y}}(\pmb{x};T)=max_i\
S_i(\pmb{x};T)\)</span>,为<strong>softmax score</strong>。本文把<span class="math inline">\(S_{\hat{y}}(\pmb{x};T)\)</span>简写为<span class="math inline">\(S(\pmb{x};T)\)</span>。之前已经有工作使用了temperature
scaling来提取神经网络的知识，并校准分类任务的预测置信度。我们将看到，使用temperature
scaling 可以分离ID和OoD的softmax scores，让检测更有效。</p>
<h3 id="input-preprocessing">Input Preprocessing</h3>
<p>除了temperature scaling，本文通过添加微扰对输入进行预处理： <span class="math display">\[\begin{equation}
\tilde{\pmb{x}}=\pmb{x}-\epsilon sign(-\nabla_{\pmb{x}}log\
S_{\hat{y}}(\pmb{x};T))
\end{equation}\]</span> 其中<span class="math inline">\(\epsilon\)</span>是控制扰动大小的参数。这个方法是受对抗样本的启发(即在对抗样本工作中，添加小的扰动，降低正样本的softmax
score从而迫使网络做出错误预测)。而本文目标和设置刚好相反。本文旨在对任意输入(不需要类标签)都增加softmax
score。之后将看到，微扰对ID的影响大于OoD的影响，使得它们更加分离。注意到，对交叉熵损失梯度(相对于输入)进行反向传播，很容易计算微扰。</p>
<h3 id="out-of-distribution-detector">Out-of-Distribution detector</h3>
<p>检测器结合了上述两个组件。对于每个图像<span class="math inline">\(\pmb{x}\)</span>, 首先用公式2计算预处理后的<span class="math inline">\(\tilde{\pmb{x}}\)</span>。然后把预处理后的<span class="math inline">\(\tilde{\pmb{x}}\)</span>丢入网络，计算修正后的softmax
score<span class="math inline">\(S(\pmb{x};T)\)</span>。然后把score和阈值<span class="math inline">\(\delta\)</span>比较。如果大于阈值则判定为ID，否则判定为OoD。OoD检测器的数学描述如下：
<span class="math display">\[\begin{equation}
g(\pmb{x};\delta,T,\epsilon)=
\begin{cases}
1&amp; max_i\ p(\tilde{\pmb{x}};T) \leq \delta \\
0&amp; \text{otherwise}
\end{cases}
\end{equation}\]</span> 设置参数<span class="math inline">\(T\)</span>、<span class="math inline">\(\epsilon\)</span>和<span class="math inline">\(\delta\)</span>为合适的值，使得TPR为95%。</p>
<h2 id="experiments">Experiments</h2>
<p>本节，作者在几个CV的benchmark数据集上展示了ODIN方法的性能。实验完全用PyTorch框架编写，代码是开源的以方便复现。</p>
<h3 id="training-setup">Training setup</h3>
<h4 id="architectures-and-training-configuration">Architectures and
training configuration</h4>
<p>本文采用两个state-of-the-art的神经网络架构，分别为DenseNet和Wide
ResNet。对于DenseNet，我们的模型设置为：层数<span class="math inline">\(L=100\)</span>,growth rate <span class="math inline">\(k=12\)</span>(Dense-BC),dropout rate=0。对于Wide
ResNet，层数为28，宽度10，dropout
rate为0。神经网络的超参数设置和原始的Wide ResNet (Zagoruyko &amp;
Komodakis, 2016) and DenseNet (Huang et al.,
2016)实现完全相同。所有的网络都用带牛顿动量的SGD法(Duchi et al., 2011;
Kingma &amp; Ba, 2014)优化。具体来说，作者训练Dense-BC轮次为300，batch
size为64，momentum为0.9；训练Wide ResNet轮次为200，batch
size为128，momentum为0.9。学习率起始为0.1，当训练进行到50%和75%时，再相对降低10倍。</p>
<h4 id="accuracy-of-pre-trained-networks">Accuracy of pre-trained
networks</h4>
<p>两个网络结构的训练集都是CIFAR-10和CIFAR-100。CIFAR-10和CIFAR-100分别有10个类和100个类，都包括50000个训练集和10000个测试集。在CIFAR数据集上的测试错误率如下表(Table
1)：</p>
<img src="/2021/02/20/ODIN/Table1.jpg" class title="this is table">
<h3 id="out-of-distribution-datasets">Out-of-Distribution Datasets</h3>
<p>在测试阶段，来自CIFAR-10(以及CIFAR-100)的图像数据集被看作是In-Distribution样本，对于OoD样本，按照(Hendrycks
&amp; Gimpel,
2017)的设置，测试了几个不同的自然图像数据集和合成噪声数据集。本文考虑了如下OoD测试数据集。</p>
<ul>
<li><p><strong>TinyImageNet</strong> 本数据集是 ImageNet images (Deng et
al.,
2009)的子集，包含10000个测试图像，200个类型。实验中构造两个数据集，crop版本和resize版本，方法分别为随机裁剪<span class="math inline">\(32\times32\)</span>大小的子图、降像素采样至<span class="math inline">\(32\times32\)</span>大小的子图。</p></li>
<li><p><strong>LSUN</strong> 本数据集为Large-scale Scene
UNderstanding数据集，有10000个测试集图像，10个类，比如卧室、厨房、客厅。和TinyImageNet一样，构造两个数据集，分别为crop版本和resize版本。</p></li>
<li><p><strong>Gaussian Noise</strong>
本数据集为合成高斯噪声，包含10000个随机的二维高斯噪声图像，且RGB三个信道的值都从各自的独立同分布的高斯分布中采样，均值为0.5，方差为单位大小。本实验把像素映射到[0,1]区间。</p></li>
<li><p><strong>Uniform Noise</strong>
本数据集为合成均匀分布噪声，包含10000个图像，每个像素点的RGB都独立的、同等的从一个[0,1]均匀分布中采样。</p></li>
</ul>
<p>对于超参数调优，使用iSUN(Xu et al.,
2015)作为<strong>验证集</strong>。此数据集和前面四个测试集是独立的，由自然场景图像组成，包含8925个图像，每个图像也被降像素采样到<span class="math inline">\(32\times 32\)</span>的大小。</p>
<h3 id="evaluation-metrics">Evaluation metrics</h3>
<p>本文采用下面的四个指标来度量一个神经网络区分ID和OoD的性能。 +
<strong>FPR at 95% TPR</strong>
即TPR为95%时，负样本(OoD样本)识别为正样本(ID样本)的概率 +
<strong>Detection Error</strong> <span class="math inline">\(P_e\)</span>为TPR为95%时的错误分类概率。具体可以定义为<span class="math inline">\(P_e=0.5(1-TPR)+0.5FPR\)</span>，假定正例和反例在测试集中出现概率一样大。
+ <strong>AUROC</strong>
即ROC曲线的面积，是一个依赖于阈值的指标。本指标刻画了TPR和FPR的关系。可以看作是正例比反例能获得更高的detection
score的概率。一个完美的检测器有着100%的AUROC。 + <strong>AUPR</strong>
即PR曲线的面积，也是一个依赖于阈值的指标。具体来说，P就是<span class="math inline">\(TP/(TP+FP)\)</span>,R就是<span class="math inline">\(TP/(TP+FN)\)</span>，PR曲线就是P和R的关系图。而下表（Table
2）中，AUPR-In和AUPR-Out是当ID和OoD分别指定为正例时，PR曲线的面积。</p>
<img src="/2021/02/20/ODIN/Table2.jpg" class title="this is table">
<h3 id="experimental-results">Experimental results</h3>
<h4 id="comparison-with-baseline">Comparison with baseline</h4>
<p>下图(Figure
1)展示了DenseNet-BC-100的ROC曲线，测试集中正例为CIFAR-10,负例为TinyImageNet。红色的曲线对应于baseline方法，蓝色的曲线对应于ODIN的方法。可以观察到两个曲线有一个比较大的gap。比如，当TPR=95%时，FPR从34%(baseline)降低到4.2%(ODIN)。</p>
<img src="/2021/02/20/ODIN/Figure1.jpg" class title="this is figure">
<h4 id="hyperparameters">Hyperparameters</h4>
<p>本文使用单独的OoD验证集用于调参。对于T参数，在1、2、5、10、20、50、100、200、500、1000中选择。对于微扰程度<span class="math inline">\(\epsilon\)</span>，从0到0.004中等距选取。调节参数到合适的值，使得验证集的FPR
at 95% TPR指标最小。</p>
<h4 id="main-result">Main result</h4>
<p>主要的结果总结在之前的Table 2中。验证集是iSUN(Xu et al.,
2015)。T都设置为1000。对于DenseNet，对CIFAR-10使用<span class="math inline">\(\epsilon=0.0014\)</span>，对CIFAR-100使用<span class="math inline">\(\epsilon=0.002\)</span>。在下一节Discussions中提供参数影响的细节。对于每一对ID和OoD数据集，实验都记录了baseline和ODIN的性能，从Table
2中可以看到在所有的数据对中，ODIN的性能相比baseline都有显著提升。</p>
<h4 id="parameter-transferability">Parameter transferability</h4>
<p>下表(Table
3)展示了，在单个验证集上进行参数调节是具有泛化性的。具体来说，使用单个OoD数据集作为验证集来调参，然后用剩余的OoD测试集进行评估。每次(不同的OoD验证集)的结果都是相似，这说明了本文的方法对于验证集的选取不太敏感。</p>
<img src="/2021/02/20/ODIN/Table3.jpg" class title="this is table">
<p>注：神经网络是在CIFAR-10上预训练的。</p>
<h4 id="data-distributional-distance-vs.-detection-performance">Data
distributional distance vs. detection performance</h4>
<p>为了度量ID和OoD数据集的统计距离，本文采用了一个广泛使用的指标，即<strong>Maximum
Mean
Discrepancy</strong>(MMD)。使用高斯RBF核。具体来说，给定两个图像集合，<span class="math inline">\(V={v_1,...,v_m}\)</span>、<span class="math inline">\(W={w_1,...,w_m}\)</span>。V和Q最大平均误差MMD定义如下：
<span class="math display">\[\begin{equation}
\widehat{MMD}^2(V,W)=\frac{1}{\tbinom{m}{2}}\sum\limits_{i\neq
j}k(v_i,v_j)+\frac{1}{\tbinom{m}{2}}\sum\limits_{i\neq
j}k(w_i,w_j)-\frac{2}{\tbinom{m}{2}}\sum\limits_{i\neq j}k(v_i,v_j)
\end{equation}\]</span></p>
<p>其中<span class="math inline">\(k(.,.)\)</span>为Gaussian RBF
kernel。比如<span class="math inline">\(k(x,x&#39;)=exp(-\frac{\|\|x-x&#39;\|\|_2^2}{2\sigma^2})\)</span>。本文使用和Sutherland
et al.(2016)相同的方法去选择<span class="math inline">\(\sigma\)</span>。此时<span class="math inline">\(2\sigma^2\)</span>设置为集合<span class="math inline">\(V\cup W\)</span>中所有图像间欧氏距离的均值。</p>
<p>下图(Figure
2)展示了ODIN的性能如何随着ID和OoD之间的MMD距离变化而变化。数据集(x轴)是按MMD距离降序排序的。网络在CIFAR-100上训练，OoD数据集从1到5分别为：LSUN(cop)、TinyImageNet(crop)、LSUN(resize)、iSUN(resize)、TinyImageNet(resize)。</p>
<img src="/2021/02/20/ODIN/Figure2.jpg" class title="this is figure">
<p>可以发现两个有趣的结论： +
裁剪会使得数据集和CIFAR-100的MMD距离变得更大，可能是因为裁剪后图像只包含局部信息，因此与CIFAR-100的区别加大，而resized后的图像还包含全局的信息，因此和CIFAR-100中图像相对相似。
+
MMD距离和检测性能是负相关的。这表明当ID和OoD图像相似度时候，检测任务会变得困难。</p>
<h2 id="discussions">Discussions</h2>
<h3 id="analysis-on-temperature-scaling">Analysis on temperature
scaling</h3>
<p>在本小节，作者分析了temperature scaling方法的有效性。如下图(Figure
3)的(a)(b)，可以观察到足够大的T可以获得更好的检测性能，当T过大的时候，这种正面影响变弱。</p>
<img src="/2021/02/20/ODIN/Figure3.jpg" class title="this is figure">
<p>为了深入原理，作者对softmax
score进行泰勒展开，假设T可以充分大，详细推导如下： <span class="math display">\[\begin{equation}
\begin{aligned}
S_{\hat{y}}(\pmb{x};T)&amp;=\frac{exp(f_{\hat{y}}(\pmb{x})/T)}{\sum_{i=1}^{N}exp(f_i(\pmb{x})/T)}\\
&amp;=\frac{1}{\sum_{i=1}^{N}exp(\frac{f_i(\pmb{x})-f_{\hat{y}}(\pmb{x})}{T})}\\
&amp;=\frac{1}{\sum_{i=1}^{N}[1+\frac{f_i(\pmb{x})-f_{\hat{y}}(\pmb{x})}{T}+\frac{1}{2!}\frac{(f_i(\pmb{x})-f_{\hat{y}}(\pmb{x}))^2}{T^2}+o(\frac{1}{T^2})]}\\
&amp;\approx\frac{1}{N-\frac{1}{T}\sum_{i=1}^{N}[f_{\hat{y}}(\pmb{x})-f_i(\pmb{x})]+\frac{1}{2T^2}\sum_{i=1}^N[f_i(\pmb{x})-f_{\hat{y}}(\pmb{x})]^2}\\
&amp;
\end{aligned}
\end{equation}\]</span></p>
<p>最后结果忽略了第三阶以及更高的项。为了简化表示，假定： <span class="math display">\[\begin{equation}
\begin{aligned}
&amp;U_1(\pmb{x})=\frac{1}{N-1}\sum\limits_{i\neq\hat{y}}[f_{\hat{y}}(\pmb{x})-f_i(\pmb{x})]
\\
and\ \ \ \ \ &amp;U_2(\pmb{x})=\frac{1}{N-1}
\sum\limits_{i\neq\hat{y}}[f_{\hat{y}}(\pmb{x})-f_i(\pmb{x})]^2
\end{aligned}
\end{equation}\]</span></p>
<p>接着，作者对<strong><span class="math inline">\(U_1\)</span>和<span class="math inline">\(U_2\)</span>进行了解释</strong>。根据定义，<span class="math inline">\(U_1\)</span>度量了最大的logits和其余logits之间的偏差。而<span class="math inline">\(U_2\)</span>还度量了其余小logits之间的偏差。个人的理解是因为<span class="math inline">\(U_2\)</span>的形式类似于方差，因为可以在括号内加上一个logits平均值再减去一个logits平均值，然后用完全平方公式展开，可得到条件正相关于方差的形式(即<span class="math inline">\(U_1\)</span>固定，<span class="math inline">\(U_2\)</span>正相关于其他小logits间的方差)。在本文的附录D中有详细推导，此处从略。下图(Figure
5)的(a)展示了每个OoD和ID的<span class="math inline">\(U1\)</span>的分布概率密度，ID是红色的。</p>
<img src="/2021/02/20/ODIN/Figure5.jpg" class title="this is figure">
<p>我们观察到神经网络使用ID输入时，最大的logits输入和其余logits的偏差更大，即<span class="math inline">\(U_1\)</span>更大。这可能是因为神经网络倾向于对ID给出更高的置信度。</p>
<p>此外，Figure 5的(b)展示了<span class="math inline">\(U_2\)</span>关于<span class="math inline">\(U_1\)</span>的条件期望<span class="math inline">\(E[U_2|U_1]\)</span>。每个曲线对应一个数据集，红色的是ID数据集CIFAR-10。可以观察到红色的曲线始终在其他曲线之上，这表明当两个图像的<span class="math inline">\(U_1\)</span>接近时，ID图像倾向于有一个更大<span class="math inline">\(U_2\)</span>。换句话说，对于ID图像，去掉最大的logits，剩余的小logits倾向于更加分散。当ID中某些类特征相似而其他类间显著不同时可能会发生上述情况。为了解释这一点，可以看Figure
5
的(f)(g)。(f)图展示了在DenseNet网络下，用CIFAR-10训练，然后输入一个来自CIFAR-10的狗的图像，得到每个类的输出logits。(g)图则是用TinyImageNet(crop)作为ID，输入一个青蛙。对于狗的图像，可以观察到标签狗和猫的预测logits非常接近但猫和卡车的输出差异就很大。这可能是因为狗和猫很相似但它们和卡车有很大差异。对于TinyImageNet(crop)数据集，除了最大的logits，其他的几个logits输出都比较接近，因此始终有一个较小<span class="math inline">\(U_2\)</span>。</p>
<p>下面，作者探讨了<strong>T的影响</strong>。为了确定选取一个较大的T是有用的，作者首先重写公式3的softmax
score函数为<span class="math inline">\(S\propto
(U_1-U_2/2T)/T\)</span>。因此softmax score很大程度上由<span class="math inline">\(U_1和U_2/2T\)</span>来决定。如之前所推论的，<span class="math inline">\(S \propto U_1\)</span>且ID的<span class="math inline">\(U_1\)</span>较大,因此<span class="math inline">\(U_1\)</span>正面促进了ID的<span class="math inline">\(S\)</span>较大这个结果；而<span class="math inline">\(S \propto -U_2\)</span>,而ID的<span class="math inline">\(U_2\)</span>相对于OoD也更大，故<span class="math inline">\(U_2\)</span>负面削弱了ID的<span class="math inline">\(S\)</span>较大这个结果。因此可以选取一个较大的temperature来弥补<span class="math inline">\(U_2/T\)</span>对检测性能的负面影响。这样，In-Distribution和Out-of-Distribution的softmax
score就更加分离。最后，如果<span class="math inline">\(T\)</span>充分的大，softmax score几乎只被<span class="math inline">\(U_1\)</span>所影响————这解释了Figure
3(a)(b)的现象，也就是为什么<span class="math inline">\(T\)</span>太大了后(eg.,T&gt;100)性能不再提升。在附录C中作者提供了规范的证明，来展示当T无穷大的时候检测误差将收敛为常数。可以详见作者原文，本笔记从略。</p>
<h3 id="analysis-on-input-preprocessing">Analysis on Input
Preprocessing</h3>
<p>正如前文所说，使用temperture
scaling方法对于检测性能提高是很有效的。然而当T很大的时候，性能就不再继续提升了。为了进一步提高性能，作者补充了一个input
preprocessing的方法。正如下图(Figure 4)所展示的，使用合适的微扰程度<span class="math inline">\(\epsilon\)</span>后，检测性能得到了极大的提高(T=1000)。</p>
<img src="/2021/02/20/ODIN/Figure4.jpg" class title="this is figure">
<p>本小节提供了一些直观的理解。首先看到log-softmax函数对于微扰图像<span class="math inline">\(\hat{x}\)</span>的一阶泰勒展开： <span class="math display">\[\begin{equation}
log\ S_{\hat{y}}(\tilde{\pmb{x}};T)=log\ S_{\hat{y}}(\pmb{x};T)+\epsilon
\|\|\nabla_{\pmb{x}}log\ S_{\hat{y}}(\pmb{x};T)\|\|_1+o(\epsilon)
\end{equation}\]</span> 其中 <span class="math inline">\(x\)</span>为原始输入。</p>
<p>首先看<strong>梯度的影响</strong>。Figure 5的(c)展示了<span class="math inline">\(\|\|\nabla_{\pmb{x}}log\
S_{\hat{y}}(\pmb{x};T)\|\|_1\)</span>的分布，这是log-softmax关于<span class="math inline">\(x\)</span>梯度的一范式。一个突出的现象就是，相比大多数OoD的图像，CIFAR-10的图像倾向于有一个更大的梯度范式的值。为了进一步弄清梯度范式对softmax
score的影响，可以看到Figure 5的(d)是梯度范式关于S的条件数学期望<span class="math inline">\(E[\|\|\nabla_{\pmb{x}}log\
S(\pmb{x};T)\|\|_1|S]\)</span>。可以发现当softmax
score相同的时候，ID相比OoD的<span class="math inline">\(\|\|\nabla_{\pmb{x}}log\
S(\pmb{x};T)\|\|\)</span>更大。</p>
<p>下图(Figure 6)解释了梯度范式的影响。</p>
<img src="/2021/02/20/ODIN/Figure6.jpg" class title="this is figure">
<p>假定图像<span class="math inline">\(\pmb{x}_1\)</span>(蓝色)是ID，图像<span class="math inline">\(\pmb{x}_2\)</span>(红色)是OoD，这两者有接近的softmax
score。但经过input
processing，因为ID的梯度的一范式较大，故微扰后ID有更大的softmax
score了。这样，ID和OoD的图像就进一步的分离开(Figure
5的(e)也能看到类似的现象)。</p>
<p>然后看<strong><span class="math inline">\(\epsilon\)</span>的影响</strong>。当<span class="math inline">\(\epsilon\)</span>充分小的时候，添加微扰不会有什么影响。然而当<span class="math inline">\(\epsilon\)</span>不可忽略时，ID和OoD的gap就会受到<span class="math inline">\(\|\|\nabla_{\pmb{x}}log\
S(\pmb{x};T)\|\|\)</span>的影响。本文的观察和(Szegedy et al., 2014;
Goodfellow et al., 2015; Moosavi- Dezfooli et al.,
2017)的现象一致，都表明：<strong>给定ID图像小的微扰，softmax
scores倾向于显著改变</strong>。值得注意的是，使用一个非常大的<span class="math inline">\(\epsilon\)</span>会导致性能下降，如Figure
4。这可能是因为，当<span class="math inline">\(\epsilon\)</span>比较大的时候，泰勒展开的第二阶和更高阶项不再可以忽略。</p>
<h2 id="related-works-and-future-directions">Related works and future
directions</h2>
<p>OoD样本的检测问题在低维空间上已经在各种背景下被深入研究(可以参考Pimentel
et al.
(2014)的调查)。传统的方法，例如<strong>密度估计、最邻近、聚类分析</strong>都被广泛的使用(Chow,
1970; Vincent &amp; Bengio, 2003; Ghoting et al., 2008; Devroye et
al.,2013)。密度估计方法使用概率模型来估计ID,如果一个测试样本在低密度区域，那么就被识别为一个OoD;聚类方法基于统计距离，如果一个测试样本距离它的邻居很远，那么就被识别为OoD。尽管低维空间中方法很多，但不幸的是在高维空间(例如图像空间)中这些方法都不太可靠(Wasserman,
2006; Theis et al.,
2015)。近些年，基于深度模型的OoD检测器被提出了。Schlegl et al.
(2017)训练了一个生成式的对抗网络来检测临床场景中的OoD。Sabokrou et al.
(2016)训练了一个卷积网络来检测异常的场景。Andrews et al.
(2016)采用了迁移表征学习来进行异常检测。这些工作都需要扩充或修改神经网络架构。在最近的一个工作中(也就是baseline那篇文章)，Hendrycks
&amp; Gimpel
(2017)发现了预训练好的神经网络对于OoD样本的分类是过度自信的，这限制了检测的性能。<strong>本文旨在提高OoD样本的检测性能，而不需要修改已有的训练好的网络模型</strong>。</p>
<p>我们的方法利用了下面两个有趣的现象来提高ID和OoD的区分：(1)对于ID图像，现代神经网络倾向于产生类间方差较大的输出；(2)对于ID图像，神经网络往往会有一个较大的log-softmax
score的梯度范式。作者相信，更好地理解这些现象就可以更加理解这个问题。</p>
<h2 id="conclusions">Conclusions</h2>
<p>在本文中，作者提出了一个简单而有效的方法去检测神经网络中OoD的样本。这个方法不需要重训练神经网络，并且相比于Hendrycks
&amp; Gimpel
(2017)的baseline方法，性能在各个网络架构、各个数据集上都有很大改进。本文实证的分析了不同参数设置下的方法，并且提供了一些见解。未来的工作可以是探索本文的方法在其他领域的应用，如语音识别和自然语言处理等等。</p>
]]></content>
      <categories>
        <category>OoD Detection</category>
      </categories>
      <tags>
        <tag>Reading Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>【阅读笔记】 A Baseline for Detecting Misclassified and Out-of-Distribution Examples In Neural Networks</title>
    <url>/2021/02/13/OoD-Baseline/</url>
    <content><![CDATA[<h2 id="abstract">Abstract</h2>
<p>本文考虑样本检测中两个相关的问题：误分类和OoD。作者利用来自softmax分布的概率提出了一个检测的<strong>baseline</strong>。相比于错误分类的样本和OoD的样本，被正确分类的样本倾向于有更大的maximum
softmax概率(<strong>后文统称为置信度</strong>)。接着，baseline的各方面性能通过关于计算机视觉、自然语言处理、自动语音识别的一些任务被进行评估。作者然后说明了baseline有时是可以被超越的，展示了这个检测领域的任务未来可探索的空间。</p>
<h2 id="introduction">Introduction</h2>
<p>当训练分布和测试分布有差异的时候，应用于现实任务的机器学习分类器往往会工作失败。更糟糕的是，面对错误，这些分类器仍然会给出较高的置信度而不会报错，即使错的离谱。分类器如果不能指出自己什么时候可能是错的，它的使用就会收到限制并可能导致严重事故。例如，一个医学的诊断模型可能始终以较高的置信度进行归类，即使模型应该把不太确定的困难样本标记并留给人工处理。由此导致的未标记的错误诊断会阻碍机器学习技术未来在医疗领域的发展。作者还指出一个更普遍而重要的事情：评估一个模型何时发生错误在人工智能安全领域中饱受关注。</p>
<p>softmax输出经常产生高置信度的预测，这是因为softmax概率是由快速递增的指数函数所计算的。
因此给softmax的输入(<strong>logits</strong>)一个微小的增量，会导致输出分布的质变。因为softmax函数是指示函数的平滑近似，所以OoD样例输出一个均匀分布并不常见。实际上，随机高斯噪声输入到一个MNIST图像分类器会得到一个高达91%的预测置信度。作者在实验中表明softmax的预测概率和可信度相关性很弱。</p>
<p>但实验工作也表明，错误样本或OoD样本的预测结果，也会倾向于给出相对于正确样本较低的预测概率。因此，尽管预测概率的结果单独看是有误导性的，收集正确样本的预测概率数据对于检测异常样本是有效的。</p>
<p>这些预测概率构筑了作者的检测baseline，作者在各个领域展示了这个方法的功效，如计算机视觉、自然语言处理、自动语义识别任务等。作者也指出，尽管这些预测概率创建了一个一贯有用的basline，但有时效率也会很低，这表明了其具有改进的空间。此后作者贡献了一个比baseline更好的方法(在部分但不是全部任务中)，提供了未来检测的研究思路。这个方法通过评估神经网络输入重构(<strong>input
reconstruction</strong>)的质量来判断异常样本。</p>
<p>除了basline的方法，作者另一个贡献性的成果就是标准任务以及评估指标的设计。具体的来说，就是在三个研究领域内，用标准神经网络结构训练充分的大量任务。对于OoD检测，提供OoD的样本(不同的数据集或扭曲的实际输入)参与测试。作者希望其他研究团队在未来继续推动这些任务，并超过本文提出的basline的性能。</p>
<p>总的来说，尽管softmax分类器概率不是一个直接有用的置信度估计，但是用来估计模型的置信度也不是那么悲观。简单的统计来自softmax分布数据就是一个有效的检测OoD的方法，作者用实验进行了展示。这些创造了一个很强的检测错误和OoD的baseline，在未来有改进的空间。</p>
<h2 id="problem-formulation-and-evaluation">Problem Formulation and
Evaluation</h2>
<p>本文关心两个问题。一个是<strong>错误</strong>和<strong>正确</strong>分类的预测。另一个是<strong>In
Distribution</strong>和<strong>Out of
Distribution</strong>的检测。针对两个问题，作者提出了一个简单的baseline，并使用两组评估参数进行性能评估。作者指出，比较检测器的性能不是简单的使用精度。在检测过程中有两个类，检测器对正类和负类各输出一个打分。如果负类的个数原比正类数目多，那么检测器始终设置预测为负类也会得到很高的精度，但这是误导性的。必须设置具体的打分阈值，这样正例也可能被正确划分，但是这样就需要对<strong>false
negatives</strong>和<strong>false positives</strong>进行权衡。</p>
<p>面对这样的问题，本文使用AUROC曲线指标，这也是一个依赖于阈值的性能评估方法。Roc曲线是真正例关于假正率的曲线，此外，AUROC可以被认为是<strong>一个正例比一个反例有更大检测器分值的概率</strong>。比如说，一个随机的正例预测器的AUROC大概是50%,而一个完美的分类器的
AUCROC应该是100%。</p>
<p>AUROC回避了阈值选取的问题，而AUPR曲线有时认为含有更多的信息。这是因为当正类和反类有较大的基本比率时AUROC不太理想，而AUPR调节了正反基本比率。因此本文设置AUPR为第二个评估指标。PR曲线刻画了P和R的关系，即查准率和查全率的关系。一个baseline的检测器的AUPR大概和查准率相等，而一个完美的检测器大概是100%的AUPR。这导致，正类的基本比率很大的影响了AUPR，因此检测中需要指定什么类是正例。有鉴于此，本文的正类设为正确分类或正常的样本时作者展示了AUPRs。本文的正类设为错误分类或异常样本时作者展示了面积。把错误分类或异常样本设为正类的方法是将检测器分值乘以负一，然后打上正例的标签。注意：把错误分类和异常样本当成正例不会影响AUROC的值。</p>
<p>在第三部分作者开始了实验并描述了一个简单的baseline，这个baseline使用了神经网络分类器的置信度(即
<strong>maximum softmax
probability</strong>)。在第四部分，作者描述了一个方法，它使用额外的、经过训练的辅助模型组件来重构输入。</p>
<h2 id="softmax-prediction-probability-as-a-baseline">Softmax Prediction
Probability as a Baseline</h2>
<p>接下来，作者检索最大的softmax预测概率来检测一个样本是否被错分类或是否为OoD。具体来说，本文把测试集中正确分类和错误分类的样本分开，对于每个样本计算其softmax置信度。对于这两个类我们得到了PR和ROC曲线的面积。这些面积总结了不同阈值的二分类器用打分值(置信度)进行区分的能力。“Succ”检测器把正确分类的样本看作正例；“Err”检测器把错误分类的样例看作正例，并把置信度取反作为检测器的打分值。</p>
<p>对于“In”的检测器，正例为In
Distribution的样本和正确分类的测试样本。使用softmax置信度作为预测分类的一个分值。而“Out”检测器把OoD的样本作为正类，并使用前面提到的概率的相反数。因为“Succ”、“Err”、“In”、“Out”的AUPRs依赖于正例的比率，作者列出了一个使用基础值的随机检测器能达到的面积。在接下来的结果中，作者列出了错误分类样本的平均预测概率，以展示softmax置信度是一个孤立来看，误导性的信心指数。“Pred.Prob(mean)”列展示了OoD样本也有相同的缺点。</p>
<p>先不考虑标签，作者先从视觉相关的数据集开始实验，然后考虑自然语言处理和自动语义识别中的任务。接下来的所有实验表明，根据Wilcoxon秩和检验，AUROCs与随机基线的不同是有很高的统计显著性的。</p>
<h3 id="computer-vision">Computer Vision</h3>
<p>在计算机视觉任务中，作者使用了三个数据集：MNIST,CIFAR-10,CIFAR-100。MNIST是一个手写体数字的数据集，有60000个训练数据和10000个测试数据集;CIFAR-10有10个不同的类，50000个训练集和10000个测试集;CIFAR-100有100个不同的类，50000个训练集和10000个测试集。</p>
<p>由下表(Table
1)，可知正确分类和错误分类的样本是充分可分辨的，其中数字都是百分比。</p>
<img src="/2021/02/13/OoD-Baseline/Table1.jpg" class title="this is table">
<p>接着，作者考虑使用softmax分布去区分OoD和ID。本文把所有测试集样本作为ID，把现实图像和噪声作为OoD。对于CIFAR-10和CIFAR-100，使用了来自SUN数据集的现实图像，包含397个不同的场景。对于MNIST，使用来自三个源的灰度现实图像。其中，Omniglot是手写字母而不是手写数字；notMNIST是打字体的数字；CIFAR-10bw是黑白的CIFAR-10图像。合成的“Gaussian”数据是一个随机正态分布噪声，“Uniform”数据是随机均匀分布噪声。如果必要，图像会被调整大小。</p>
<p>结果如下表(Table 2)所示</p>
<img src="/2021/02/13/OoD-Baseline/Table2.jpg" class title="this is table">
<p>注意到平均预测置信度,即Pred.Prob(mean)大于75%，但如果预测概率单独翻译为信心，那么CIFAR-100的softmax分布应该会更均匀的。这再次表明softmax概率不应该看作是信心的直接表示。幸运的是，OoD的样本和ID的样本在概率预测上有着充分大的差异，这使得成功检测成为可能，并且可以获得较大的PR和ROC曲线面积。</p>
<p>为了可复现性，作者具体的给出了模型的结构。MNIST的分类器有三层，256的神经元宽度，由30轮Adam训练的全连接网络。网络使用了非线性的激活函数（<span class="math inline">\(x\Phi(x)\)</span>）,其中<span class="math inline">\(\Phi(x)\)</span>是标准正态分布的累积分布函数。作者根据(Hendrycks
&amp; Gimpel,
2016c)初始化了权重。对于CIFAR-10和CIFAR-100，本文分别训练了宽度为40和4的剩余网络，轮次为50回合，使用随机梯度下降，使用重启动，使用非线性激活函数，使用标准镜像以及裁剪数据增强。</p>
<h3 id="natural-language-processing">Natural Language Processing</h3>
<p>接下来作者介绍了一些自然语言处理方面的任务和使用的架构。 ####
Sentiment Classification
第一个NLP任务是一个二值情感分类问题，使用了IMDB数据集————一个极化电影评论的数据集，有25000个训练集和25000个测试集评论。这个任务让我们可以确定一个由相对较小的数据集训练的分类器是否可以产生信息丰富的softmax分布。这个任务使用一个线性分类器，以维数为50的可训练的随机初始化词向量的平均值作为输入。作者挑出5000个训练集评论，用Adam法训练15轮并早停。下表(Table
3)展示了softmax分布在正确和不正确分类的样本上的不同，因此预测概率使得我们能够可靠的检测哪个样本被正确分类，哪个被错误分类。</p>
<img src="/2021/02/13/OoD-Baseline/Table3.jpg" class title="this is table">
<p>然后作者使用Customer Review(Hu&amp;Liu,2004)和Movie Review(Pang et
al.,2002)数据集作为OoD样本，前者有产品的评论而不单单是电影，后者有来自专业影评的片段而不是业余的长篇评论。所有的IMDB测试集样本都作为in-distribution样本，而来自Customer
Review和500条和来自Moview Review的1000条测试评论是OoD样本。下表(Table
4)展示了检测结果，前面的Table2有相同的结论。</p>
<img src="/2021/02/13/OoD-Baseline/Table4.jpg" class title="this is table">
<h4 id="text-categorization">Text Categorization</h4>
<p>通过文本分类任务，作者希望判断对于相似于ID的OoD,softmax分布是否依然有用。在任务中，分类器被训练来预测他们处理的文本的主题。20
Newgroups(Lang,1995) 数据集中有20个不同的新闻组主题，共20000个文档。The
Reuters 8(Lewis et
al.,2004)数据集中有8个不同的新闻主题，近8000个故事。The Reuters
52数据集有52个新闻主题，略超过9000个新闻故事。这个数据集的单个主题最多只能有3条故事。</p>
<p>对于20
Newsgroups数据集，作者用20个轮次训练了一个30维词向量上的线性分类器。同时Reuter
8和Retuers
52使用单层神经网络，一袋单词输入，非线性激活函数，全部用Adam法进行优化了5轮。训练在一个主题子集上进行，选出了20
Newsgroups中的5个主题，Reuters 8中的2个主题，Reuters
52中的12个主题，作为OoD的样本。下表(Table
5)展示了这些数据集和结构可以可靠的检测错误分类的主题。</p>
<img src="/2021/02/13/OoD-Baseline/Table5.jpg" class title="this is table">
<p>下表(Table 6)说明了softmax预测概率可以检测出OoD的主题。</p>
<img src="/2021/02/13/OoD-Baseline/Table6.jpg" class title="this is table">
<h4 id="part-of-speech-tagging">Part-of-Speech Tagging</h4>
<p>对新闻热线和社交媒体文本进行词性标注是下一个挑战。本文使用了Wall
Street Journal portion of the Penn Treebank (Marcus et al.,
1993)数据集，包含45个不同的词性标签。对于社交媒体，作者使用POS-annotated
tweets (Gimpel et al., 2011; Owoputi et
al.,2013)数据集，包含25个标签。WSJ标注器训练了一个双向长短期记忆递归神经网络(Hochreiter
&amp; Schmidhuber,
1997)，共3层，每层128个神经元，并随机初始化词向量，在90%的语料库上进行训练，10轮随机梯度下降，batch
size是32。而tweet标注器更加简单：两层神经网络，带有非线性激活函数的，权重初始化根据(Hendrycks
&amp;Gimpel, 2016c)，预训练词向量在5600万条tweets语料库上训练(Owoputi et
al.,2013)，一个大小为256的隐层，在1000个tweets数据上训练30轮，用Adam法优化，用327条验证集tweets早停。下表(Table
7)是错误检测结果。</p>
<img src="/2021/02/13/OoD-Baseline/Table7.jpg" class title="this is table">
<p>对于OoD的检测，我们用WSJ标注器对tweets以及来自English Web
Treebank(Bies et al., 2012)的网络日志数据进行标注。结果为下表(Table
8)。</p>
<img src="/2021/02/13/OoD-Baseline/Table8.jpg" class title="this is table">
<p>因为网络日志数据比起tweets，风格上更接近新闻热线，所以检测一个网络日志数据是OoD更加困难。事实上，由于词性标注是在单词级别上完成的，我们根据单词和上下文特征判断每个单词是否是OoD。考虑到这一点，我们发现tweets的单词更容易成功检测为OoD。</p>
<h3 id="automatic-speech-recognition">Automatic Speech Recognition</h3>
<p>本节考虑的任务是使用softmax值去构建整个序列而不是决定一个输入的分类。这个序列预测系统使用一个双向的LSTM(长短期人工神经网络)，这个LSTM具有两层和剪切的非线性激活函数，用RMSProp算法优化了60回合，训练集为80%的TIMIT语料库(Garofolo
et al., 1993)。这个LSTM用连接时序分类(CTC)进行训练(Graves et al.,
2006)，以预测给定MFCCs、能量、前两个25ms帧情况下的手机序列。当用CTC进行训练的时候，LSTM学会让他的电话标签概率瞬间飙升，而大部分其他的预测为空白符号。这样，softmax的使用就不同于经典的分类问题，并为检测方法提供了独特的测试。</p>
<p>本节不去展示这个系统在正确分类和错误分类样本上的检测性能，因为错误不是二值的而是沿着一系列的编辑距离排列。但是本节可以展示OoD的检测。将TIMIT音频和来自Aurora-2数据集(Hirsch
&amp; Pearce,
2000)的真实噪声混合，并将TIMIT音频的音量保持在100%，噪声音量保持在30%，给出平均信噪比为5。人耳仍然可以清晰的听到扬声器，但手机识别器会混淆因为预测的编辑距离增加了一倍以上。更多的OoD样本使用的是来自THCHS-30
dataset(Wang &amp;
Zhang,2015)的测试样本，这是一个中文的语料库。下表(Table
9)展示了结果。</p>
<img src="/2021/02/13/OoD-Baseline/Table9.jpg" class title="this is table">
<p>很重要的是，当执行检测的时候，softmax概率被计算而空白符号的logit被忽略。有了空白符号的存在，softmax的分布大部分时间步都以较高置信度预测为空白符号；但若无空白符号，就更容易区分正常和异常的分布。通过这个修改，softmax预测概率就可以检测出OoD。</p>
<h2 id="abnormality-detection-with-auxiliary-decoders">Abnormality
Detection with Auxiliary Decoders</h2>
<p>看到了softmax预测概率使异常检测成为可能，作者接下来展示了其他对于检测很有用的信息。为了证明这一点，作者利用学习到的神经网络的内部表征。首先训练一个普通的分类器然后附加一个辅助解码器来重构输入，如下图。</p>
<img src="/2021/02/13/OoD-Baseline/Figure1.jpg" class title="this is figure">
<p>辅助解码器有时可以提高分类性能。译码器和打分器用ID样本一起训练。此后，图中蓝色的层被冻结。然后，在无噪声、有噪声的训练样本上训练红色层，然后红色层的sigmoid的输出代表着输入的正常程度评分。因此，有噪声的样本是异常类，无噪声的样本是正常类，而sigmoid被训练成为输入所属的输出类型。训练完成后就得到一个普通的分类器、一个辅助的解码器和一个被称为<strong>异常模块</strong>的模块。异常模块对检测是有益的，这表明存在可能的研究途径去超越baseline。
### TIMIT
作者使用不同的网络结构重做TIMIT任务，以测试异常模块的性能，并展示这些辅助组件对检测的改进程度。这个系统有3层，1024个神经元宽度，有一个辅助解码器和一个异常模块。该网络以11帧为输入，必须预测中心帧的手机，每帧26个特征。权重根据(Hendrycks
&amp; Gimpel,
2016c)来初始化。网络训练20轮次，异常模块训练2轮次。异常模块看到的是无噪声的样本，而负样本则是TIMIT和诸如白噪声、棕噪声(光谱密度和<span class="math inline">\(\frac{1}{f^2}\)</span>成比例的噪声)、粉色噪声(光谱密度和<span class="math inline">\(\frac{1}{f}\)</span>成比例的噪声)在不同音量下的混合。</p>
<p>可以注意到，异常模块的训练噪声和测试集的噪声不是一个类型。尽管如此，下表(Table
10)展示了把简单的噪声样本看作现实扭曲音频后得到的高效检测结果。</p>
<img src="/2021/02/13/OoD-Baseline/Table10.jpg" class title="this is table">
<p>作者指出，检测异常样本是通过比较干净样本的典型异常模块输出和扭曲样本的输出。这些来自于Aurora-2的噪声以30%的音量加入到TIMIT中。同时THCHS-30也被用作为中文语音数据集。与之前不同的是，THCHS-30是用作训练样本而不是测试集样本，因为全连接网络会充分快速的评估整个训练集。值得一提的是,全连接深度神经网络具有抗噪性(Seltzer
et al.,
2013),但异常模块仍然可以检测OoD。检测的显著性体现在：网络分类在整个测试集(非核心数据集)上的错误率是29.69%，且扭曲样本的平均分类错误率是30.43%————这和性能显著下降的双向LSTM明显不同。因为分类退化程度很小，softmax统计数据本身不能提供一个有用的OoD检测。而与之相反的是，异常模块提供一个分数去检测不同但相似的样本。在实践中，确定一个样本是否是OoD非常重要，而异常模块是有用的。</p>
<h3 id="mnist">MNIST</h3>
<p>最后，和之前实验相似的，作者训练了一个MNIST分类器，网络有三层，宽度256。本节实验同样使用一个辅助解码器和异常模块而不是仅仅依靠softmax统计。异常样本则是对训练图像进行模糊、旋转或添加高斯噪声。异常模块的收益结果如下表(Table
11)。</p>
<img src="/2021/02/13/OoD-Baseline/Table10.jpg" class title="this is table">
<p>这对比基于softmax预测概率的OoD检测来说，也有效果上的提升。并且即使是非常不同的样本，异常模块也可以进一步提高检测性能。</p>
<h2 id="discussion-and-future-work">Discussion and Future Work</h2>
<p>异常模块表明，在某些情况下basline是可以通过利用网络提取的特征打败的，暗示了无数的研究方向。利用<strong>类间方差</strong>可能是未来一个不错的研究思路：如果一个样本和另一个预测类的样本的距离异常远，那么这个样本可能是一个OoD(Giryes
et al.,
2015)。另一个方法就是把总结一层激活情况的向量输入到RNN中，每一层都有一个向量。这样对于OoD的样本，RNN可以判断出激活模式是异常的。让检测粒度更细也是一个想法：OoD样本是known-unknown还是unknown-unknown？另一个方法是除了检测正确的分类外，还要输出正确检测的概率。作者表示，这些都是改进错误、提高OoD检测性能的一些思路。</p>
<p>作者希望，任何新的检测方法都能在本文研究中选择的各种任务和架构上进行测试。一个基本的展示包括下面的数据集：MNIST,CIFAR,IMDB以及tweets，因为仅针对视觉的展示可能不合适其他的结构或数据集。报告AUPR和AUROC的值非常重要，底层分类器的准确性也很重要，因为一个恒负的分类器在错误检测中会得到一个最大的AUPR(假定错误是正类)。同时，未来的研究不需要使用本文的精确值进行比较。机器学习系统在不断演化，因此没必要把精确的架构和本文的数据集捆绑到一起评估，人们可以简单的选择各种数据集和架构，很可能就和本文一样，然后将他们的检测方法和基于softmax预测概率的检测器进行比较。在OoD检测这个未充分探索的挑战中，作者对试图超越baseline的其他研究者给出了以上建议。</p>
<h2 id="conclusion">Conclusion</h2>
<p>本文展示了一个softmax预测概率的baseline，可以检测各种架构、数据集上的错误分类样本和OoD样本。然后，本文提出异常模块，这个模块为测试集中正常样本和异常样本的区分提供了较高的分数。异常模块的实验表明，baseline在某些情况下是可以被打败的，这意味着未来是有研究空间的。作者希望其他研究者探索更好地预测异常样本的架构，或者追寻更可靠的检测分类错误和OoD的方法，因为知道一个机器学习系统什么时候失败对我们是非常重要的。</p>
]]></content>
      <categories>
        <category>OoD Detection</category>
      </categories>
      <tags>
        <tag>Reading Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 地球的故事复习笔记</title>
    <url>/2021/06/14/earthStory/</url>
    <content><![CDATA[<h2 id="宇宙大爆炸">宇宙大爆炸</h2>
<ul>
<li>宇宙可观测的范围：直径约930亿光年</li>
<li>奥伯斯佯谬：如果宇宙是无限稳态的，夜晚的天空会像白天一样明亮
<ul>
<li>解释1：因为宇宙有黑暗星体、尘埃和气体阻隔；但这些最终会加热并发出自己的光</li>
<li>解释2：宇宙是有限的；但这样宇宙会坍塌，边缘星体会被拉向内部</li>
<li>猜想：宇宙大爆炸模型：模型是有限的，正在膨胀的；可以解释奥伯斯佯谬</li>
</ul></li>
<li>电磁辐射——波粒二象性
<ul>
<li>电磁波的能量传输：波有特定波长，与频率成反比</li>
<li>辐射表现为光子流：能量是<span class="math inline">\(E=hf\)</span>，短波能量高</li>
</ul></li>
<li>元素的特征谱线
<ul>
<li>元素电子跃迁会吸收或释放特定波长的光</li>
<li>恒星会发出不同的（连续）波长的电磁辐射</li>
<li>恒星外层大气中低温气体吸收特定光子，导致光谱产生吸收谱线（暗谱线）</li>
<li>通过特征谱线，可以判定是什么元素</li>
<li>通过光的强度，可以计算出该元素的浓度</li>
<li>通过太阳光可以探测太阳光球层的成分</li>
</ul></li>
<li>红移
<ul>
<li>其他星系的光谱也有暗谱线</li>
<li>这些光谱的暗线的相对分布类似，说明各星系含有的元素一样</li>
<li>越远的星系，暗线整体红移，说明越远的星系以越大的速度远离我们（多普勒效应）</li>
<li>证明了宇宙正在膨胀</li>
</ul></li>
<li>测量星体和地球的距离
<ul>
<li>三角测量法：只适合测量星系中近距离的天体，不适合确定宇宙的膨胀</li>
<li>标准烛光法：距离越远，能力越分散，亮度越低</li>
<li>大小和亮度法：测量最遥远的天体</li>
</ul></li>
<li>哈勃定律：<span class="math inline">\(v=HL\)</span>
<ul>
<li>H是哈勃常数，也是宇宙年龄的倒数。因为宇宙大爆炸时速度快的星体，现在离我们会更远。</li>
<li>所有的星体都在远离不代表我们是宇宙的中心，因为远离是相对的位置关系</li>
<li>速度可以由红移确定，距离由标准烛光法和星系大小确定</li>
<li>计算出哈勃常数，从而得到宇宙的年龄为137亿年</li>
</ul></li>
<li>宇宙大爆炸的证据
<ul>
<li>星系的光谱红移</li>
<li>宇宙背景辐射（黑体辐射）</li>
<li>宇宙中的H/He比值</li>
</ul></li>
<li>黑体辐射
<ul>
<li>黑体指的是入射电磁波吸收率100%，但仍要对外辐射</li>
<li>宇宙各方向有强度不变的背景微波辐射，大约是3K</li>
</ul></li>
<li>宇宙的组成：73%的暗能量、23%的暗物质、4%的原子</li>
</ul>
<h2 id="元素起源">元素起源</h2>
<ul>
<li>地球陆壳元素丰度排序：O、Si、Al、Fe、Ca</li>
<li>地球上元素丰度排序：Fe、O、Si、Mg、S、Ni、Ca、Al</li>
<li>太阳中元素丰度排序：H、He、O（Fe含量不低）</li>
<li>原子结构：原子核、质子、中子、电子
<ul>
<li>质量看原子核</li>
<li>大小看电子云大小</li>
<li>上标质量数，下标质子数</li>
</ul></li>
<li>四种基本力： 引力、电磁力、弱力、强力。
<ul>
<li>强力和电磁力使原子稳定。</li>
<li>核素表的稳定带：强力可以把原子核的质子和中子稳定结合在一起</li>
<li>核素表不稳定的区域会发生核反应，例如电子捕获把质子变中子、<span class="math inline">\(\beta\)</span>衰变把中子转化为质子和电子、<span class="math inline">\(\alpha\)</span>衰变放出He、裂变等</li>
</ul></li>
<li>同位素：质子数相同</li>
<li>同重核素：质量数相同</li>
<li>质能方程：<span class="math inline">\(E=mc^2\)</span></li>
<li>质量陷阱：没有质量数是5和8的核素
<ul>
<li>宇宙大爆炸形成了大部分氢氦，和少量锂铍硼</li>
<li>宇宙中的H/He质量比约为2.5</li>
<li>H和He占宇宙物质质量的99%以上</li>
</ul></li>
<li>核聚变只能到56Fe
<ul>
<li>结合能最高点，在此前放热，此后吸热</li>
<li>更重的核素形成靠的是超新星爆发</li>
<li>星系中元素的分布也受超新星爆发影响</li>
</ul></li>
<li>恒星越大，合成元素越多，恒星寿命越短；太阳是质量小的恒星，可以由很多元素组成但不形成重元素。</li>
<li>r-过程：快中子捕获</li>
<li>s-过程：慢中子捕获</li>
<li>p-过程：如质子捕获</li>
<li>这些过程的证据
<ul>
<li>恒星燃烧的唯一能量来源</li>
<li>超新星爆发已被观测</li>
<li>元素相对丰度计算与观测结果相对应</li>
<li>超新星爆发遗迹中观察到锝的吸收线</li>
<li>太阳系物质中短寿期放射性核素证据</li>
</ul></li>
</ul>
<h2 id="矿物和有机分子形成">矿物和有机分子形成</h2>
<ul>
<li>稳定分子形成的条件
<ul>
<li>原子的电子层排满达到电荷平衡（离子键、共价键）</li>
<li>原子间结合大小适宜</li>
</ul></li>
<li>分子大小
<ul>
<li>电子层多的原子大</li>
<li>同电子层的原子，正电荷数越大，原子越小</li>
<li>阴离子比阳离子大</li>
</ul></li>
<li>矿物结构取决于阴离子排列方式和阳离子如何填充到阴离子之间</li>
<li>两类分子：无机和有机
<ul>
<li>无机分子构成大多数行星物质，形成矿物</li>
<li>矿物是固态的天然无机物，有对称结构</li>
<li>有机分子含有C-H键</li>
<li>矿物对宜居性很重要</li>
</ul></li>
<li>地球化学亲和力对物质分类
<ul>
<li>亲气：H、He、N、惰性气体</li>
<li>亲石：碱金属、碱土金属、卤族元素、B、O、Al、Si、Ti、Cr、Mn等</li>
<li>亲铜：Cu、Zn、Ga、Ag、Cd、Pb等</li>
<li>亲铁：Fe、Co、Ni等</li>
</ul></li>
<li>硅氧四面体
<ul>
<li>岛装硅酸盐：橄榄石(<span class="math inline">\(\[Fe,Mg\]_2SiO_4\)</span>)</li>
<li>单链硅酸盐：辉石(<span class="math inline">\(\[Ca,Mg,Fe^{+2}\]_2SiO_4\)</span>)</li>
<li>双链硅酸盐：角闪石(有<span class="math inline">\(Si_4O_{11}\)</span>)</li>
<li>层状硅酸盐：云母(有<span class="math inline">\(Si_2O_5\)</span>)</li>
<li>架状硅酸盐：长石(<span class="math inline">\(KAlSi_3O_8\)</span>)、石英（<span class="math inline">\(SiO_2\)</span>）</li>
</ul></li>
<li>矿物的密度
<ul>
<li>密度决定于原子核粒子平均数和原子排列的紧密程度</li>
<li>通过密度可以推测化学组成</li>
<li>月球岩浆洋的分异因为斜长石密度差异</li>
</ul></li>
<li>物质的状态：固、液、气、等离子</li>
<li>矿物的密度和挥发性对行星形成很重要
<ul>
<li>行星内部圈层结构</li>
<li>太阳系内物质的分布</li>
</ul></li>
<li>与生命有关的四种有机分子：碳水化合物、脂肪、蛋白质、核酸</li>
</ul>
<h2 id="太阳系起源">太阳系起源</h2>
<ul>
<li>太阳和地球的年龄：45.6亿年</li>
<li>八（九）大行星：水、金、地、火、木、土、天王、海王、（冥王）</li>
<li>太阳系的规律
<ul>
<li>所有行星都接近黄道面</li>
<li>公转方向相同</li>
<li>金星自转方向是和其他七大行星反的</li>
<li>波得定律：行星离太阳的距离大约是前一行星距离的1.7倍——预言了天王星和谷神星轨道位置</li>
<li>内行星比较小，外行星比较大</li>
<li>行星质量排序：木、土、海王、天王、地、金、火、水</li>
<li>行星密度：地、水、金、火、海王、木、天王、土</li>
</ul></li>
<li>碳质球粒陨石和太阳有着相似的化学成分</li>
<li>球粒陨石和地球有相同的年龄，主要金属元素是Mg、Si、Fe</li>
<li>太阳系物质组成
<ul>
<li>外太阳系行星主要是冰和气体</li>
<li>内太阳系行星主要是岩石和金属</li>
<li>分子的挥发性差异，距离太阳越远，温度越低</li>
<li>内太阳系行星主要是普通球粒陨石，相比于碳质球粒陨石亏挥发性元素</li>
</ul></li>
<li>太阳、球粒陨石元素相对丰度受控于
<ul>
<li>元素在太阳系中的丰度</li>
<li>分子的挥发性</li>
</ul></li>
<li>K/U比
<ul>
<li>K挥发性比U大，其他性质类似，因此可以衡量挥发性</li>
<li>越远离太阳，比值越大</li>
<li>月球K/U比非常小（比内太阳系行星小），因为月球是大撞击过程形成，丢失了挥发性元素</li>
</ul></li>
<li>类地行星：水星、金星、地球、火星</li>
<li>类木行星：木星、土星、海王星</li>
<li>太阳系起源小节
<ul>
<li>短寿命的超新星生成并分散各种元素</li>
<li>在星云中形成有机无机分子</li>
<li>长寿的太阳系在这些恒星出生地中形成</li>
</ul></li>
</ul>
<h2 id="定年">定年</h2>
<ul>
<li>史坦诺定律
<ul>
<li>地层重叠法则：若不考虑底层扰动，上面的地层相对年轻</li>
<li>原始水平法则：形成的层在一个水平线上</li>
</ul></li>
<li>可以用化石比较不同地层的相对年龄（地层柱状图）</li>
<li>放射性衰变基本定律：单位时间内衰变概率固定</li>
<li>半衰期乘以衰变常数=ln2</li>
<li>同位素定年的必要条件
<ul>
<li>封闭体系</li>
<li>衰变速率恒定</li>
<li>子体初始含量已知，最好是0</li>
<li>或者母体初始含量已知</li>
</ul></li>
<li>等时线定年
<ul>
<li>等时线方程的截距是子体初始值</li>
<li>斜率正相关于年龄（<span class="math inline">\(e^{\lambda\
t}-1\)</span>）</li>
<li>横坐标是母体同位素，纵坐标是子体同位素</li>
</ul></li>
<li>月球年龄和地球差不多</li>
<li>短寿命核素定年
<ul>
<li>横坐标是27Al和24Mg比值</li>
<li>纵坐标是26Mg和24Mg比值</li>
<li>截距是26Mg和24Mg的初始比值</li>
<li>斜率是26Al和27Al的初始比值</li>
<li>利用短寿命核素定年得到的是相对年龄</li>
</ul></li>
</ul>
<h2 id="地球的内部结构">地球的内部结构</h2>
<ul>
<li>地球的圈层结构
<ul>
<li>地壳：固相</li>
<li>上地幔：固相</li>
<li>下地幔：固相</li>
<li>外核：液相、气相</li>
<li>内核：固相</li>
</ul></li>
<li>地核半径是地球半径的一半，是铁核</li>
<li>地震波
<ul>
<li>P波，纵波，地壳、地幔、地核速度依次更快</li>
<li>S波，横波，振动方向和传播方向垂直，无法在外核传播，比p波慢，内核、地壳、地幔速度依次更快</li>
</ul></li>
<li>不连续面
<ul>
<li>莫霍不连续面：地壳和地幔</li>
<li>古登堡不连续面：地幔和地核</li>
<li>莱曼不连续面：外核和内核</li>
</ul></li>
<li>亲铁和亲铜元素主要在地核中</li>
<li>亲石元素主要在地幔和地壳中</li>
<li>亲岩浆元素主要在大陆地壳中</li>
<li>球粒陨石的证据均匀吸积表明核在吸积后形成</li>
<li>地核的形成是金属和硅酸盐的分离（不混溶）
<ul>
<li>是行星分异的正常过程</li>
<li>导致了地球上亲铁元素和亲石元素的基本分离</li>
</ul></li>
<li>地核形成的时间
<ul>
<li>Hf-W体系，前者亲石，后者亲铁</li>
<li>地核形成于地球形成后30 Ma内</li>
</ul></li>
<li>地壳的形成
<ul>
<li>部分熔融导致硅酸盐物质不断分离</li>
<li>大陆地壳早期形成，花岗质岩浆（65%-70%
SiO2）和演化沉积物组成，经历多次熔融，可能还有拆沉作用</li>
<li>大洋地壳年轻（小于150 Ma），玄武质岩浆（50%
SiO2），由地幔减压熔融产生</li>
</ul></li>
<li>大气圈的形成
<ul>
<li>猜测一：晚期富挥发分的彗星的加入，错误</li>
<li>猜测二：地球内部的去气作用，正确</li>
<li>形成于地球形成后30 Ma内</li>
</ul></li>
<li>亲岩浆元素在地壳中聚集</li>
</ul>
<h2 id="地球的邻居">地球的邻居</h2>
<ul>
<li>造成陨石坑的撞击体的来源
<ul>
<li>小行星带</li>
<li>来自柯依波带的彗星</li>
<li>来自奥尔特云的彗星</li>
</ul></li>
<li>月球撞击坑是陨石而不是火山</li>
<li>撞击密度大的区域更老</li>
<li>撞击坑约是撞击体的直径的20倍</li>
<li>月球相对于行星的质量是很大的</li>
<li>月球贫铁、贫挥发份，月球很古老，只比太阳系晚60-125Ma</li>
<li>月球形成模型
<ul>
<li>捕获说：无法解释O、Si同位素比值的相似性，且月球质量很大</li>
<li>共生说：不能解释密度差异大，月球贫铁</li>
<li>裂解说：不能解释地月系统的角动量</li>
<li>大撞击理论：很好的解释贫铁、贫挥发；可以解释和地球物质的相似</li>
<li>现在认为是大撞击和月球吸积下形成</li>
</ul></li>
<li>斜长岩：钙长石矿物组成的岩石</li>
<li>月球的高地斜长岩非常古老，月海玄武岩年轻得多且亏Eu（月幔亏Eu）</li>
<li>月球岩浆洋形成理论</li>
<li>地球早期可能像月球一样形成岩浆洋
<ul>
<li>热量源地球大，包括撞击、衰变、地核形成</li>
<li>热损耗地球小，看表面积比体积</li>
<li>地球压力比月球大</li>
</ul></li>
<li>地球没有形成斜长石地壳的主要原因是因为斜长石的稳定压力低</li>
</ul>
<h2 id="宜居性">宜居性</h2>
<ul>
<li>地球的宜居性
<ul>
<li>液态水</li>
<li>温度调控</li>
<li>磁场的保护</li>
</ul></li>
<li>液态水
<ul>
<li>岩石证据显示38亿年前就有液态水</li>
<li>锆石年龄可达到44亿年（同位素定年），16O比18O更容易蒸发</li>
<li>古老的沉积物中有O同位素的变化，是水循环的结果</li>
<li>锆石的钛含量说明其形成于750℃的环境（酸性岩浆环境）</li>
<li>核幔壳幔分异过程中挥发分集中在表面、水不流失到外太空这是两个形成丰富地表水的关键</li>
<li>水陷阱保护了地球的水</li>
</ul></li>
<li>磁场保护了大气层</li>
<li>恒星表面的温度受控于
<ul>
<li>恒星光度</li>
<li>行星恒星距离</li>
<li>行星表明反射率</li>
<li>温室效应（CO2、H20、CH4）</li>
</ul></li>
<li>金星的温室效应很强（C02）</li>
<li>温室效应的能力，CH4比CO2高得多，但是CO2比CH4多得多，所以地球最重要的温室气体是CO2</li>
<li>地球的早期温室气体是CH4，现在是CO2</li>
<li>火山气体是CO2的稳定来源</li>
<li>岩石的风化反应降低了大气中C02的浓度</li>
<li>大气C02含量增加使得：大气温度升高、水蒸气含量增加、酸雨增多，从而风化加强，海洋中Ca离子输入量增加，CaCO3沉淀增加，大气C02浓度降低</li>
<li>大气C02含量降低使得：大气温度降低、水蒸气含量减少、酸雨减少，从而风化减弱，海洋中Ca离子输入量减少，CaCO3沉淀减少，大气C02浓度增加</li>
</ul>
<h2 id="板块构造">板块构造</h2>
<ul>
<li>魏格纳提出大陆漂移说
<ul>
<li>解释了很多现象，如中龙化石不同洲相同、非洲区域看到冰川运动遗迹等</li>
<li>大陆地壳（刚性）如何在大洋地壳（刚性）和地幔（刚性）之间进行移动，动力在哪来</li>
</ul></li>
<li>海底扩张
<ul>
<li>大西洋中有很大的洋中脊的隆起</li>
<li>洋中脊两侧出现对称的正反磁异常条带</li>
<li>离洋中脊越远，沉积物越厚，底部的沉积物越老</li>
<li>洋壳年龄不超过200Ma，因为老的洋壳消失于俯冲带，进入了地幔</li>
<li>俯冲带、洋中脊有地震活动</li>
<li>转换断层：洋中脊之间连接的地方，和走滑断层有区别</li>
</ul></li>
<li>板块
<ul>
<li>指的是岩石圈，岩石圈下面的部分地幔是软流层</li>
<li>板块不是地壳，岩石圈在软流层上移动</li>
<li>一组朝同一个方向移动的岩石。可以同时有大洋和大陆，也可以只有一种</li>
</ul></li>
<li>板块构造理论
<ul>
<li>地球表层由一系列板块组成</li>
<li>洋壳形成在大洋中脊，岩浆作用形成了洋壳</li>
<li>洋壳消失在汇聚板块边缘，通过俯冲回到地幔</li>
<li>大陆不发生俯冲</li>
</ul></li>
<li>大部分板块构造活动都是在海洋中发生的</li>
<li>三种板块边界
<ul>
<li>转换边界，如转换断层</li>
<li>离散边界，如洋中脊</li>
<li>会聚边界，包括大洋-大洋（日本）、大洋-大陆（安第斯山脉）、大陆-大陆（喜马拉雅山脉）。前两者是俯冲，第二个会形成大陆弧，最后一个是大陆变形。</li>
</ul></li>
<li>一些板块实例：亚欧板块、太平洋板块、非洲板块、南美洲板块、北美洲板块、南极洲板块等</li>
</ul>
<h2 id="地幔对流">地幔对流</h2>
<ul>
<li>地幔虽然是固态，但可以流动</li>
<li>岩石在高压高温时缓慢施加应力可以流动</li>
<li>固体的变形
<ul>
<li>弹性形变：可逆</li>
<li>断裂：不可逆</li>
<li>塑性变形：不可逆</li>
</ul></li>
<li>地幔流动的证据：
<ul>
<li>陆壳和洋壳均衡补偿（陆壳密度比洋壳小，引起高程变化）</li>
<li>冰川溶解后地壳均衡回弹</li>
</ul></li>
<li>地幔对流
<ul>
<li>瑞利数指示对流是否会发生（大于2000）</li>
<li>粘度和热传导系数小有利于对流发生</li>
<li>上升流由地幔柱代表，下降流与俯冲带相关</li>
</ul></li>
<li>上地幔存在温差的证据
<ul>
<li>洋壳成分和洋中脊深度相关</li>
<li>浅的洋中脊由热的地幔形成，洋壳厚</li>
<li>深的洋中脊远离热点，显示出较冷的地幔区域</li>
</ul></li>
</ul>
<h2 id="地球化学循环">地球化学循环</h2>
<ul>
<li>洋中脊
<ul>
<li>3He来自洋中脊玄武岩岩浆</li>
<li>洋中脊的热液循环对维持海水化学组成很重要</li>
<li>热液作用使得大洋地壳形成富挥发分的矿物：绿泥石、角闪石、蛇纹石，都有羟基，富水</li>
<li>洋中脊的热量给生物提供了能量</li>
<li>洋中脊把水分和其他成分输送到俯冲带，使得火山活动和大陆生长能够进行</li>
<li>洋中脊在水碳循环中起重要作用，保证了地球气候长期稳定</li>
<li>洋中脊可能在地球生命起源起了重要作用，为宇宙其他天体生命存在提供启示</li>
<li>快速扩张的洋中脊可形成火山，慢速扩张的洋中脊可形成深谷</li>
<li>洋中脊火山岩浆占全球的80%</li>
<li>海水与岩浆发生作用形成黑烟囱，温度可达400℃（因为海底高压）</li>
<li>海水的3He来自于地幔</li>
<li>热液的Fe、Mn、Li含量高</li>
</ul></li>
<li>俯冲带
<ul>
<li>海洋沉积物、洋壳（玄武质）、上地幔（橄榄岩）水分依次减少</li>
<li>汇聚型板块边缘岩浆富水的证据有：矿物的熔融包裹体含有大于5%的水、汇聚型板块边缘可形成富硅岩浆、汇聚型板块边缘多爆发式火山喷发</li>
<li>汇聚板块边缘喷发的岩浆中有10Be说明沉积物俯冲进入地幔</li>
<li>俯冲再循环物质不能有效地均一化到地幔中</li>
</ul></li>
<li>重点
<ul>
<li>板块构造是地球化学循环的一种方式</li>
<li>洋中脊是海水和洋壳的化学反应器：海水通过洋中脊保持反应平衡、洋壳称为挥发分载体、</li>
<li>挥发分向俯冲带迁移导致火山爆发和陆壳的构建</li>
</ul></li>
</ul>
<h2 id="生命起源和改造">生命起源和改造</h2>
<ul>
<li>38亿年前的岩石发现了生物标志物不代表38亿年前就有生命</li>
<li>30亿年前有生命，最古老的也许在35亿年前</li>
<li>水的形成（44亿年前）和生命的诞生有很长的间隔，10亿年。</li>
<li>生命对地表的改造是以一系列能源革命为标志的
<ul>
<li>第一次能源革命：做自己的食物，自养微生物，不需要自由氧</li>
<li>第二次能源革命：有氧光合作用</li>
<li>第三次能源革命：有氧呼吸</li>
<li>第四次能源革命：多细胞</li>
</ul></li>
<li>大气从无氧到有氧的证据：硫的四个同位素非质量分流在深紫外线照射下明显，当氧气含量很高时，大气将阻挡紫外透射，光化学反应不产生非质量分馏，从而可以推测大气中氧含量</li>
<li>新生代：哺乳动物时代</li>
<li>中生代：爬行动物时代</li>
<li>古生代：两栖动物、鱼类、无脊椎动物时代</li>
<li>鱼类时代开始形成煤和石油</li>
<li>最早的化石从古生代开始</li>
<li>温室效应使得海水酸化</li>
<li>减少二氧化碳浓度的方法
<ul>
<li>减排</li>
<li>捕获大气中的CO2，需要大量代价</li>
</ul></li>
<li>大气中的<span class="math inline">\(\delta^{13}
C\)</span>越来越小和全球排放有关</li>
</ul>
]]></content>
      <categories>
        <category>地球的故事</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第三章-数据链路层</title>
    <url>/2021/11/25/network3/</url>
    <content><![CDATA[<h2 id="数据链路层的功能">数据链路层的功能</h2>
<ul>
<li>为网络层提供服务
<ul>
<li>无确认无连接服务
<ul>
<li>适合误码率低的以太网</li>
</ul></li>
<li>有确认无连接服务
<ul>
<li>适合误码率高的无线通信</li>
</ul></li>
<li>有确认有连接服务
<ul>
<li>适合可靠性要求高的通信</li>
</ul></li>
</ul></li>
<li>链路管理
<ul>
<li>连接的建立、维持、释放的管理</li>
</ul></li>
<li>帧的定界、同步、透明传输
<ul>
<li>帧定界：确定帧的界限，即起始和终止，一般需要定界符</li>
<li>帧同步：确定帧的起始和终止，帧定界的另一种说法</li>
<li>透明传输：帧可以传输任意数据，比如定界符本身</li>
</ul></li>
<li>流量控制
<ul>
<li>限制发送方数据流量，使得发送速率不超过接收速率</li>
</ul></li>
<li>差错控制
<ul>
<li>发送方确定接收方是否正确收到数据的方法</li>
<li>错误包括位错和帧错
<ul>
<li>位错：CRC检错，ARQ重传；FEC纠错</li>
<li>帧错：引入定时器和编号机制，防止帧的重复、失序、丢失</li>
</ul></li>
</ul></li>
</ul>
<h2 id="组帧">组帧</h2>
<ul>
<li>字符计数法
<ul>
<li>方法：帧的第一个字节指出整个帧的字符数</li>
<li>缺点：计数字段出错，后果严重</li>
</ul></li>
<li>字符填充的首尾定界符法
<ul>
<li>方法：通过首尾定界符SOH和EOT来定界</li>
<li>透明传输实现：如果信息码出现定界符或转义符，则在其前面插入一个转义符ESC</li>
<li>缺点：复杂、难兼容</li>
</ul></li>
<li>零比特填充的首尾标志法（常用）
<ul>
<li>方法：使用0111 1110作为首尾的标志字符</li>
<li>透明传输实现：如果信息码出现连续5个1，则在后面插入1个0</li>
<li>优点：容易由硬件实现，比字符填充法的性能好</li>
</ul></li>
<li>违规编码法（常用）
<ul>
<li>方法：采用冗余的编码方式，未被使用的编码作为定界符
<ul>
<li>比如2个比特位编码0和1，00表示0，11表示1，冗余的01或10作为定界符</li>
</ul></li>
<li>透明传输：不需要填充技术</li>
</ul></li>
</ul>
<h2 id="差错控制">差错控制</h2>
<p><em>前面提到，差错控制包括位错和帧错，本节讨论位错的控制</em></p>
<h3 id="检错编码">检错编码</h3>
<h4 id="奇偶检验">奇偶检验</h4>
<ul>
<li>方法：添加1个校验位使得1的个数为奇数或偶数</li>
<li>奇校验：1的个数为奇数</li>
<li>偶校验：1的个数为偶数</li>
<li>缺点：只能检查出奇数位错</li>
</ul>
<h4 id="循环冗余编码">循环冗余编码</h4>
<ul>
<li>CRC编码
<ul>
<li>输入：m位信息码和一个r阶多项式G(x)</li>
<li>操作：信息码左移r位，模二除法（用异或操作代替加减操作），除以G(x)对应比特数</li>
<li>输出：余数就是r位校验位，和m位信息位合并为CRC码</li>
</ul></li>
<li>检错：CRC码可以模二整除G(x)对应比特数</li>
<li>纠错：CRC码可以纠错，但数据链路层只用到检错功能</li>
</ul>
<h3 id="纠错编码">纠错编码</h3>
<p>本节介绍海明编码，方法（检错纠错1位）如下</p>
<ul>
<li>确定海明码位数
<ul>
<li>找到最小的满足<span class="math inline">\(n+k\leq
2^k-1\)</span>的<span class="math inline">\(k\)</span>作为校验位长度</li>
<li>如果需要检错2位，则校验位长度为<span class="math inline">\(k+1\)</span></li>
</ul></li>
<li>确定各校验位插入位置（下标一律从<span class="math inline">\(1\)</span>开始）
<ul>
<li>把校验位<span class="math inline">\(P_i\)</span>插入到从右开始，第<span class="math inline">\(2^{i-1}\)</span>的位置</li>
</ul></li>
<li>确定各信息位用到的校验位
<ul>
<li>设信息位<span class="math inline">\(D_j\)</span>的位置为海明码右边开始第<span class="math inline">\(i\)</span>个，则<span class="math inline">\(i\)</span>的二进制串可确定该信息位用到的检验位
<ul>
<li>比如信息位<span class="math inline">\(D_3\)</span>在海明码右边第<span class="math inline">\(6\)</span>个位置，二进制为<span class="math inline">\(110\)</span>，则用到校验位<span class="math inline">\(P_2,P_3\)</span></li>
</ul></li>
</ul></li>
<li>计算各校验位
<ul>
<li>每个校验位 = 所有用到该校验位的信息位的异或</li>
</ul></li>
<li>纠错方法
<ul>
<li><span class="math inline">\(k\)</span>位校验位，分别与用到每个校验位的信息位的异或结果进行异或，得到<span class="math inline">\(k\)</span>位纠错码</li>
<li>全<span class="math inline">\(0\)</span>表示无错，否则表示出错的海明码的位置</li>
</ul></li>
</ul>
<p>注： + 海明距指的是两个合法海明编码的最短路径，比如<span class="math inline">\(111\)</span>和<span class="math inline">\(000\)</span>距离是3 + 纠错<span class="math inline">\(k\)</span>位，海明距不小于<span class="math inline">\(2k+1\)</span>；检错<span class="math inline">\(k\)</span>，海明距不小于<span class="math inline">\(k+1\)</span></p>
<h2 id="流量控制与可靠传输机制">流量控制与可靠传输机制</h2>
<h3 id="流量控制">流量控制</h3>
<h4 id="停止等待流量控制">停止等待流量控制</h4>
<ul>
<li>发送方每次发送一帧，接收到应答信号后才能发送下一帧</li>
<li>接收方接收一帧后，需要发送应答信号才能接收下一帧</li>
</ul>
<h4 id="滑动窗口流量控制">滑动窗口流量控制</h4>
<ul>
<li>发送窗口：发送方维护的允许连续发送的帧序号</li>
<li>接收窗口：接收方维护的允许连续接收的帧序号</li>
<li>窗口滑动步骤：发送方发送帧、接收窗口滑动、接收方发确认帧、发送窗口滑动</li>
<li>特性
<ul>
<li>接收窗口为1时，帧有序接收</li>
<li>数据链路层的滑动窗口大小固定，不同于传输层的滑动窗口</li>
</ul></li>
</ul>
<h3 id="可靠传输机制">可靠传输机制</h3>
<h4 id="基本介绍">基本介绍</h4>
<ul>
<li>常用协议：自动重传请求ARQ（数据链路层和传输层都可以用到的协议）
<ul>
<li>停止等待ARQ</li>
<li>连续ARQ
<ul>
<li>后退N帧ARQ</li>
<li>选择性重传ARQ</li>
</ul></li>
</ul></li>
<li>包括确认和超时重传两个机制
<ul>
<li>确认：接收方让发送方知道已正确接收的帧
<ul>
<li>一般采用捎带，把确认放在回复帧中</li>
<li>后退N帧ARQ采用累计确认，选择性重传ARQ不采用累计确认</li>
</ul></li>
<li>超时重传：发送方发送一个帧后开启一个计时器，到时间没有确认则重传
<ul>
<li>停止等待ARQ使用一个计时器</li>
<li>后退N帧ARQ使用一个计时器（记录的是第一个未收到确认的已发送帧的等待时间，超时后发送方重传所有未收到确认的发送帧）</li>
<li>选择性重传ARQ对每个发送帧都设置一个计时器（超时后发送方只重传该超时帧）</li>
</ul></li>
</ul></li>
<li>设置缓存区
<ul>
<li>发送方缓存区：备份帧用于超时重传</li>
<li>接收方缓存区：备份帧用于判定重复帧</li>
</ul></li>
</ul>
<h4 id="停止等待arq协议">停止等待ARQ协议</h4>
<ul>
<li>流量控制：发送窗口为<span class="math inline">\(1\)</span>，接收窗口为<span class="math inline">\(1\)</span>，编号比特数满足<span class="math inline">\(2^n\geq 1+1\)</span>，即<span class="math inline">\(1\)</span>位</li>
<li>差错控制
<ul>
<li>无差错情况
<ul>
<li>发送方：发送发送帧、等待确认帧</li>
<li>接收方：接收发送帧、发送确认帧</li>
</ul></li>
<li>发送帧丢失情况：接收方收不到，发送方超时重传</li>
<li>发送帧破坏情况：接收方丢弃，发送方超时重传</li>
<li>确认帧丢失或破坏情况：发送方超时重传，接收方丢弃重复帧并重发确认帧</li>
<li>确认帧迟到情况：发送方超时重传，接收方丢弃重复帧并重发确认帧，发送方丢弃重复的确认帧</li>
</ul></li>
</ul>
<h4 id="后退n帧arq协议gbn协议">后退N帧ARQ协议(GBN协议)</h4>
<ul>
<li>流量控制：发送窗口<span class="math inline">\(W_T&gt;
1\)</span>，接收窗口为<span class="math inline">\(1\)</span>，编号比特数满足<span class="math inline">\(2^n\geq W_T+1\)</span>
<ul>
<li>对编号比特数限制的理解（停止等待协议和SR协议同理）
<ul>
<li>发送方发送<span class="math inline">\(W_T\)</span>个帧，到达接收方，但确认帧丢失</li>
<li>超时后发送方重传<span class="math inline">\(W_T\)</span>个帧，此时接收方必须能根据序号判断出帧是旧帧还是新帧</li>
</ul></li>
</ul></li>
<li>差错控制：
<ul>
<li>无差错情况
<ul>
<li>发送方：发送窗口内的帧连续发送、等待确认帧</li>
<li>接收方：按序接收发送帧，发送确认帧，告诉接收方到该帧为止的帧都已经正确接收（<strong>不一定每次收到正确帧都确认，可能捎带的方式，即接收方在发送数据时捎带确认</strong>），</li>
</ul></li>
<li>发送窗口的帧全部丢失情况：接收方收不到，发送方超时重传</li>
<li>发送窗口的帧部分丢失或破坏
<ul>
<li>超过当前接收序号的正确帧：接收方丢弃，并重复发送确认帧，发送方超时重传</li>
<li>错误帧：接收方丢弃，发送方超时重传</li>
</ul></li>
<li>确认帧丢失或破坏情况：发送方超时重传，接收方丢弃重复帧并重发确认帧</li>
<li>确认帧迟到情况：发送方超时重传，接收方丢弃重复帧并重发确认帧，发送方丢弃重复的确认帧</li>
</ul></li>
</ul>
<h4 id="选择重传arq协议sr协议">选择重传ARQ协议(SR协议)</h4>
<ul>
<li>流量控制：发送窗口<span class="math inline">\(W_T&gt;
1\)</span>，接收窗口为<span class="math inline">\(W_R&gt;
1\)</span>，编号比特数满足<span class="math inline">\(2^n\geq
W_T+W_R\)</span>
<ul>
<li>显然<span class="math inline">\(W_R\leq
W_T\)</span>，否则无意义</li>
<li>默认情况是<span class="math inline">\(W_T=W_R\)</span></li>
</ul></li>
<li>设置缓冲区
<ul>
<li>注意和前面的缓存区不同</li>
<li>缓冲区的大小等于接收窗口大小</li>
<li>缓冲区的作用是接收无序到达的帧</li>
</ul></li>
<li>差错控制：
<ul>
<li>无差错情况
<ul>
<li>发送方：发送窗口内的帧连续发送、等待确认帧</li>
<li>接收方：如果接收到接受窗口中不按序的帧，放入缓冲区，并发送确认帧；如果接收到接收窗口中按序的帧，则把该帧和缓冲区按序的部分内容合并提交给上层，并发送确认帧</li>
</ul></li>
<li>发送窗口的某帧丢失情况：接收方收不到，发送方超时重传</li>
<li>发送窗口的某帧被破坏情况：接收方丢弃并发送否定帧NAK，要求发送方重传</li>
<li>确认帧丢失或破坏情况：发送方超时重传，接收方丢弃重复帧并重发确认帧</li>
<li>确认帧迟到情况：发送方超时重传，接收方丢弃重复帧并重发确认帧，发送方丢弃重复的确认帧</li>
</ul></li>
</ul>
<h4 id="信道效率">信道效率</h4>
<ul>
<li>发送周期
<ul>
<li>从开始发送数据到收到一个确认帧为止的时间</li>
<li>包括发送方传输时延、往返时延RTT、接收方处理的时间（一般忽略）、接收方确认的传输时延（非捎带情况一般忽略）</li>
</ul></li>
<li>信道利用率
<ul>
<li>发送方在一个发送周期内，有效的发送时间的占比</li>
</ul></li>
<li>信道吞吐量
<ul>
<li>信道利用率 <span class="math inline">\(\times\)</span>
发送方的发送速率</li>
</ul></li>
</ul>
<h2 id="介质访问控制">介质访问控制</h2>
<p><em>介质访问控制的任务是保证广播信道上两个结点的通信不受信道上其他结点的干扰</em></p>
<h3 id="信道划分">信道划分</h3>
<p><em>本节用到多路复用技术，把多个输入信道整合到一个复用通道中，是静态的信道划分方法</em></p>
<h4 id="频分多路复用fdm">频分多路复用FDM</h4>
<ul>
<li>频分：把物理信道的总带宽（这里带宽指可用的频率范围）划分，得到多个能传输单个信号的子信道
<ul>
<li>为了防止子信道的干扰，可以引入冗余的频段，即<strong>保护频带</strong></li>
</ul></li>
<li>多路复用方法：原始多个基带信号按各自的频率调制，然后进行波的叠加，形成复合信号</li>
<li>优点：充分利用带宽、技术成熟、实现容易</li>
<li>特点：划分空间，共享时间</li>
</ul>
<h4 id="时分多路复用tdm">时分多路复用TDM</h4>
<ul>
<li>时分：把物理信道划分为若干时间片</li>
<li>多路复用方法：多路子信道在某段时间内轮流分配使用时间片
<ul>
<li>统计时分多路复用STDM：对TDM改进，按需动态分配时间片，而不是轮流分配</li>
</ul></li>
<li>特点：划分时间，共享空间</li>
</ul>
<h4 id="波分多路复用wdm">波分多路复用WDM</h4>
<ul>
<li>本质是光的频分复用
<ul>
<li>光的带宽高，可以实现频分复用</li>
<li>光的频率高，一般用波长表示光，因此叫波分复用</li>
</ul></li>
</ul>
<h4 id="码分多路复用cdm">码分多路复用CDM</h4>
<ul>
<li>又叫码分多址CDMA</li>
<li>码分：把多个子信道的信息编码到一起，在一个物理信道上传输，在接收端再分解得到编码的各分量</li>
<li>码片：由发送一个比特的时间划分得到的更小的时间槽
<ul>
<li>发送多个比特来表示一个比特</li>
</ul></li>
<li>码片序列：给每个子信道指定码片序列，对应一个向量
<ul>
<li>比如码片序列<span class="math inline">\(0011\)</span>，对应向量<span class="math inline">\((-1,-1,1,1)\)</span>，且发送<span class="math inline">\(0011\)</span>表示发送<span class="math inline">\(1\)</span>，发送<span class="math inline">\(1100\)</span>表示发送<span class="math inline">\(0\)</span></li>
</ul></li>
<li>码片序列的设置要求
<ul>
<li>不同子信道对应的向量要求正交，规格化内积为0
<ul>
<li>比如<span class="math inline">\(A=(-1,-1,1,1)\)</span>和<span class="math inline">\(B=(1,-1,1,-1)\)</span></li>
<li>规格化内积为<span class="math inline">\(\frac{-1+1+1-1}{4}=0\)</span></li>
</ul></li>
</ul></li>
<li>码片序列的性质
<ul>
<li>码片序列的向量和自身向量的规格化内积为1
<ul>
<li>比如<span class="math inline">\(+A=(-1,-1,1,1)\)</span>和<span class="math inline">\(A=(-1,-1,1,1)\)</span></li>
<li>规格化内积为<span class="math inline">\(\frac{1+1+1+1}{4}=1\)</span></li>
</ul></li>
<li>码片序列的反向量和自身向量的规格化内积为-1
<ul>
<li>比如<span class="math inline">\(-B=(-1,1,-1,1)\)</span>和<span class="math inline">\(B=(1,-1,1,-1)\)</span></li>
<li>规格化内积为<span class="math inline">\(\frac{-1-1-1-1}{4}=-1\)</span></li>
</ul></li>
</ul></li>
<li>多路复用
<ul>
<li>输入时：各子信号的向量线性叠加为复合向量，形成复合信号
<ul>
<li>比如<span class="math inline">\(+A=(-1,-1,1,1)\)</span>和<span class="math inline">\(-B=(-1,1,-1,1)\)</span></li>
<li>线性叠加为<span class="math inline">\(+A-B=(-2,0,0,2)\)</span></li>
</ul></li>
<li>输出时：把复合向量和子信道的码片序列向量进行规格化内积，得到该子信道发送的子信号
<ul>
<li><span class="math inline">\(+A-B=(-2,0,0,2)\)</span>和<span class="math inline">\(A=(-1,-1,1,1)\)</span>的规格化内积为<span class="math inline">\(\frac{2+0+0+2}{4}=1\)</span></li>
<li><span class="math inline">\(+A-B=(-2,0,0,2)\)</span>和<span class="math inline">\(B=(1,-1,1,-1)\)</span>的规格化内积为<span class="math inline">\(\frac{-2+0+0-2}{4}=-1\)</span></li>
</ul></li>
</ul></li>
<li>特点：共享空间，共享时间</li>
</ul>
<h3 id="随机访问">随机访问</h3>
<ul>
<li>本节的协议都是争用型协议，是动态的随机信道访问协议
<ul>
<li>争用：广播信道被转化为点对点信道，用户根据自己发送信息的意愿争取信道的使用。</li>
<li>动态：不对信道作静态统一的划分，不共享时间也不共享空间，可能发生冲突</li>
</ul></li>
</ul>
<h4 id="aloha协议">ALOHA协议</h4>
<ul>
<li>纯ALOHA协议
<ul>
<li>思想
<ul>
<li>数据直接发送，一段时间内未收到确认则认为有冲突（碰撞）</li>
<li>若冲突则每个帧时间都以p概率重传，直到成功</li>
</ul></li>
<li>性能
<ul>
<li>设一个帧平均发送时间为<span class="math inline">\(T_0\)</span>、网络负载（<span class="math inline">\(T_0\)</span>时间内发送的平均总帧数）为<span class="math inline">\(G\)</span></li>
<li>则网络吞吐量（<span class="math inline">\(T_0\)</span>时间内成功发送的平均帧数）为<span class="math inline">\(Ge^{-2G}\)</span>、最大吞吐量为<span class="math inline">\(\frac{1}{2e}=0.184\)</span>，当<span class="math inline">\(G=0.5\)</span>时取到</li>
</ul></li>
</ul></li>
<li>时隙ALOHA协议
<ul>
<li>思想
<ul>
<li>把时间划分为等长时隙，帧在时隙开始时发送，在时隙内完成发送</li>
<li>若冲突则每个时隙都以p概率重传，直到成功</li>
</ul></li>
<li>性能
<ul>
<li>设时隙为<span class="math inline">\(T_0\)</span>、网络负载（<span class="math inline">\(T_0\)</span>时间内发送的平均总帧数）为<span class="math inline">\(G\)</span></li>
<li>则网络吞吐量（<span class="math inline">\(T_0\)</span>时间内成功发送的平均帧数）为<span class="math inline">\(Ge^{-G}\)</span>、最大吞吐量为<span class="math inline">\(\frac{1}{e}=0.368\)</span>，当<span class="math inline">\(G=1\)</span>时取到</li>
</ul></li>
</ul></li>
</ul>
<h4 id="csma协议">CSMA协议</h4>
<p>即载波侦听多路访问，发送前先侦听一下信道</p>
<ul>
<li>1坚持
<ul>
<li>信道空闲时立刻发送数据</li>
<li>信道忙时坚持侦听</li>
</ul></li>
<li>非坚持
<ul>
<li>信道空闲时立刻发送数据</li>
<li>信道忙时等随机一段时间再侦听</li>
</ul></li>
<li>p坚持
<ul>
<li>信道空闲时以p概率发送，以1-p概率推迟到下一个时隙</li>
<li>信道忙时等到下一个时隙再侦听（也可以理解为坚持侦听）</li>
</ul></li>
</ul>
<h4 id="csmacd协议">CSMA/CD协议</h4>
<ul>
<li>信道空闲时立刻发送数据</li>
<li>信道忙时坚持侦听</li>
<li>发送过程中保持监听，即碰撞检测CD（这是本协议和CSMA协议的区别）
<ul>
<li>检测到碰撞则停止发送，并发出拥塞广播信号</li>
<li>停止后采用指数随即退避算法，等待随机时间再侦听信道</li>
</ul></li>
<li>适合半双工总线型网络
<ul>
<li>成功应用于有限连接的局域网，以太网</li>
</ul></li>
<li>争用期
<ul>
<li>又叫冲突窗口、碰撞窗口</li>
<li>等于两倍的（到最远端主机的）传播时延，发送帧后在该时间内即可判断是否有冲突
<ul>
<li>因此要求传输时延不小于争用期长度</li>
<li>以太网规定最短帧长是64B就是考虑传输时延的下界</li>
</ul></li>
<li>可以分为若干时隙</li>
</ul></li>
<li>二进制指数退避算法
<ul>
<li>基本退避时间一般取争用期</li>
<li>若当前重传次数为<span class="math inline">\(t\leq
16\)</span>，令<span class="math inline">\(k=\min\{t,10\}\)</span>
<ul>
<li>若<span class="math inline">\(t&gt;16\)</span>，则说明网络拥挤，丢弃该帧并向高层报告</li>
</ul></li>
<li>从集合<span class="math inline">\(\{0,1,2,\cdots,2^k-1\}\)</span>中取随机一个数<span class="math inline">\(r\)</span></li>
<li>退避时间为<span class="math inline">\(r\)</span>倍基本退避时间</li>
</ul></li>
</ul>
<h4 id="csmaca协议">CSMA/CA协议</h4>
<p><em>本节和无线局域网有交叉，可以结合后面进行理解</em></p>
<ul>
<li>为了应用于无线局域网，采用碰撞避免CA而不是碰撞检测CD，原因是
<ul>
<li>无线局域网的碰撞检测开销很大</li>
<li>无线局域网存在隐蔽站，彼此听不见对方</li>
</ul></li>
<li>帧间间隔IFS
<ul>
<li>SIFS（短协调IFS）：最短
<ul>
<li>使用场合：ACK、CTS、AP探询回应帧</li>
</ul></li>
<li>PIFS（点协调IFS）：中等长度
<ul>
<li>使用场合：PCF操作</li>
</ul></li>
<li>DIFS（分布式协调IFS）：最长
<ul>
<li>使用场合：异步帧竞争访问时</li>
</ul></li>
</ul></li>
<li>链路层确认（802.11使用ARQ方案）
<ul>
<li>发送站发完帧后等待确认，收到后才能继续发下一帧</li>
<li>接收站接收数据进行校验，校验通过后等待SIFS后发送确认帧ACK</li>
</ul></li>
<li>CSMA/CA协议描述
<ul>
<li>初始若信道空闲，且等待DIFS后仍空闲，则发送帧并等待确认
<ul>
<li>没有碰撞检测，一次发完不会停止</li>
</ul></li>
<li>若信道繁忙，选一个随机回退值（不大于一个争用期的时隙数），启动计时器
<ul>
<li>推迟接入：信道忙则计时器暂停（尽可能避免碰撞）</li>
<li>退避时隙：信道空闲则计时器递减（发现空闲不一定传输，也体现了碰撞避免）</li>
</ul></li>
<li>计时器为0时，此时信道必空闲，发送帧并等待确认
<ul>
<li>若收到确认，到第二步重选回退值（防止垄断），以发送下一帧</li>
<li>若超时，则到第二步选更大回退值，以重发帧</li>
</ul></li>
</ul></li>
<li>信道预约
<ul>
<li>隐蔽站问题：A和C相互看不见，A和C都希望向B发信息，导致碰撞</li>
<li>RTS帧：较短的请求发送帧，向目的主机预约信道
<ul>
<li>包括源地址、目的地址、通信持续时长</li>
</ul></li>
<li>CTS帧：较短的允许发送帧，向信道广播（告知源站允许发送，告知其他站抑制发送）
<ul>
<li>包括该次通信的持续时长</li>
</ul></li>
<li>预约策略
<ul>
<li>使用RTS和CTS</li>
<li>在数据帧超过一定阈值时，使用RTS和CTS</li>
<li>不使用RTS和CTS</li>
</ul></li>
</ul></li>
</ul>
<h3 id="轮询访问">轮询访问</h3>
<ul>
<li>轮询访问协议
<ul>
<li>在随机介质访问基础上，限制有权发送数据的结点只有一个
<ul>
<li>没冲突，适合高负载高冲突的网络</li>
</ul></li>
<li>不共享时间也不共享空间</li>
<li>典型的是令牌传递协议</li>
</ul></li>
<li>令牌传递协议
<ul>
<li>令牌环局域网：物理上不一定是环，但设备间逻辑上是一个环</li>
<li>令牌：3字节的特殊帧，在各站点间以固定顺序交换
<ul>
<li>有令牌的站点才能发送帧</li>
</ul></li>
<li>发帧流程
<ul>
<li>初始化逻辑环，生成空令牌（空闲状态）在环上流动</li>
<li>拿到令牌的站点如果想发送帧，则修改令牌的一位，使之变为“忙状态”</li>
<li>源站点把发送帧插入令牌后面形成总的帧，传递给逻辑环的下一站点</li>
<li>非目的站点把帧传递给逻辑环的下一站点</li>
<li>目的站点把帧放入缓存区，再存入本站，最后把帧的尾部附上“响应比特”，传递给逻辑环的下一站点</li>
<li>源站拿到了绕了一圈的帧，检查发现了响应比特，把令牌恢复空闲，传递给逻辑环的下一站点</li>
</ul></li>
<li>令牌释放方式
<ul>
<li>常规释放：源站收到响应比特才释放令牌（前面发帧流程就是本方式）</li>
<li>早期释放：源站发送完最后一比特后即释放令牌（只作了解，具体实现如何保证不冲突性不太清楚）</li>
</ul></li>
</ul></li>
</ul>
<h2 id="局域网">局域网</h2>
<h3 id="基本概念">基本概念</h3>
<p>LAN指较小地理范围（如一所学校）的计算机互联网络，特点为</p>
<ul>
<li>一个单位所有，地理范围、站点数有限</li>
<li>所有站点共享较高总带宽</li>
<li>较低时延和较低误码率</li>
<li>各站平等</li>
<li>能广播、组播</li>
</ul>
<h3 id="体系结构">体系结构</h3>
<h4 id="局域网三大要素">局域网三大要素</h4>
<ul>
<li>拓扑结构
<ul>
<li>星形</li>
<li>环形</li>
<li>总线形</li>
<li>星形和总线形复合型</li>
</ul></li>
<li>传输介质
<ul>
<li>双绞线
<ul>
<li>最主流</li>
</ul></li>
<li>铜缆</li>
<li>光纤</li>
</ul></li>
<li>介质访问控制方式
<ul>
<li>CSMA/CD
<ul>
<li>总线形局域网</li>
</ul></li>
<li>令牌总线
<ul>
<li>总线形局域网</li>
</ul></li>
<li>令牌环
<ul>
<li>环形局域网</li>
</ul></li>
</ul></li>
</ul>
<h4 id="ieee-802标准">IEEE 802标准</h4>
<p>IEEE
802标准对应OSI模型的物理层、数据链路层，并把数据链路层从上到下拆分为</p>
<ul>
<li>逻辑链路控制LLC子层
<ul>
<li>向网络层提供无确认无连接、有确认无连接、有确认有连接、高速传输4种连接服务类型</li>
</ul></li>
<li>媒体接入控制MAC子层
<ul>
<li>向LLC子层提供对物理层的访问接口</li>
<li>包括组帧拆帧、差错检测、透明传输</li>
</ul></li>
</ul>
<h4 id="有线局域网举例">有线局域网举例</h4>
<ul>
<li>以太网
<ul>
<li>IEEE 802.3，使用范围最广的局域网</li>
<li>逻辑拓扑：总线形</li>
<li>物理拓扑：星形、拓展星形</li>
</ul></li>
<li>令牌环
<ul>
<li>IEEE 802.5</li>
<li>逻辑拓扑：环形</li>
<li>物理拓扑：星形</li>
</ul></li>
<li>光纤分布数字接口FDDI
<ul>
<li>IEEE 802.8</li>
<li>逻辑拓扑：环形</li>
<li>物理拓扑：双环形</li>
</ul></li>
</ul>
<h3 id="以太网">以太网</h3>
<p>即IEEE 802.3局域网</p>
<ul>
<li>逻辑结构：基带总线形</li>
<li>介质访问控制方式：CSMA/CD</li>
<li>特点
<ul>
<li>提供无确认无连接服务
<ul>
<li>不可靠服务，尽最大努力交付数据</li>
</ul></li>
<li>使用曼彻斯特编码</li>
</ul></li>
<li>网线标准举例（下面的速率都是10Mb/s）
<ul>
<li>10BASE-2
<ul>
<li>物理结构：总线形</li>
<li>传输媒介：细缆</li>
<li>最大长度：500m</li>
<li>基本被淘汰</li>
</ul></li>
<li>10BASE-5
<ul>
<li>物理结构：总线形</li>
<li>传输媒介：粗缆</li>
<li>最大长度：185m</li>
<li>基本被淘汰</li>
</ul></li>
<li>10BASE-T
<ul>
<li>物理结构：星形</li>
<li>传输媒介：非屏蔽双绞线</li>
<li>最大长度：100m</li>
</ul></li>
<li>10BASE-FL
<ul>
<li>物理结构：点对点</li>
<li>传输媒介：光纤对</li>
<li>最大长度：2000m</li>
</ul></li>
</ul></li>
<li>网卡（网络适配器、网络接口卡）
<ul>
<li>工作在物理层、数据链路层的MAC子层
<ul>
<li>自带处理器、存储器的网络组件</li>
</ul></li>
<li>和局域网以电缆或双绞线连接、串行通信</li>
<li>和计算机以IO总线连接、并行通信</li>
<li>介质访问控制（MAC）地址
<ul>
<li>每个网卡独特的出厂代码，又叫物理地址</li>
<li>6个字节，字节用2个十六进制数表示，字节间用-或：连接</li>
<li>高三字节是厂商代码，低三字节是网卡序列号</li>
</ul></li>
</ul></li>
<li>MAC帧格式（DIX 以太网v2标准）
<ul>
<li>前导码（不算MAC帧的内容）：前8个字节，用于时钟同步，包括
<ul>
<li>7字节的前同步码，用于比特同步</li>
<li>1字节的开始定界符</li>
</ul></li>
<li>头部：14字节
<ul>
<li>6字节的目的MAC地址</li>
<li>6字节的源MAC地址</li>
<li>2字节的类型，记录网络层采用的协议</li>
</ul></li>
<li>数据：46-1500字节
<ul>
<li>46字节为了保证MAC帧不小于64字节，不足时填充帧</li>
<li>1500字节是以太网的最大传送单元MTU</li>
</ul></li>
<li>尾部：4字节
<ul>
<li>FCS：校验头部和数据部分，采用32位CRC</li>
</ul></li>
</ul></li>
<li>Mac帧格式（IEEE 802.3标准）
<ul>
<li>2字节的类型域更换为2字节的长度域，指出数据的长度</li>
<li>两个标准可以并存，因为可以用46-1500表示长度，用1501-65535表示类型</li>
</ul></li>
<li>高速以太网（至少100Mb/s，使用IEEE 802.3标准帧格式）
<ul>
<li>100BASE-T以太网
<ul>
<li>传输速率：100Mb/s</li>
<li>物理结构：星形</li>
<li>传输媒介：双绞线</li>
<li>工作方式：半双工（使用CSMA/CD）或全双工（无冲突、不使用CSMA/CD）</li>
</ul></li>
<li>吉比特以太网（千兆以太网）
<ul>
<li>传输速率：1Gb/s</li>
<li>其他同100BASE-T</li>
</ul></li>
<li>10吉比特以太网
<ul>
<li>传输速率：10Gb/s</li>
<li>物理结构：星形</li>
<li>传输媒介：光纤</li>
<li>工作方式：全双工（无冲突，无争用）</li>
</ul></li>
</ul></li>
</ul>
<h3 id="无线局域网">无线局域网</h3>
<h4 id="基本概念-1">基本概念</h4>
<ul>
<li>WLAN
<ul>
<li>即无线局域网</li>
<li>分为有固定基础设施WLAN和无固定基础设施WLAN</li>
</ul></li>
<li>WIFI
<ul>
<li>WLAN通常采用IEEE 802.11系列协议，此时叫WIFI</li>
<li>802.11系列协议包括802.11 a/b/g/n等</li>
</ul></li>
</ul>
<h4 id="接入方式">接入方式</h4>
<ul>
<li>固定接入：接入网络后，用户位置不变</li>
<li>游牧接入：通信期间，用户位置不变，否则通信会中断</li>
<li>便携接入：通信期间，用户可以步行速度移动，切换服务区（后面有介绍）能力有限
<ul>
<li>也可以把游牧接入归类为便携接入</li>
</ul></li>
<li>移动接入：通信期间，用户可以以车辆速度移动，切换服务区时，通信保持连续</li>
</ul>
<h4 id="有固定基础设施">有固定基础设施</h4>
<ul>
<li>物理拓扑：星形</li>
<li>无线接入点AP：无线局域网的中心基础设施，和外界的有线以太网连接
<ul>
<li>通常是基站</li>
<li>家用的AP是无线路由器</li>
</ul></li>
<li>介质访问控制方式：CSMA/CA</li>
<li>基本服务集BSS，包括
<ul>
<li>一个AP</li>
<li>若干移动站
<ul>
<li>比如手机、电脑</li>
</ul></li>
</ul></li>
<li>服务集标识符SSID
<ul>
<li>即AP的名字（字符串）</li>
<li>用户通常可知</li>
</ul></li>
<li>基本服务集标识符BSSID
<ul>
<li>即AP的MAC地址（6字节二进制串）</li>
<li>用户通常不可知</li>
</ul></li>
<li>基本服务区BSA
<ul>
<li>BSS覆盖的地理范围</li>
<li>当多个BSA重合时，移动站选择信号较强的AP进行<strong>关联</strong>（后面会介绍）</li>
</ul></li>
<li>扩展服务集ESS
<ul>
<li>多个BSS连入分配系统DS形成</li>
</ul></li>
<li>分配系统
<ul>
<li>可以理解为总线的结构</li>
<li>使得ESS对外表现为BSS</li>
<li>一般用以太网</li>
</ul></li>
<li>门户
<ul>
<li>连接分配系统的设备，使得ESS连接外界的非无线局域网</li>
<li>功能相当于网桥（见数据链路层设备小节）</li>
</ul></li>
<li>拓展服务集标识符ESSID
<ul>
<li>ESS的名字（字符串）</li>
</ul></li>
<li>关联：移动站加入AP所在BSS，有两种方式（可同时进行加快关联）
<ul>
<li>被动扫描
<ul>
<li>各AP周期性发出信标帧</li>
<li>移动站选择一个AP，发送关联请求帧</li>
<li>被选的AP发出关联响应帧</li>
</ul></li>
<li>主动扫描
<ul>
<li>移动站发出探测请求帧</li>
<li>各AP发送探测响应帧</li>
<li>移动站选择一个AP，发送关联请求帧</li>
<li>被选的AP发出关联响应帧</li>
</ul></li>
</ul></li>
<li>热点：提供WIFI接入服务的地点
<ul>
<li>若干热点接入AP，形成热区（一种基本服务区）</li>
</ul></li>
</ul>
<h4 id="无固定基础设施">无固定基础设施</h4>
<p>即移动自组网络</p>
<ul>
<li>各移动站地位平等，都有路由转发分组的能力
<ul>
<li>但不使用固定网络已有的路由选择协议</li>
</ul></li>
<li>无AP，一般不与外界相连
<ul>
<li>不同于移动IP（该技术把漫游的主机接入互联网）</li>
</ul></li>
</ul>
<h4 id="mac层协议">MAC层协议</h4>
<p>802.11标准把MAC层按功能从下到上分为</p>
<ul>
<li>分布协调功能DCF
<ul>
<li>实现：不采用中心控制算法，把每个节点分布式接入CSMA机制</li>
<li>功能：向上提供争用服务
<ul>
<li>必须实现的功能</li>
</ul></li>
<li>用到的时间间隔：SIFS和DIFS</li>
</ul></li>
<li>点协调功能PCF
<ul>
<li>实现：使用集中控制算法，由接入点AP集中控制整个BSS的活动</li>
<li>功能：向上提供无争用服务
<ul>
<li>可选功能，比如自组网络就不需要</li>
</ul></li>
<li>用到的时间间隔：PIFS</li>
</ul></li>
</ul>
<h4 id="mac帧格式">MAC帧格式</h4>
<ul>
<li>数据帧
<ul>
<li>帧控制：2字节，包含1比特的<strong>去往AP</strong>标识和1比特的<strong>来自AP</strong>标识
<ul>
<li>去往AP为1，来自AP为0：该帧当前的下一中间站是AP</li>
<li>去往AP为0，来自AP为1：该帧当前的上一中间站是AP</li>
</ul></li>
<li>持续期：2字节，用作信道预约</li>
<li>地址1：下一中间站地址
<ul>
<li>去往AP：AP的BSSID</li>
<li>来自AP：目的站MAC地址</li>
</ul></li>
<li>地址2：上一中间站地址
<ul>
<li>去往AP：源站MAC地址</li>
<li>来自AP：AP的BSSID</li>
</ul></li>
<li>地址3：源站或目的站的MAC地址
<ul>
<li>去往AP：目的站MAC地址</li>
<li>来自AP：源站的MAC地址</li>
</ul></li>
<li>序号：2字节，标志帧的序号</li>
<li>地址4：只在自组移动网使用</li>
<li>帧主体：0-2312字节</li>
<li>FCS：4字节的校验位</li>
</ul></li>
<li>RTS帧
<ul>
<li>帧控制：2字节</li>
<li>持续期：2字节</li>
<li>接收地址：6字节</li>
<li>发送地址：6字节</li>
<li>FCS：4字节</li>
</ul></li>
<li>CTS和ACK帧
<ul>
<li>帧控制：2字节</li>
<li>持续期：2字节</li>
<li>接收地址：6字节</li>
<li>FCS：4字节</li>
</ul></li>
</ul>
<h3 id="vlan">VLAN</h3>
<ul>
<li>VLAN：把较大的局域网划分为多个较小的逻辑上的虚拟局域网
<ul>
<li>每个VLAN为一个广播域
<ul>
<li>若两个主机不在一个广播域，则通信时需要网络层来路由转发</li>
</ul></li>
<li>每个VLAN在物理上可以横跨多个交换机</li>
</ul></li>
<li>VLAN标签：4字节
<ul>
<li>加入位置：以太网帧的源地址和类型字段之间</li>
<li>功能：指出该帧所属的虚拟局域网</li>
<li>组成
<ul>
<li>前2字节：0x8100，表示这个是802.1Q帧</li>
<li>半字节：4位空闲比特</li>
<li>后1.5字节：12位VLAN标识，即VID</li>
</ul></li>
</ul></li>
<li>802.1Q帧：加入了VLAN标签的帧
<ul>
<li>最大帧长从1518字节变成1522字节</li>
<li>交换机把普通帧拓展为802.1Q帧，或把802.1Q帧化简为普通帧
<ul>
<li>802.1Q帧只在交换机之间传送</li>
</ul></li>
</ul></li>
<li>下图可以辅助理解</li>
</ul>
<img src="/2021/11/25/network3/VLAN.png" class title="this is VLAN">
<h2 id="广域网">广域网</h2>
<h3 id="基本概念-2">基本概念</h3>
<ul>
<li>覆盖范围：远超城市级别的范围</li>
<li>连接方式：由多个结点交换机和交换机链路组成
<ul>
<li>点到点的连接方式</li>
</ul></li>
<li>OSI参考模型层次：物理层、数据链路层、网络层
<ul>
<li>协议主要在网络层，主要的问题是路由和转发（见网络层的章节）</li>
</ul></li>
<li>广域网是因特网核心部分，和局域网共同组成互联网</li>
<li>广域网强调资源共享，局域网强调数据传输</li>
</ul>
<h3 id="ppp协议">PPP协议</h3>
<h4 id="协议组成">协议组成</h4>
<ul>
<li>封装IP数据报的方法</li>
<li>链路控制协议LCP
<ul>
<li>建立、配置、测试和管理数据链路</li>
</ul></li>
<li>网络控制协议NCP
<ul>
<li>组成：包含多个支持不同网络层协议的协议</li>
<li>功能：使得PPP协议两端可运行不同网络层协议</li>
</ul></li>
</ul>
<h4 id="帧格式">帧格式</h4>
<ul>
<li>首部
<ul>
<li>开始标志符
<ul>
<li>固定为0x7E</li>
</ul></li>
<li>地址字段
<ul>
<li>固定为0xFF</li>
</ul></li>
<li>控制字段
<ul>
<li>固定为0x03</li>
</ul></li>
<li>协议字段：2字节
<ul>
<li>0x0021：信息部分为IP数据报</li>
<li>0xC021：信息部分为LCP分组</li>
<li>0x8021：信息部分为NCP中的某个协议</li>
</ul></li>
</ul></li>
<li>信息部分：不超过1500字节
<ul>
<li>因为是点对点的传输，没有冲突，不需要争用，因此不限制最短帧长</li>
</ul></li>
<li>尾部
<ul>
<li>FCS：2字节
<ul>
<li>CRC校验字段</li>
</ul></li>
<li>结束标志符
<ul>
<li>固定为0x7E</li>
</ul></li>
</ul></li>
</ul>
<h4 id="工作状态">工作状态</h4>
<ul>
<li>链路静止
<ul>
<li>建立物理连接后，进入<strong>链路建立</strong>状态</li>
</ul></li>
<li>链路建立
<ul>
<li>一方发送LCP配置请求帧</li>
<li>另一方回应
<ul>
<li>配置确认帧：接受所有选项，进入<strong>鉴别</strong>状态</li>
<li>配置否认帧：不接受所有选项，返回**链路静止<em>状态</em></li>
<li>配置拒绝帧：无法识别或不接受部分选项，返回<strong>链路建立</strong>状态（继续协商LCP配置）</li>
</ul></li>
</ul></li>
<li>鉴别
<ul>
<li>鉴别成功，进入<strong>网络层协议</strong>状态</li>
<li>鉴别失败，进入<strong>链路终止</strong>状态，最终回到<strong>链路静止</strong>状态</li>
</ul></li>
<li>网络层协议
<ul>
<li>双方发送NCP中的协议，协商NCP配置
<ul>
<li>比如发送NCP中支持IP的协议IPCP</li>
</ul></li>
<li>配置完成后进入<strong>链路打开</strong>状态</li>
</ul></li>
<li>链路打开
<ul>
<li>可以相互发送分组</li>
<li>可以发送回送请求LCP分组和回送回答LCP分组
<ul>
<li>检查链路状态</li>
</ul></li>
<li>可以发送终止请求LCP分组和终止确认LCP分组
<ul>
<li>进入<strong>链路终止</strong>状态，最终回到<strong>链路静止</strong>状态</li>
</ul></li>
</ul></li>
</ul>
<h4 id="特点">特点</h4>
<ul>
<li>PPP协议应用在直接连接的两个结点链路上
<ul>
<li>是面向字节的点到点协议</li>
</ul></li>
<li>不是单纯的数据链路层的协议，也包含物理层和网络层的内容
<ul>
<li>默认情况当作数据链路层协议</li>
</ul></li>
<li>透明传输
<ul>
<li>异步线路（默认）传输时，字符填充法</li>
<li>同步线路（如SONET/SDH）传输时，零比特填充法</li>
</ul></li>
<li>提供差错检测，不提供纠错功能
<ul>
<li>不可靠传输协议，无序号、无确认</li>
</ul></li>
<li>只支持全双工</li>
<li>不同网络协议的两端，可以用PPP协议通信</li>
</ul>
<h2 id="数据链路层设备">数据链路层设备</h2>
<h3 id="网桥">网桥</h3>
<ul>
<li>网桥：连接不同的以太网的设备
<ul>
<li>形成更大的以太网</li>
</ul></li>
<li>网段：即原本的各以太网
<ul>
<li>各网段是隔离开的冲突域</li>
</ul></li>
</ul>
<h3 id="以太网交换机">以太网交换机</h3>
<ul>
<li>概念
<ul>
<li>本质是多端口的网桥</li>
<li>把网络分成较小的冲突域</li>
<li>对工作站透明</li>
<li>实现VLAN方便（前面介绍过）</li>
</ul></li>
<li>原理
<ul>
<li>检测帧的源MAC地址、目的MAC地址</li>
<li>和系统内部动态查找表比较
<ul>
<li>源MAC地址不在表中，则加入表中</li>
<li>目的MAC地址不在表中，则从所有非输入端口发送（广播）</li>
<li>目的MAC地址在表中，则把帧从相应端口发送</li>
</ul></li>
</ul></li>
<li>特点
<ul>
<li>每个端口连一个主机</li>
<li>可以同时连多个端口
<ul>
<li>无碰撞，全双工</li>
</ul></li>
<li>转发表通过自学习算法逐步建立</li>
<li>用户通信时独占传输媒体带宽
<ul>
<li>比如以太网带宽10 Mb/s，交换机连N个用户，则每个用户10
Mb/s，交换机总容量10N Mb/s</li>
</ul></li>
<li>拥有多种速率端口，方便不同需求的用户</li>
</ul></li>
<li>交换模式
<ul>
<li>直通式
<ul>
<li>方法：检查帧目的地址后即可发送</li>
<li>优点：速度快</li>
<li>缺点：不安全、不能支持不同速率的端口</li>
</ul></li>
<li>存储转发式
<ul>
<li>方法：把帧存到高速缓存器，检查数据正确性，有误则丢弃，否则通过查找表把帧从输出端口发出</li>
<li>优点：安全、支持不同速率的端口</li>
<li>缺点：速度慢</li>
</ul></li>
</ul></li>
</ul>
<h2 id="冲突域和广播域">冲突域和广播域</h2>
<p><em>本节补充冲突域和广播域的辨析</em></p>
<ul>
<li>冲突域
<ul>
<li>定义：可能发生冲突的网卡组成冲突域</li>
<li>举例：一般为一个网段</li>
</ul></li>
<li>广播域
<ul>
<li>定义：广播能相互收到信息的网卡组成广播域</li>
<li>举例：一般为一个局域网</li>
</ul></li>
<li>设备隔离总结
<ul>
<li>集线器和中继器：不隔离冲突域、不隔离广播域</li>
<li>网桥和交换机：隔离冲突域、不隔离广播域</li>
<li>路由器：隔离冲突域、隔离广播域</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第四章-网络层</title>
    <url>/2021/11/28/network4/</url>
    <content><![CDATA[<h2 id="网络层的功能">网络层的功能</h2>
<h3 id="异构网络互联">异构网络互联</h3>
<ul>
<li>中间设备：又叫中间系统、中继系统
<ul>
<li>物理层中间设备：中继器、集线器</li>
<li>数据链路层中间设备：网桥、交换机</li>
<li>网络层中间设备：路由器</li>
<li>网络层以上中间设备：网关
<ul>
<li>路由器的一种，详见NAT</li>
</ul></li>
</ul></li>
<li>异构网络：物理结构不同的网络</li>
<li>异构网络互联：把多个<strong>异构网络</strong>用网络层的<strong>中间设备</strong>连接，构成<strong>更大的网络系统</strong>
<ul>
<li>该更大的网络叫虚拟互联网络（或逻辑互联网络、IP网络）</li>
</ul></li>
</ul>
<h3 id="路由和转发">路由和转发</h3>
<p>网络层从上到下分为控制层、数据层，对应路由器的两个功能（当然主机也有这个功能）</p>
<ul>
<li>路由选择（控制层的功能）
<ul>
<li>根据路由选择协议，构造路由表（目的地址、子网掩码、下一跳地址）</li>
<li>和相邻路由器交换信息，更新维护路由表</li>
</ul></li>
<li>分组转发（数据层的功能）
<ul>
<li>输入端口
<ul>
<li>从比特流中提取出帧，进一步提取出数据报</li>
</ul></li>
<li>交换结构
<ul>
<li>根据路由表和ARP表算出转发表（在讨论路由选择时不区分转发表）</li>
<li>根据转发表把分组从适合的端口转发（涉及队列管理、任务调度）</li>
<li>交换有三种硬件实现，即通过存储器、总线、互联网络</li>
</ul></li>
<li>输出端口
<ul>
<li>把数据报封装为帧，进一步封装为比特流</li>
</ul></li>
</ul></li>
</ul>
<h3 id="sdn基本概念">SDN基本概念</h3>
<ul>
<li>原理
<ul>
<li>传统网络：路由器分布式的实现控制层、数据层</li>
<li>软件定义网络（SDN）：远程控制器集中式实现控制层，路由器分布式实现数据层
<ul>
<li>远程控制器一般由多个服务器组成，掌握整个网络状态，算出最佳路由后把转发表发给路由器</li>
</ul></li>
</ul></li>
<li>接口
<ul>
<li>北向接口：SDN控制器提供给应用开发者的编程接口</li>
<li>南向接口：SDN控制器提供给路由器的双向会话接口</li>
<li>东西向接口：SDN控制器集群内部控制器间的通信接口</li>
</ul></li>
<li>优点
<ul>
<li>控制层和数据层分离，全局优化路由，高速转发</li>
<li>网络灵活可编程</li>
<li>降低成本</li>
</ul></li>
<li>缺点
<ul>
<li>控制器崩溃则网络崩溃，不安全</li>
<li>网络规模扩大，控制器成为性能瓶颈</li>
</ul></li>
</ul>
<h3 id="拥塞控制">拥塞控制</h3>
<ul>
<li>拥塞
<ul>
<li>概念：通信子网中，分组过量导致网络性能下降的现象</li>
<li>坏处：导致分组丢失，甚至网络死锁</li>
</ul></li>
<li>拥塞控制
<ul>
<li>判断网络是否拥塞
<ul>
<li>一般用网络吞吐量（相比正常吞吐量）的下降程度表示拥塞程度</li>
</ul></li>
<li>控制拥塞
<ul>
<li>开环控制：网络设计时考虑导致拥塞的因素，一种静态预防方法</li>
<li>闭环控制：网络运行时检测系统拥塞的情况，一种动态调整方法</li>
</ul></li>
</ul></li>
<li>拥塞控制和流量控制的对比
<ul>
<li>不同点
<ul>
<li>流量控制是两个点之间通信量的控制，希望发送速率不大于接收速率</li>
<li>拥塞控制涉及整个通信子网所有的主机</li>
</ul></li>
<li>相同点
<ul>
<li>都控制发送方的发送速率（发送窗口）</li>
</ul></li>
</ul></li>
</ul>
<h2 id="路由算法">路由算法</h2>
<h3 id="静态路由和动态路由">静态路由和动态路由</h3>
<ul>
<li>静态路由算法（非自适应路由算法）
<ul>
<li>由网络管理员手动设置路由信息</li>
<li>简便，开销小，适合小型网络</li>
</ul></li>
<li>动态路由算法（自适应路由算法）
<ul>
<li>路由器之间交换信息，按算法优化得到路由表项</li>
<li>性能好，但需要复杂的算法，增加网络的负担</li>
<li>常见动态路由算法
<ul>
<li>距离-向量路由</li>
<li>链路状态路由</li>
</ul></li>
</ul></li>
</ul>
<h3 id="距离-向量路由算法">距离-向量路由算法</h3>
<p><em>本节只介绍大概的算法思想，具体的算法后面再介绍</em></p>
<ul>
<li>数据结构
<ul>
<li>每个结点维护一个向量，表示当前结点到各目的地的距离（比如跳数）</li>
</ul></li>
<li>算法思想
<ul>
<li>若接收到相邻结点发来的向量，则对自身向量进行更新</li>
<li>若本结点的向量更新，则将其发到所有的相邻结点</li>
</ul></li>
<li>特点
<ul>
<li>结点给<strong>相邻结点</strong>发送<strong>从自身到所有其他结点</strong>的最低费用估计</li>
<li>有慢收敛现象（在RIP协议再解释），可能导致路由回路问题（分组在两个结点间来回传递）</li>
</ul></li>
<li>典型算法
<ul>
<li>RIP算法</li>
</ul></li>
</ul>
<h3 id="链路状态路由算法">链路状态路由算法</h3>
<p><em>本节只介绍大概的算法思想，具体的算法后面再介绍</em></p>
<ul>
<li>数据结构
<ul>
<li>每个结点维护<strong>直接链路状态</strong>和<strong>全局网络拓扑</strong>
<ul>
<li>直接链路状态即到各相邻路由器的距离、费用、时延等代价度量</li>
<li>全局网络拓扑即整个网络的非负带权图</li>
</ul></li>
</ul></li>
<li>算法思想
<ul>
<li>若接收其他任何结点更新后的直接链路状态，则对本结点的全局网络拓扑进行更新，并用Dijkstra算法重新计算路由</li>
<li>若自身直接链路状态变化时，则将其发送到所有其他的路由器
<ul>
<li>洪泛法</li>
</ul></li>
</ul></li>
<li>特点
<ul>
<li>结点给<strong>其他所有结点</strong>发送<strong>从自身到相邻结点</strong>的链路状态</li>
<li>每个结点有全局的网络拓扑信息，能直接算出路由，快速收敛汇聚</li>
</ul></li>
<li>典型算法
<ul>
<li>OSPF算法</li>
</ul></li>
</ul>
<h3 id="层次路由">层次路由</h3>
<p><em>本节只介绍大概的算法思想，具体的算法后面再介绍</em></p>
<ul>
<li>层次路由
<ul>
<li>把整个互联网划分为多个自治系统AS（每个AS可包括若干局域网）</li>
<li>AS内和AS间采用各自的路由协议</li>
</ul></li>
<li>内部网关协议IGP（域内路由选择协议）
<ul>
<li>即AS内部的路由选择协议</li>
<li>比如RIP、OSPF</li>
</ul></li>
<li>外部网关协议EGP（域间路由选择协议）
<ul>
<li>即AS之间的路由选择协议</li>
<li>比如BGP</li>
</ul></li>
</ul>
<h2 id="ipv4">IPv4</h2>
<h3 id="分组格式">分组格式</h3>
<ul>
<li>首部
<ul>
<li>版本（半字节）
<ul>
<li>IP的版本</li>
</ul></li>
<li>首部长度（半字节）
<ul>
<li>单位是<span class="math inline">\(4B\)</span></li>
<li>最大值为<span class="math inline">\(15\times 4B=60B\)</span></li>
<li>最常见为<span class="math inline">\(20B\)</span>（即首部不采用可选项）</li>
</ul></li>
<li>服务类型（1字节）
<ul>
<li>比如区分一些要求低时延、高吞吐量的数据报</li>
</ul></li>
<li>总长度（2字节）
<ul>
<li>指首部和数据部分总长度</li>
<li>单位是<span class="math inline">\(1B\)</span></li>
</ul></li>
<li>标识（2字节）
<ul>
<li>每个数据报（分组）一个标识</li>
<li>同一个数据报片的各分片标识相同</li>
</ul></li>
<li>标志（3位）
<ul>
<li>低位MF表示后面是否还有分片</li>
<li>中位DF表示是否禁止对本分组继续分片</li>
<li>高位没用</li>
</ul></li>
<li>片偏移（13位）
<ul>
<li>表示分片在原数据报的相对位置</li>
<li>单位是8字节（因为分片大小规定是8字节的整数倍）</li>
</ul></li>
<li>生存时间TTL（1字节）
<ul>
<li>表示数据报在网络中可通过的最大路由器数</li>
<li>路由器收到TTL为0的数据报则丢弃，否则转发并把TTL减1</li>
</ul></li>
<li>协议（1字节）
<ul>
<li>指出传输层是什么协议</li>
<li>6表示TCP，17表示UDP</li>
</ul></li>
<li>首部校验和（2字节）
<ul>
<li>网络层只对首部进行差错检测</li>
</ul></li>
<li>源地址（4字节）
<ul>
<li>最初发送方IP地址</li>
</ul></li>
<li>目的地址（4字节）
<ul>
<li>最终接收方IP地址</li>
</ul></li>
<li>可变长字段
<ul>
<li>0-40字节</li>
</ul></li>
</ul></li>
<li>数据部分
<ul>
<li>首部加数据部分长度不超过帧的最大传送单元MTU</li>
</ul></li>
</ul>
<h3 id="分组分片">分组分片</h3>
<ul>
<li>分片
<ul>
<li><strong>中间路由器</strong>转发分组时，由于MTU的限制，会<strong>把分组分片</strong></li>
<li>各分片的标识同原始分组</li>
<li>设置分片的标志和片偏移</li>
</ul></li>
<li>重组
<ul>
<li>在<strong>目的地重组分片</strong></li>
<li>把同标识的分片取出，根据片偏移排序重组为原分组</li>
</ul></li>
</ul>
<h3 id="转发流程">转发流程</h3>
<ul>
<li>提取目的地址D</li>
<li>如果某个直连路由器的网络和D匹配（需要用到该网络的子网掩码），则数据报<strong>直接交付</strong>
<ul>
<li>否则是间接交付，继续往下执行</li>
</ul></li>
<li>如果路由表有D的路由，则转发到下一跳
<ul>
<li>否则继续执行</li>
</ul></li>
<li>如果路由表有网络和D匹配（需要用到该网络的子网掩码），则转发到下一跳
<ul>
<li>否则继续执行</li>
</ul></li>
<li>如果路由表有默认路由，则转发到该默认路由器
<ul>
<li>否则报告转发出错</li>
</ul></li>
</ul>
<p><em>注：路由器转发帧，不改变网络层地址，通过ARP和下一跳地址来修改MAC源地址、目的地址。此外，网桥转发帧时不改变帧的源MAC地址。</em></p>
<h3 id="ipv4地址">IPv4地址</h3>
<ul>
<li>定义：全球唯一的32位网络层标识符
<ul>
<li>简称IP地址</li>
</ul></li>
<li>组成
<ul>
<li>网络号：整个因特网范围唯一</li>
<li>主机号：网络号对应的网络的范围内唯一</li>
</ul></li>
<li>传统网络划分
<ul>
<li>A类：0（网络号固定部分）、7位网络号可变部分、24位主机号</li>
<li>B类：10（网络号固定部分）、14位网络号可变部分、16位主机号</li>
<li>C类：110（网络号固定部分）、21位网络号可变部分、8位主机号</li>
<li>D类（多播地址）：1110（网络号固定部分）、多播地址可变部分</li>
<li>E类：1111（网络号固定部分）、保留将来使用</li>
</ul></li>
<li>IP地址划分
<ul>
<li>网络号全0，主机号全0
<ul>
<li><strong>本网络</strong>的本主机</li>
<li>DHCP协议用到</li>
<li>注：网络号全0指的是网络号的可变部分全0，下同</li>
</ul></li>
<li>网络号全0，主机号非全0非全1
<ul>
<li><strong>本网络</strong>的某主机</li>
</ul></li>
<li>网络号全0，主机号全1
<ul>
<li><strong>本网络</strong>的广播</li>
</ul></li>
<li>网络号非全0，主机号全0
<ul>
<li><strong>网络号对应</strong>的网络本身</li>
</ul></li>
<li>网络号非全0，主机号非全0非全1
<ul>
<li><strong>网络号对应</strong>网络的某主机</li>
</ul></li>
<li>网络号非全0，主机号全1（等价于本网络的广播，因为路由器隔离广播域）
<ul>
<li>网络号非全1：网络号对应的网络的广播地址（全称直接广播地址）</li>
<li>网络号全1：整个TCP/IP网络的广播（全称受限广播地址）</li>
</ul></li>
<li>127.x.x.x，且主机号x.x.x非全0非全1
<ul>
<li>环回自检地址，表示主机本身</li>
<li>主机检查自身端口状况时使用，带该地址的数据报不会出现在网络层</li>
</ul></li>
</ul></li>
<li>特点
<ul>
<li>网络号由IP地址管理机构分配，主机号由得到网络的单位自行分配</li>
<li>路由器每个端口一个IP地址，一般至少两个IP地址</li>
<li>交换机连接的各局域网，其主机IP地址网络号相同，但主机号不同</li>
</ul></li>
</ul>
<h3 id="网络地址转换nat">网络地址转换NAT</h3>
<ul>
<li>设计目的
<ul>
<li>节省公用IP地址的消耗
<ul>
<li>一个公用IP让多个主机访问因特网</li>
</ul></li>
<li>隐藏内部网络结构，更安全
<ul>
<li>多个私有IP在外界看来是一个公用IP</li>
</ul></li>
</ul></li>
<li>工作原理
<ul>
<li>把IP地址划分为公有IP和私有IP</li>
<li>公有IP给外界的因特网（广域网WAN）使用</li>
<li>私有IP给内部的专用网（局域网LAN）使用
<ul>
<li>又叫可重用地址，因为不同局域网的私有IP可以重复</li>
<li>网段包括10.x.x.x、127.16-31.x.x、192.168.x.x</li>
</ul></li>
<li>通过<strong>网关NAT路由器</strong>实现两种地址的转换
<ul>
<li>转换表项是（私有IP，端口号）和（公有IP，端口号）之间的映射</li>
<li>转换表项由管理员手动添加</li>
</ul></li>
</ul></li>
<li>转换步骤
<ul>
<li>从LAN到WAN
<ul>
<li>转换源IP和源端口</li>
</ul></li>
<li>从WAN到LAN
<ul>
<li>转换目的IP和目的端口</li>
</ul></li>
</ul></li>
<li>网关NAT路由器
<ul>
<li>工作在传输层，因为使用到传输层的端口号</li>
</ul></li>
</ul>
<h3 id="子网划分">子网划分</h3>
<ul>
<li>定长子网划分：把两级IP地址（网络号、主机号）变成三级IP地址（网络号、子网号、主机号）
<ul>
<li>把主机号分成子网号和主机号</li>
<li>划分后的主机号全0表示子网，全1表示子网的广播</li>
<li>划分后的各子网长度相等，有着相同的子网掩码</li>
</ul></li>
<li>变长子网划分
<ul>
<li>给出各子网的32位IP地址和子网掩码</li>
<li>划分后的子网大小不完全相同，有着不同的子网掩码</li>
</ul></li>
</ul>
<h3 id="子网掩码">子网掩码</h3>
<ul>
<li>32位二进制串，高位若干1，低位若干0
<ul>
<li>1为网络号和子网号的位数</li>
<li>0为主机号的位数</li>
</ul></li>
<li>IP地址和子网掩码进行位运算“与”，得到子网的地址</li>
<li>默认子网掩码
<ul>
<li>255.0.0.0</li>
<li>255.255.0.0</li>
<li>255.255.255.0</li>
</ul></li>
</ul>
<h3 id="cidr">CIDR</h3>
<ul>
<li>定义：无分类域间路由选择CIDR是基于子网掩码的网络划分方法
<ul>
<li>两级IP地址（网络前缀、主机号）</li>
<li>网络前缀的长度不固定
<ul>
<li>消除了传统A、B、C网络地址（网络号定长）的概念</li>
</ul></li>
<li>主机号可以进一步划分成一些子网
<ul>
<li>子网的<strong>网络前缀变长</strong></li>
</ul></li>
</ul></li>
<li>斜线记法（CIDR记法）
<ul>
<li>IP地址/网络前缀的比特数</li>
</ul></li>
<li>CIDR地址块：网络前缀相同的IP地址的集合</li>
<li>路由聚合
<ul>
<li>按需要<strong>缩短网络前缀</strong>，使得多个IP地址的网络前缀相同</li>
<li>把这些IP地址用一个CIDR块表示，节约路由表的表项</li>
</ul></li>
<li>最长前缀匹配（最佳匹配）
<ul>
<li>路由表中，匹配网络前缀最长的表项</li>
</ul></li>
</ul>
<h3 id="有关协议">有关协议</h3>
<h4 id="arp协议">ARP协议</h4>
<ul>
<li>地址解析协议ARP
<ul>
<li>网络层协议</li>
<li>每个主机维护一个ARP高速缓存（ARP表），完成本局域网各IP地址到MAC地址的映射</li>
</ul></li>
<li>工作原理
<ul>
<li>ARP表中有下一跳的IP地址，则映射为MAC地址，封装为帧发送</li>
<li>ARP表中没有下一跳的IP地址，则广播<strong>ARP请求分组</strong>（MAC地址为全1）
<ul>
<li>下一跳设备收到ARP请求后，发出<strong>ARP响应分组</strong>，包含其IP地址到MAC地址的映射</li>
<li>原设备收到后更新ARP表，然后根据映射封装并发送帧即可</li>
</ul></li>
</ul></li>
</ul>
<h4 id="dhcp协议">DHCP协议</h4>
<ul>
<li>动态主机配置协议DHCP
<ul>
<li>基于UDP的应用层协议
<ul>
<li>工作方式为客户-服务器方式（应用层部分会介绍）</li>
</ul></li>
<li>给主机动态的分配IP地址
<ul>
<li>分配是临时的，分配时长叫做<strong>租用期</strong></li>
</ul></li>
</ul></li>
<li>步骤原理
<ul>
<li>第一步：客户机广播<strong>DHCP发现报文</strong>
<ul>
<li>源IP全0，目的IP全1</li>
<li>广播域中可以有多个DHCP服务器</li>
</ul></li>
<li>第二步：服务器收到后
<ul>
<li>若数据库中有该计算机配置信息，则发送此配置信息</li>
<li>否则广播<strong>DHCP提供报文</strong>，包括提供给客户机的IP地址（服务器从地址池中取出）和配置信息</li>
</ul></li>
<li>第三步：客户机收到后，如果接受则广播<strong>DHCP请求报文</strong>
<ul>
<li>一般只接受第一个收到的提供报文</li>
<li>请求报文中包括请求的IP地址</li>
</ul></li>
<li>第四步：服务器收到后，广播<strong>DHCP确认报文</strong>
<ul>
<li>包括提供的IP地址和配置信息</li>
</ul></li>
</ul></li>
<li>使用广播的原因
<ul>
<li>第一步：服务器地址未知</li>
<li>第二步：客户机还没有IP地址</li>
<li>第三步：告知所有DHCP服务器，客户机将选择某服务器</li>
<li>第四步：客户机还没有IP地址</li>
</ul></li>
<li>重新登陆
<ul>
<li>客户机重新登陆时从第三步开始，发送请求报文</li>
<li>服务器接收到后
<ul>
<li>若同意客户继续使用IP地址，则发送确认报文</li>
<li>否则发送<strong>否定报文NACK</strong>，客户机要从第一步开始</li>
</ul></li>
</ul></li>
<li>更新租约
<ul>
<li>在租用期过半时，客户从第三步开始，发送请求报文，更新租约</li>
</ul></li>
</ul>
<h4 id="icmp协议">ICMP协议</h4>
<ul>
<li>网际控制报文协议ICMP
<ul>
<li>报告差错和异常情况</li>
<li>ICMP报文作为IP的数据部分，加上IP头部组成IP数据报</li>
</ul></li>
<li>ICMP差错报告报文
<ul>
<li>终点不可达
<ul>
<li>包括网络无路由、主机不可达、端口不可达等多种子情况</li>
</ul></li>
<li>源点抑制
<ul>
<li>用于拥塞控制</li>
</ul></li>
<li>时间超过
<ul>
<li>路由器发送情况：收到TTL为0的分组，丢弃</li>
<li>终点主机发送情况：等待数据报分片超时，丢弃已接收的分片</li>
</ul></li>
<li>参数问题
<ul>
<li>数据报的头部有错误字段</li>
</ul></li>
<li>改变路由（重定向）
<ul>
<li>路由器告知主机更好的路由</li>
</ul></li>
</ul></li>
<li>不发送的ICMP差错报告情况
<ul>
<li>ICMP差错报告报文所在的数据报</li>
<li>第一个分片后面所有分片的数据报</li>
<li>有组播地址的数据报</li>
<li>有特殊地址（如127.0.0.0和0.0.0.0）的数据报</li>
</ul></li>
<li>ICMP询问报文
<ul>
<li>回送请求和回答报文
<ul>
<li>测试目的主机的可达状态</li>
</ul></li>
<li>时间戳请求和回答报文</li>
<li>地址掩码请求和回答报文</li>
<li>路由器询问和通告报文</li>
</ul></li>
<li>应用
<ul>
<li>路由追踪命令（Traceroute/Tracert）
<ul>
<li>工作层：网络层</li>
<li>原理：依次发送TTL为1、2、3的报文，通过接收的<strong>ICMP时间超过报文</strong>，推测路由信息</li>
</ul></li>
<li>分组网间探测命令（PING）
<ul>
<li>工作层：应用层，不使用传输层</li>
<li>原理：通过<strong>ICMP回送请求和回答报文</strong>测试连通性</li>
</ul></li>
</ul></li>
</ul>
<h2 id="ipv6">IPv6</h2>
<h3 id="主要特点">主要特点</h3>
<ul>
<li>16字节的IP地址</li>
<li>拓展的地址层次，查路由更快
<ul>
<li>第一级：全球级</li>
<li>第二级：单个场点级</li>
<li>第三级：单个网络接口级</li>
</ul></li>
<li>灵活且简化的首部格式
<ul>
<li>从12个固定项变成8个固定项</li>
<li>一些固定项变成选项</li>
</ul></li>
<li>协议允许继续扩充</li>
<li>即插即用（自动配置IP）</li>
<li>支持资源预分配</li>
<li>只能在源点才能分片（不能路由分片）</li>
<li>首部长度是8字节整数倍
<ul>
<li>固定长度40字节</li>
</ul></li>
<li>身份验证和保密功能</li>
</ul>
<h3 id="ipv6地址">IPv6地址</h3>
<ul>
<li>目的地址类型
<ul>
<li>单播：目的站是一个计算机</li>
<li>多播：目的站是一组计算机的每个</li>
<li>任播：目的站是一组计算机的某一个（通常是最近的一个）</li>
</ul></li>
<li>地址表示
<ul>
<li>16字节分成8组，每组2字节
<ul>
<li>写成16进制</li>
</ul></li>
<li>组间用分号隔开，若有连续的0，有一次机会写成双分号
<ul>
<li>举例：4BF5::BA5F:39A:A:2176省去了0:0:0</li>
</ul></li>
</ul></li>
</ul>
<h3 id="从ipv4到ipv6">从IPv4到IPv6</h3>
<ul>
<li>IPv6和IPv4不兼容
<ul>
<li>IPv6系统不能和IPv4系统直接通信</li>
</ul></li>
<li>采用逐步演进法过渡
<ul>
<li>IPv6系统能接收、路由和转发IPv4的分组</li>
</ul></li>
<li>过渡策略
<ul>
<li>双协议栈
<ul>
<li>一台设备同时安装IPv4和IPv6的协议栈</li>
</ul></li>
<li>隧道技术
<ul>
<li>把IPv6作为IPv4的数据部分进行封装</li>
</ul></li>
</ul></li>
</ul>
<h2 id="路由协议">路由协议</h2>
<h3 id="自治系统">自治系统</h3>
<ul>
<li>即AS，内部的所有路由器在AS内都是连通的</li>
<li>AS内采用<strong>域内路由</strong>，AS间采用<strong>域间路由</strong></li>
</ul>
<h3 id="域内路由和域间路由">域内路由和域间路由</h3>
<ul>
<li>内部网关协议IGP
<ul>
<li>如RIP和OSPF</li>
</ul></li>
<li>外部网关协议EGP
<ul>
<li>如BGP-4</li>
</ul></li>
</ul>
<h3 id="rip路由协议">RIP路由协议</h3>
<ul>
<li>路由信息协议RIP
<ul>
<li>应用层协议
<ul>
<li>RIP封装在UDP中，基于UDP</li>
</ul></li>
<li>基于距离-向量路由算法
<ul>
<li>距离定义为跳数</li>
</ul></li>
</ul></li>
<li>规定
<ul>
<li>一条路径最多15个网络，距离为16表示不可达
<ul>
<li>说明只适合小型网</li>
</ul></li>
<li><strong>相邻的</strong>路由器<strong>默认隔30秒</strong>交换<strong>整个路由表</strong>的信息
<ul>
<li>网络拓扑改变时也交换信息</li>
<li>3分钟没收到相邻路由器的信息，则将其标记为不可达（距离设为16）</li>
</ul></li>
<li>主机只接收路由信息不发送路由信息</li>
<li>路由表表项：网络、最短距离、下一跳地址
<ul>
<li>不包括子网掩码，因此域内网络的子网掩码要求相同</li>
<li>最新的RIP2支持变长子网掩码和CIDR</li>
</ul></li>
</ul></li>
<li>算法：收到邻居的路由表后，对于每个表项
<ul>
<li>最短距离加1，下一跳改成邻居</li>
<li>若网络在本地路由表找不到
<ul>
<li>则把表项插入本地路由表</li>
</ul></li>
<li>若网络在本地路由表找到
<ul>
<li>当下一跳相同，则用新表项代替原表项</li>
<li>当下一跳不同，则新旧表项中，选择距离较小的</li>
</ul></li>
</ul></li>
<li>特点
<ul>
<li>实现简单，开销小</li>
<li>只适合小型网
<ul>
<li>规模太大时，路由表太大</li>
</ul></li>
<li>有路由回路问题
<ul>
<li>相邻的两个路由器互相认为到达某网络的下一跳为对方</li>
</ul></li>
<li>慢收敛
<ul>
<li>路由出故障需要较长时间才能把正确路由传送到全局</li>
</ul></li>
</ul></li>
</ul>
<h3 id="ospf路由协议">OSPF路由协议</h3>
<ul>
<li>开放最短路径优先协议OSPF
<ul>
<li>网络层协议
<ul>
<li>OSPF封装在IP中，基于IP</li>
</ul></li>
<li>基于链路状态路由算法</li>
</ul></li>
<li>规定
<ul>
<li>在<strong>链路状态变化</strong>时，向<strong>所有</strong>路由器发送<strong>到相邻路由器</strong>的链路状态信息
<ul>
<li>泛洪法</li>
<li>链路状态信息即各边和各边的代价（包含32位序号，序号大，状态新）</li>
<li>只发送相邻的链路状态，网络可以规模很大</li>
</ul></li>
<li>不同的IP<strong>服务类型</strong>TOS，计算不同的路由</li>
<li>到同一个网络的多个同代价路径，可以<strong>负载平衡</strong></li>
<li>通过<strong>鉴别</strong>功能，保证链路状态信息发送给可信的路由器</li>
<li>支持变长子网掩码和CIDR</li>
<li>每个路由器有一个<strong>链路状态数据库</strong>（AS的网络拓扑图）
<ul>
<li>同步：使得各路由器的链路状态数据库保持一致</li>
</ul></li>
</ul></li>
<li>算法原理
<ul>
<li>数据库建立：当新路由器开始工作
<ul>
<li>每个路由器发送<strong>数据库描述分组</strong>（全部链路的摘要信息）给邻居</li>
<li>邻居回应<strong>链路状态请求分组</strong>，请求所缺链路的详细信息</li>
</ul></li>
<li>数据库维护
<ul>
<li>默认每隔10秒，和邻居交换<strong>问候分组</strong>，确认可达性</li>
<li>默认每隔30分钟，刷新一次数据库</li>
</ul></li>
<li>数据库同步（泛洪法）
<ul>
<li>链路状态改变时，向邻居（认为在下游）发送<strong>链路状态更新分组</strong></li>
<li>下游邻居收到后，继续向下游转发、更新数据库、向上游回应<strong>链路状态确认分组</strong>（仅一次）</li>
</ul></li>
<li>路由表更新
<ul>
<li>根据数据库对应的全网拓扑图，用Dijkstra算法算出最优路径，更新路由表</li>
</ul></li>
</ul></li>
<li>区域
<ul>
<li>定义：AS进一步的划分，使得区域成为泛洪法的范围</li>
<li>目的：链路状态数据库是区域内的网络拓扑图，减少通信量</li>
<li>分层：区域中有一个是主干区域
<ul>
<li>通过区域边界路由器，连接AS内的其他（下层）区域</li>
<li>通过AS边界路由器，连接其他AS</li>
</ul></li>
</ul></li>
</ul>
<h3 id="bgp路由协议">BGP路由协议</h3>
<ul>
<li>边界网关协议BGP
<ul>
<li>应用层协议
<ul>
<li>BGP封装在TCP中，基于TCP</li>
</ul></li>
<li>基于路径-向量路由算法</li>
</ul></li>
<li>规定
<ul>
<li>AS内的路由器分为<strong>边界网关</strong>和<strong>内部路由器</strong>
<ul>
<li>边界网关可以有多个，但不会太多</li>
<li>AS之间通过各自的边界网关直连</li>
</ul></li>
<li>BGP会话（建立TCP连接后才能进行BGP会话）
<ul>
<li>eBGP会话：边界网关和其他AS的边界网关交换信息</li>
<li>iBGP会话：边界网关和自身AS的内部路由器交换信息</li>
</ul></li>
<li>BGP路由表：只记录跨AS的目的网络的路由信息</li>
<li>边界网关的BGP路由表项格式
<ul>
<li>目标的网络前缀（说明BGP支持CIDR）</li>
<li>经过的AS序列（不允许重复）</li>
<li>下一跳</li>
</ul></li>
<li>内部路由器的BGP路由表项格式
<ul>
<li>目标的网络前缀</li>
<li>下一跳</li>
</ul></li>
<li>路由信息交换的时机
<ul>
<li>BGP启动时，和邻居交换路由表所有信息</li>
<li>路由发生变化时，只交换路由表的变化部分信息</li>
</ul></li>
</ul></li>
<li>算法原理
<ul>
<li>边界网关给其他AS的边界网关发送路由表信息前
<ul>
<li>把自身插入AS序列</li>
<li>把下一跳改成自身</li>
</ul></li>
<li>边界网关收到其他AS的边界网关发送路由表信息后
<ul>
<li>拒绝不符合规定的路由交换信息</li>
<li>更新本地BGP路由表</li>
<li>转发符合规定的路由交换信息（不作修改的发给AS内的路由器）</li>
</ul></li>
<li>内部路由器收到边界网关的交换信息后（不考虑路由选择）
<ul>
<li>根据内部网关协议，计算到边界网关的下一跳</li>
<li>更新本地BGP路由表</li>
</ul></li>
<li>路由选择（考虑同一个目的地有多个路径时，内部路由器采取的选择策略）
<ul>
<li>本地偏好：管理员给AS内每个网关一个偏好值，选择偏好值最高的网关所在路径</li>
<li>最少AS跳数：选择AS序列最短的路径</li>
<li>热土豆法：选择最近的网关所在路径（最近的评判标准由内部网关协议给定）</li>
</ul></li>
</ul></li>
<li>BGP-4报文类型
<ul>
<li>打开报文：边界网关发送给邻居（对等端），请求建立BGP会话</li>
<li>更新报文：发送路由信息或撤销路由信息</li>
<li>保活报文：回应打开报文，并周期性的证实会话的连通性</li>
<li>通知报文：发送检测到的差错</li>
</ul></li>
</ul>
<h2 id="ip组播">IP组播</h2>
<h3 id="基本概念">基本概念</h3>
<ul>
<li>组播（多播）：源主机发送<strong>单个分组</strong>到达<strong>一组目标主机（多播组）</strong>
<ul>
<li>单个分组
<ul>
<li>在路由器分叉时，复制为多个分组</li>
<li>到达局域网时，则不用复制，由硬件实现组播</li>
</ul></li>
<li>同一组主机使用一个组播地址
<ul>
<li>IPv4的D类地址就是组播地址</li>
<li>IPv6也有地址空间保留给组播地址</li>
</ul></li>
<li>一个主机可以加入多个多播组</li>
<li>组播只给UDP提供服务</li>
</ul></li>
<li>组（多）播路由器
<ul>
<li>支持组播路由选择协议的路由器（后面会介绍此协议）</li>
</ul></li>
<li>组（多）播数据报
<ul>
<li>目的地址为组播地址（后面会介绍此地址）</li>
</ul></li>
<li>需要的协议
<ul>
<li>因特网组管理协议IGMP
<ul>
<li>让<strong>本局域网的多播路由器</strong>知道<strong>本局域网是否有主机</strong>参与或退出某个多播组</li>
</ul></li>
<li>组播路由选择协议
<ul>
<li>让不同局域网的多播路由器协作，使得多播数据报能送到组中所有的主机</li>
</ul></li>
</ul></li>
</ul>
<h3 id="ip组播地址">IP组播地址</h3>
<p>IPv4的组播地址共32位</p>
<ul>
<li>前4位是1110，总地址范围是224.0.0.0-239.255.255.255</li>
<li>第5-9位不使用</li>
<li>只使用低23位
<ul>
<li>唯一对应一个MAC组播地址
<ul>
<li>在最终局域网内硬件多播时使用</li>
<li>范围是01-00-5E-00-00-00到01-00-5E-7F-FF-FF</li>
<li>和IP组播地址有相同的低23位</li>
</ul></li>
</ul></li>
</ul>
<h3 id="igmp">IGMP</h3>
<ul>
<li>网络层协议
<ul>
<li>封装在IP数据报中，首部协议字段为2</li>
</ul></li>
<li>工作原理
<ul>
<li>第一阶段
<ul>
<li>某主机向本地多播路由器，发送带有IGMP的多播IP数据报</li>
<li>本地多播路由器收到后，将该主机加入对应多播组</li>
<li>调用<strong>组播路由选择协议</strong>，把消息发给其他多播路由器</li>
</ul></li>
<li>第二阶段
<ul>
<li>本地多播路由器周期性探询本地主机，判断其是否还是组中成员</li>
<li>如果本地主机是组中成员，收到探询后需要回复响应</li>
</ul></li>
</ul></li>
</ul>
<h3 id="组播路由选择协议">组播路由选择协议</h3>
<ul>
<li>本质作用
<ul>
<li>给定源点和目标多播组</li>
<li>找到以该源点为根，以组播路由器为结点的组播转发树
<ul>
<li>叶子对应的组播路由器和多播组的某成员在一个局域网</li>
<li>树的特性保证不会出现路由环路</li>
</ul></li>
</ul></li>
<li>路由算法
<ul>
<li>基于距离向量算法</li>
<li>基于链路状态算法</li>
<li>协议无关组播PIM</li>
</ul></li>
</ul>
<h2 id="移动ip">移动IP</h2>
<h3 id="基本概念-1">基本概念</h3>
<ul>
<li>定义
<ul>
<li>保证移动结点在跨网段漫游时<strong>保持IP地址和网络权限不变</strong></li>
</ul></li>
<li>有关概念
<ul>
<li>移动结点：指跨网段漫游的主机</li>
<li>永久地址（归属地址）：移动结点原始的IP地址</li>
<li>归属网络：移动结点原始连接的网络</li>
<li>本地代理（归属代理）：归属网络中实现<strong>代理</strong>功能的路由器或主机
<ul>
<li>代理作为一个应用层的功能，结合后面的通信过程理解</li>
</ul></li>
<li>外地网络（被访网络）：移动结点离开归属网络后，处于外地网络</li>
<li>外部代理：外部网络中实现<strong>代理</strong>功能的路由器或主机</li>
<li>转交地址：移动结点在外部网络的临时IP地址</li>
</ul></li>
</ul>
<h3 id="通信过程">通信过程</h3>
<ul>
<li>移动结点在本地网络，按传统TCP/IP方式通信</li>
<li>移动结点漫游到第一个外地网络（锚外地网络）
<ul>
<li>在该外地网络发现外地代理（锚外地代理）</li>
<li>外地代理记录移动结点的MAC地址，并为其注册转交地址
<ul>
<li>该地址仅供外地代理、归属代理、移动结点使用，在互联网中不需要唯一</li>
</ul></li>
<li>外地代理把转交地址通知移动结点的归属代理</li>
<li>归属代理登记移动结点的转交地址信息
<ul>
<li>同时构建一条通往外地代理的隧道</li>
</ul></li>
</ul></li>
<li>某主机发分组给移动结点
<ul>
<li>首先到达归属代理</li>
<li>归属代理把分组的归属地址改成转交地址，发给外地代理</li>
<li>外地代理把分组的转交地址改成归属地址，并进一步改成移动结点的MAC地址</li>
<li>移动结点收到分组</li>
</ul></li>
<li>移动结点发分组给某主机
<ul>
<li>源地址为归属地址，目的地址为相应IP地址，直接发送即可
<ul>
<li>不经过归属代理</li>
</ul></li>
</ul></li>
<li>移动结点漫游到其他外地网络
<ul>
<li>移动结点把之前的外地代理中的转交地址注销
<ul>
<li>归属代理处的旧转交地址不需要由之前的外地代理注销，后面会被新转交地址替代</li>
</ul></li>
<li>在新的外地网络中发现外地代理，后面和锚外地网络同理</li>
</ul></li>
<li>移动结点回到本地网
<ul>
<li>注销外地代理和归属代理的转交地址，按传统TCP/IP方式通信</li>
</ul></li>
</ul>
<h2 id="网络层设备">网络层设备</h2>
<p><em>本节和前面的网络层功能路由和转发的互为补充</em></p>
<h3 id="路由器">路由器</h3>
<ul>
<li>组成
<ul>
<li>路由选择部分（控制部分）
<ul>
<li>路由选择处理机（含有路由表）</li>
</ul></li>
<li>分组转发部分
<ul>
<li>输入端口</li>
<li>交换结构（含有转发表）</li>
<li>输出端口</li>
</ul></li>
</ul></li>
<li>功能
<ul>
<li>可以连接不同协议的各网络，隔离广播域</li>
<li>核心的功能是路由和转发（本章前面已有介绍）</li>
</ul></li>
<li>实现OSI模型的层包括
<ul>
<li>物理层</li>
<li>数据链路层</li>
<li>网络层</li>
</ul></li>
</ul>
<h3 id="路由表和路由转发">路由表和路由转发</h3>
<ul>
<li>路由表项的默认列
<ul>
<li>目的网络IP地址</li>
<li>子网掩码</li>
<li>下一跳IP地址
<ul>
<li>若直连则直接交付，不需要填下一跳</li>
</ul></li>
<li>接口</li>
</ul></li>
<li>转发表的默认列
<ul>
<li>目的网络IP地址
<ul>
<li>以太网交换机中的转发表，没有该项</li>
</ul></li>
<li>下一跳MAC地址</li>
<li>接口</li>
</ul></li>
<li>路由
<ul>
<li>由软件实现</li>
<li>在数据达到前可以提前计算、更新路由</li>
</ul></li>
<li>转发
<ul>
<li>一般由硬件实现，也可以软件实现</li>
<li>在数据达到后才进行转发
<ul>
<li>更新转发表：根据输入端口传来的数据报的目的IP地址，用路由表和ARP表得到出转发表项</li>
<li>硬件实现交换：输入<strong>目的IP地址</strong>，把数据报和<strong>下一跳MAC地址</strong>发送到相应<strong>接口</strong>（将来在输出端口组装为帧和比特流）</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第三章-存储器层次结构</title>
    <url>/2021/10/25/ComputerOrganization-3/</url>
    <content><![CDATA[<h2 id="存储器概述">存储器概述</h2>
<ul>
<li>存储元：一个二进制物理器件</li>
<li>存储单元：多个存储元组成，一般是一次存取的单位</li>
<li>存储体：若干存储单元</li>
</ul>
<h3 id="存储器分类">存储器分类</h3>
<ul>
<li>按作用/层次分类
<ul>
<li>主存储器
<ul>
<li>即内存，存放计算机运行期间的数据和程序</li>
<li>CPU可以直接进行访问，也可以和Cache和辅存交换数据</li>
<li>容量较小，速度较快，价格较高</li>
</ul></li>
<li>辅助存储器
<ul>
<li>即外存，存放暂时不用的数据和程序，或需要长期保存的信息。</li>
<li>CPU不能直接访问</li>
<li>容量大，速度慢，成本低</li>
</ul></li>
<li>高速缓冲存储器
<ul>
<li>即Cache，位于主存和CPU之间，存放正在执行的程序段和数据，加速CPU访问数据</li>
<li>CPU可以直接进行访问，可以和内存交换数据</li>
<li>容量小，价格高，存取速度和CPU速度匹配</li>
</ul></li>
</ul></li>
<li>按存取方式分类
<ul>
<li>随机存储器RAM
<ul>
<li>存取时间和位置无关，可随机存取，使用方便</li>
<li>常用于主存和缓冲存储器</li>
<li>可分为静态RAM（SRAM），动态RAM（DRAM）</li>
</ul></li>
<li>只读存储器ROM
<ul>
<li>只能随机读出，不能写入</li>
<li>通常存放不变的程序、字库、常数，和RAM共同作为主存的一部分</li>
</ul></li>
<li>串行访问存储器
<ul>
<li>顺序存取存储器SAM：只能按某种顺序存取，存取时间和位置有关，速度慢，如磁带</li>
<li>直接存取存储器DAM：不是全局随机存取，也不是完全顺序存取，折中方案。先确定数据所在小区域，在区域内顺序查找，如磁盘、光盘（详见第7章笔记）</li>
</ul></li>
</ul></li>
<li>按存储介质分类
<ul>
<li>磁表面存储器
<ul>
<li>磁盘</li>
<li>磁带</li>
</ul></li>
<li>磁芯存储器</li>
<li>半导体存储器
<ul>
<li>MOS型存储器</li>
<li>双极型存储器</li>
</ul></li>
<li>光存储器
<ul>
<li>光盘</li>
<li>比如CD-ROM是只读型光盘，串行访问存储器，不是只读存储器ROM</li>
<li>详见第7章笔记</li>
</ul></li>
</ul></li>
<li>按信息的可保存性分类
<ul>
<li>易失性存储器
<ul>
<li>断电后存储信息就会消失</li>
<li>如RAM</li>
</ul></li>
<li>非易失性存储器
<ul>
<li>断电后存储信息不会消失</li>
<li>如ROM、磁表面存储器、光存储器</li>
</ul></li>
</ul></li>
</ul>
<h3 id="存储器性能指标">存储器性能指标</h3>
<ul>
<li>存储容量
<ul>
<li>存储字数<span class="math inline">\(\times\)</span>字长</li>
<li>字数是地址空间大小，字长是一次存取的数据量</li>
</ul></li>
<li>单位成本：总成本/总容量</li>
<li>存储速度
<ul>
<li>存取时间<span class="math inline">\(T_a\)</span>：启动一次存储器操作到完成操作所需时间，具体区分为读出时间、写入时间</li>
<li>存取周期<span class="math inline">\(T_m\)</span>
<ul>
<li>两次独立访存之间所需最小时间间隔，即完整一次读写操作需要的时间</li>
<li>存取周期分为存取时间和恢复时间（有的存取是有破坏性的，需要恢复），因此一般情况<span class="math inline">\(T_m&gt;T_a\)</span></li>
</ul></li>
<li>数据宽度<span class="math inline">\(W\)</span>：一个周期内可以从存储器进出的数据量</li>
<li>数据传输率<span class="math inline">\(B_m\)</span>：
<ul>
<li>又叫主存带宽，是单位时间内从主存进出的最大数据量</li>
<li><span class="math inline">\(B_m=\frac{W}{T_m}\)</span>，单位可以是字/秒、B/s、b/s</li>
</ul></li>
</ul></li>
</ul>
<h2 id="层次化存储器的基本结构">层次化存储器的基本结构</h2>
<ul>
<li>多级存储系统的目的：解决存储器大容量、高速度、低成本的矛盾，上层作为下层的高速缓存（数据是副本），使得CPU访问速度接近最上层，容量和成本接近最下层，性价比大幅度提高</li>
<li>层级结构从上到下：
<ul>
<li>寄存器、Cache、主存、磁盘、磁带或光盘</li>
<li>速度和成本递减，容量递增</li>
</ul></li>
<li>主要层次
<ul>
<li>Cache-主存层次
<ul>
<li>构成高速缓冲存储器，解决CPU和主存速度不匹配的问题</li>
<li>速度接近Cache，容量和成本接近主存</li>
<li>数据调动由硬件自动完成，对所有程序员透明（看不见）</li>
</ul></li>
<li>主存-辅存层次
<ul>
<li>构成虚拟存储系统，解决存储系统的容量问题</li>
<li>速度接近主存，容量和成本接近辅存</li>
<li>数据调动由硬件和操作系统共同完成，对应用程序员透明（看不见）</li>
</ul></li>
</ul></li>
<li>CPU、Cache、主存相互之间可以直接交换信息，辅存只能和主存交换信息</li>
</ul>
<h2 id="半导体随机存取存储器">半导体随机存取存储器</h2>
<ul>
<li>RAM（全称random-access memory）和ROM（全称read-only
memory）都属于半导体存储器</li>
<li>前者支持随机存储，后者部分支持随机存储</li>
</ul>
<h3 id="sram存储器">SRAM存储器</h3>
<ul>
<li>又叫做静态随机存储器，常用于实现Cache</li>
<li>易失性存储器</li>
<li>存储元一般是双稳态触发器（六晶体管MOS），非破坏性读出</li>
<li>行列独立技术，组织成数组，地址信号一次传送</li>
<li>相比DRAM价格高，存取快，集成度低，容量较小，功耗大</li>
<li>不需要刷新（后面会解释刷新）</li>
</ul>
<h3 id="dram存储器">DRAM存储器</h3>
<ul>
<li>又叫做动态随机存储器，常用于实现主存储器</li>
<li>易失性存储器</li>
<li>存储元一般是栅极电容（单晶体管），比SRAM密度高很多，大都是破坏性读出</li>
<li>行列地址复用技术，组织成矩阵，地址信号分行列两次传送</li>
<li>相比SRAM价格低，存取慢，集成度高，容量大，功耗低</li>
<li>DRAM为了维持电荷，需要在刷新周期内（通常2ms）刷新
<ul>
<li>刷新方法
<ul>
<li>集中刷新：停止读写，用一段固定时间（少于刷新周期）刷新，读写不受刷新影响但期间不能访问存储器（称为死区）</li>
<li>分散刷新：每个存储周期内（通常微秒级别，且存取时间和刷新时间各占存储周期的一半）刷新一行，分多个周期刷新，没有死区但存取周期长</li>
<li>异步刷新：前两个方法的结合，根据刷新周期/行数，得到两次刷新行操作需要的时间间隔t，利用逻辑电路t时间产生一次刷新请求进行刷新，比集中刷新的死区短，比分散刷新的刷新次数少</li>
</ul></li>
<li>刷新说明
<ul>
<li>以行为单位进行刷新，<strong>所有存储芯片</strong>的同一行同时刷新</li>
<li>刷新对CPU透明，芯片内部自行生成行地址</li>
<li>刷新内部本质类似于读操作，一次刷新时间等于一次访存时间</li>
<li>不是易失性存储器都需要刷新，比如SRAM不需要，DRAM需要</li>
</ul></li>
</ul></li>
</ul>
<h3 id="rom存储器">ROM存储器</h3>
<ul>
<li>和RAM一样都是支持随机存取的存储器，但只供读出</li>
<li>非易失性半导体存储器，可靠性高</li>
<li>结构简单，位密度比可读写存储器高</li>
<li>类型包括
<ul>
<li>掩模式只读存储器MROM
<ul>
<li>半导体制造厂按用户要求在生产时写入，此后无法改变</li>
<li>可靠性高、集成度高、便宜，但不灵活</li>
</ul></li>
<li>一次可编程只读存储器PROM
<ul>
<li>可以实现一次性编程的只读存储器</li>
<li>写入后无法改变</li>
</ul></li>
<li>可擦除可编程只读存储器EPROM
<ul>
<li>可以由编程器写入信息</li>
<li>写入后可以先擦除全部内容再修改</li>
<li>分为紫外线擦除UVEPROM和电擦除EEPROM</li>
<li>虽然可读可写，但是编程次数有限，写入时间很长，无法代替RAM</li>
</ul></li>
<li>闪速存储器Flash Memory
<ul>
<li>在EPROM和EEPROM基础上发展起来的</li>
<li>具备EPROM价格便宜，集成度高的特点</li>
<li>具备EEPROM的性能，且可以快速读取、快速擦除和重写</li>
<li>断电后可长期保存信息</li>
<li>反复写后会磨损</li>
<li>比如U盘和MP3</li>
<li>具体分为两种
<ul>
<li>NOR Flash：读取速度快，用户能直接运行NOR
Flash中代码，适合小容量存储器</li>
<li>NAND Flash：一次读一个块，价格便宜，用户不能直接运行NAND
Flash中代码，适合大容量存储器</li>
</ul></li>
</ul></li>
<li>固态硬盘Solid State Drive（SSD）
<ul>
<li>基于闪存技术，用固态电子存储芯片阵列制成（固体电容称作Solid）</li>
<li>和U盘本质差不多，但容量更大，存取性能更好</li>
<li>由控制单元（Flash翻译层）和存储单元（Flash芯片或DRAM芯片）组成</li>
<li>和Flash存储器一样可长期保存信息、可快速擦除重写</li>
<li>比传统磁盘读写快、质量轻、功耗低、体积小、抗震性好、安全性高、无噪音</li>
<li>缺点是价格高、容量不算很大、寿命短、容易磨损、数据破坏后难恢复</li>
</ul></li>
</ul></li>
</ul>
<h2 id="主存储器">主存储器</h2>
<h3 id="主存储器的组成">主存储器的组成</h3>
<ul>
<li>地址寄存器：和CPU的MAR通过地址线相连</li>
<li>地址译码器：对地址寄存器内容进行译码，选择相应存储单元</li>
<li>存储体：字数个存储单元组成，每个存储单元是字长个存储元件（0和1）</li>
<li>读写控制电路：接收CPU中读写控制信号，控制存储体和CPU的MDR交换信息</li>
<li>MAR和MDR的位数对应存储器中的字数的位数和字的位数（即字长）</li>
</ul>
<h3 id="dram芯片和内存条">DRAM芯片和内存条</h3>
<h4 id="dram存储芯片">DRAM存储芯片</h4>
<ul>
<li>内部结构
<ul>
<li>存储体：即存储矩阵，由行选择线、列选择线访问单元。</li>
<li>地址译码器：根据地址驱动相应读写电路</li>
<li>读写控制逻辑（IO控制电路）：控制被选中的存储单元的输入和输出</li>
</ul></li>
<li>外部引脚
<ul>
<li>地址线：位数和存储空间大小有关</li>
<li>数据线：位数和存储单元大小有关</li>
<li>读写控制线：2位线（读线<span class="math inline">\(\overline{RD}\)</span>、写线<span class="math inline">\(\overline{WE}\)</span>，若共用<span class="math inline">\(\overline{WE}\)</span>则只需要1位线）</li>
<li>片选信号线：1位CS线，存储器一般用多个芯片进行拓展，访问时需要片选信号控制是否选该片</li>
<li>电源线和地线</li>
</ul></li>
<li>DRAM芯片需要定时刷新、地址线采用复用技术（地址线为正常的一半，容易忽略）</li>
<li>常见的DRAM芯片有
<ul>
<li>EDORAM：extend data output RAM</li>
<li>DDR RAM：double data rate RAM，也叫DDR
SDRAM。一个时钟读写两次，传输速度加倍</li>
<li>SDRAM：synchronous dynamic RAM</li>
</ul></li>
<li>DRAM芯片读写周期
<ul>
<li>读写周期表示DRAM芯片两次连续读写操作所必须间隔的时间</li>
<li>读出（写入）时间比如读写周期小，从地址有效开始，并要求CS地址片选信号有效</li>
<li>RAS有效后将行地址送入引脚</li>
<li>CAS有效后将列地址送入引脚</li>
<li>读周期时<span class="math inline">\(\overline{WE}\)</span>为高电平，需要在CAS有效前建立</li>
<li>写周期时<span class="math inline">\(\overline{WE}\)</span>为低电平，需要在CAS有效前建立；写数据在CAS有效前保持稳定</li>
</ul></li>
</ul>
<img src="/2021/10/25/ComputerOrganization-3/T.png" class title="this is period of DRAM chip">
<h4 id="内存条">内存条</h4>
<ul>
<li>对容量较小的单个芯片进行拓展，将多个芯片集成到一个内存条上，再由多个内存条和主板的ROM芯片组成主存空间</li>
<li>拓展的方法有
<ul>
<li>位拓展
<ul>
<li>加大字长</li>
<li>各芯片读写信号相连，接CPU读写控制线</li>
<li>各芯片地址线相连，接系统地址总线</li>
<li>各芯片的片选线相同，保证同时选中（各芯片的同位置单元）</li>
<li>各芯片单独引出各自的数据线，连接数据总线的各对应位</li>
</ul></li>
<li>字拓展
<ul>
<li>加大字数</li>
<li>各芯片读写信号相连，接CPU读写控制线</li>
<li>各芯片地址线相连，接系统地址总线的<strong>低位</strong></li>
<li>各芯片的片选线不同，由系统地址总线的<strong>高位</strong>译码得到（后面将提到片选信号的译码方法）</li>
<li>各芯片的数据线，连接数据总线</li>
</ul></li>
<li>字位同时拓展
<ul>
<li>加大字数和字长，各芯片分组，组内进行位拓展，组间进行字拓展</li>
<li>各芯片读写信号相连，接CPU读写控制线</li>
<li>各芯片地址相连，接系统地址总线低位</li>
<li>各芯片片选线组间不同、组内相同。由系统地址总线的高位译码得到</li>
</ul></li>
</ul></li>
<li>片选信号的译码方法
<ul>
<li>线选法
<ul>
<li>高位的每位各自直接（或经过反相器）接到各芯片的片选端口，高位的各位中只能有一个1（或一个0）。</li>
<li>优点是不需要地址译码器，线路简单</li>
<li>缺点是地址不连续，空间利用不充分即地址资源存在浪费</li>
</ul></li>
<li>译码法
<ul>
<li>需要地址译码器，<span class="math inline">\(n\)</span>个高位对应<span class="math inline">\(2^n\)</span>个输出线，接到对应的片的片选信号端口</li>
<li>地址连续</li>
<li>根据高位是否全部被使用进行译码，进一步分为全译码法和部分译码法</li>
</ul></li>
</ul></li>
</ul>
<h3 id="主存和cpu之间的连接">主存和CPU之间的连接</h3>
<ul>
<li>主存储器通过数据总线、地址总线、控制总线连接到CPU的MDR、MAR、读写控制信号</li>
<li>数据总线的位数就是数据宽度（前面存储器性能小节中提到过），当存储芯片位数不足数据宽度时需要用多个芯片进行位拓展</li>
<li>地址总线的位数决定了可寻址最大空间
<ul>
<li>一般地址总线高位接到主存的地址译码器，一般是74LS138译码器。译码器的输入还需要接CPU的访存控制信号<span class="math inline">\(\overline{MREQ}\)</span>，低电平有效，比如访问io时为高电平，表示不需要访问存储</li>
<li>一般地址总线低位接到每个芯片的地址线</li>
</ul></li>
<li>控制总线指出了总线周期的类型（读或写）和本次操作完成的时刻。
<ul>
<li>如果读写只用一根线<span class="math inline">\(\overline{WE}\)</span>，一般高电平为读，低电平为写</li>
<li>如果读写各自用一根线，则读命令线<span class="math inline">\(\overline{RD}\)</span>和写命令线<span class="math inline">\(\overline{WE}\)</span>都是低电平有效</li>
</ul></li>
</ul>
<h3 id="双端口ram和多模块存储器">双端口RAM和多模块存储器</h3>
<ul>
<li>为了提高CPU访存速度，采用双端口RAM（空间并行）、多模块存储器（时间并行）</li>
<li>双端口RAM
<ul>
<li>存储器左右两个独立端口，有独立的数据线、地址线、控制线</li>
<li>两个控制器允许同时异步的访问存储单元</li>
<li>如果对不同地址读写，或对同一地址读，无冲突</li>
<li>如果对同一地址写则有写冲突；如果对同一地址读和写，则有读冲突</li>
<li>解决冲突的方法
<ul>
<li>把<span class="math inline">\(\overline{BUSY}\)</span>信号置0，相当于暂时关闭一个端口，延迟其访问</li>
<li>对每个存储看单元的数据进行CPU的权限分配</li>
</ul></li>
</ul></li>
<li>多模块存储器
<ul>
<li>单体多字存储器
<ul>
<li>一个存储体，每个存储单元多个字，比如m个</li>
<li>总线宽度也是m个字，一次并行读出</li>
<li>一个存取周期能取出m个指令，每隔1/m周期CPU向主存取一条指令，带宽增加</li>
<li>缺点是只能处理连续情况，遇到转移指令，效果不明显</li>
</ul></li>
<li>多体并行存储器（多体交叉存储器）
<ul>
<li>多个存储体模块，每个模块有独立的控制电路、地址寄存器、数据寄存器，可并行</li>
<li>高位交叉编址：高位表示体号，低位表示体内地址，本质还是顺序访问，吞吐量基本不能提高</li>
<li>低位交叉编址：低位表示体号，高位表示体内地址，此时可以流水线并行存取，提高存储器带宽。设模块字长等于总线宽度，模块存取周期是T，总线传送周期是r（每隔至少r启动流水线下一模块，一般取r），模块数（交叉存取度）不小于T/r，使得每个模块的启动间隔大于T。因此，连续存取m个字需要时间T+(m-1)r，小于顺序存取时间mT，带宽明显提高。</li>
</ul></li>
</ul></li>
</ul>
<h2 id="外部存储器">外部存储器</h2>
<h3 id="磁盘存储器">磁盘存储器</h3>
<ul>
<li>利用磁记录技术在涂有磁记录介质的旋转圆盘上进行数据存储</li>
<li>一般用于辅助存储器</li>
<li>由磁盘、磁盘驱动器、磁盘控制器构成</li>
<li>磁盘一般装在磁盘驱动器上，其数据的定位类似于柱坐标（盘面层号对应高度、扇区号对应角度、磁道号对应半径）</li>
<li>磁盘驱动器即磁盘机，是驱动磁盘转动并在盘面上通过磁头进行读写的装置</li>
<li>磁盘控制器即磁盘驱动器适配器，属于磁盘面向计算机的接口设备，接受计算机命令，向磁盘驱动器发出控制信号</li>
<li>存储容量大、数据传输率高、可长期保存</li>
<li>计组笔记第7章输入输出系统、操作系统的输入输出管理的外存管理部分也有介绍</li>
</ul>
<h3 id="固态硬盘ssd">固态硬盘SSD</h3>
<ul>
<li>参考前面ROM存储器的固态硬盘内容</li>
</ul>
<h2 id="高速缓冲存储器cache">高速缓冲存储器Cache</h2>
<h3 id="程序访问局部性原理">程序访问局部性原理</h3>
<ul>
<li>时间局部性：最近要用的信息可能是现在正在用的信息</li>
<li>空间局部性：最近要用的信息在存储空间里和正在用的信息是相邻的</li>
<li>利用程序局部性原理，把程序正在使用的部分存放的高速、容量较小的Cache中，使得访存操作通过Cache进行，提高程序速度</li>
</ul>
<h3 id="cache基本原理">Cache基本原理</h3>
<ul>
<li>通常由SRAM构成</li>
<li>主存和Cache划分为相等的块，Cache块又叫Cache行，每块有若干字节，块长度被称为块长或Cache行长</li>
<li>Cache块数远小于主存块数，仅保存主存最活跃的部分块</li>
<li>CPU发出读请求时
<ul>
<li>如果命中Cache，则地址转换为Cache地址，直接对Cache读</li>
<li>如果没命中Cache，则需要访问主存，并把该字所在块从主存调入Cache
<ul>
<li>如果Cache未满，则直接调入</li>
<li>如果Cache已满，根据替换算法，进行Cache中块的替换</li>
</ul></li>
<li>CPU和Cache交换字，主存和Cache交换块</li>
</ul></li>
<li>CPU发出写请求时
<ul>
<li>如果命中Cache，则要考虑Cache数据和内存数据的一致性问题，采取一定的写策略，如
<ul>
<li>全写法</li>
<li>写回法</li>
</ul></li>
<li>如果未命中Cache，则根据块是否调入Cache，可以分为
<ul>
<li>写分配法</li>
<li>非写分配法</li>
</ul></li>
</ul></li>
<li>Cache命中率指的是CPU欲访问信息在Cache中的比率，越接近1越好</li>
<li>假设<span class="math inline">\(t_c\)</span>是命中情况的Cache访问时间，<span class="math inline">\(t_m\)</span>是未命中情况的访问时间（有可能比访问内存时间长，因为要先检查是否命中Cache），<span class="math inline">\(H\)</span>是命中率，则<span class="math inline">\(H\times t_c+(1-H)\times
t_m\)</span>是Cache-内存系统平均访问时间</li>
<li>Cache的结构为
<ul>
<li>存储主存信息的数据块</li>
<li>有效位：表示内容是否有用</li>
<li>标记位：标记该Cache行对应主存哪个块，位数和地址映射方式有关</li>
<li>块修改标记：提供写策略使用</li>
<li>替换标记：提供替换策略使用</li>
</ul></li>
</ul>
<h3 id="cache和主存间映射方式">Cache和主存间映射方式</h3>
<ul>
<li>映射指的是从主存地址映射到Cache地址</li>
<li>Cache中的每个块都标记了其在内存中对应的块位置（块号），并有一个块有效位</li>
<li>主要方法有
<ul>
<li>直接映射
<ul>
<li>主存每个块映射到Cache唯一位置。如果冲突直接替换，不需要替换算法</li>
<li>实现简单但不灵活。</li>
<li>主存块号<span class="math inline">\(p_{mem}\)</span>的低c位是Cache行号<span class="math inline">\(p_{cache}\)</span>，即<span class="math inline">\(p_{cache}=p_{mem}\ mod\
2^{c}\)</span>，高t位存入对应Cache行的标记中</li>
<li>主存地址的结构是：主存区号（作为Cache标记）、主存区内块号（等于Cache行号）、块内地址，前两者合并就是主存块号</li>
<li>访存先根据Cache行号对比Cache行的标记和主存地址的高t位是否一致，一致且有效位是1则命中，根据块内地址存取Cache行信息；否则不命中，先从主存读该地址对应的块到Cache中，并设置有效位为1，并标记高t位，然后将地址对应的数据送到CPU</li>
</ul></li>
<li>全相联映射
<ul>
<li>主存块可以映射到Cache任何一位置，CPU访存需要和所有Cache行标记对比</li>
<li>灵活、冲突率低、空间利用率高、命中率高，但是标记比较速度慢，一般要用高成本的相联存储器（<strong>通常按内容寻址，也可以按地址寻址</strong>）进行映射</li>
<li>主存的地址结构是：主存块号（作为Cache标记）、块内地址</li>
</ul></li>
<li>组相联映射
<ul>
<li>把Cache空间分组，组间直接映射，组内全相联，访存需要和对应组的所有Cache行标记对比</li>
<li>主存的地址结构是：主存区号、组内块号、组号、块内地址。前两者作为标记存入Cache；前三者就是主存块号</li>
<li>注意主存地址的组号是主存块号的低位，位数由组数来确定。这意味着主存中连续的块，在Cache中对应不同的分组</li>
<li>n路组相联，表示每个组有n个块；n为1（即组数为Cache块数）则变为直接映射；n为Cache块数（即组数为1）则变为全相联</li>
<li>访存先根据组号找到Cache组，再对比组内每个Cache块的标记。然后相等且有效位为1则命中，否则不命中。</li>
</ul></li>
</ul></li>
</ul>
<h3 id="cache中主存块替换算法">Cache中主存块替换算法</h3>
<ul>
<li>对应全相联和组相联，当需要把主存块调入已满的Cache时，需要进行替换</li>
<li>常见的有
<ul>
<li>随机算法RAND
<ul>
<li>随即确定替换块，实现简单</li>
<li>未考虑程序局部性原理，命中率可能低</li>
</ul></li>
<li>先进先出算法FIFO
<ul>
<li>选最早进入的块替换，实现简单</li>
<li>未考虑程序局部性原理，命中率可能低</li>
</ul></li>
<li>近期最少用算法LRU
<ul>
<li>选最久没使用的块替换，考虑局部性原理，命中率比FIFO高</li>
<li>设置一个计数器，最近访问的Cache块（可能是新调入的，或命中原本Cache的）的计数器置0，Cache中已有的其他块计数器加1</li>
<li>计数器的位数等于组内块数对应的位数，即计数器的值小于组内块数，当计数器的值自增达到上限后，不再自增</li>
<li>如果Cache已满需要替换，则移出计数器值最大（等于组内块数减1）的块</li>
<li>当集中访问的、映射到同一组的存储块数超过了组内块数，很可能出现命中率很低的情况，称为抖动现象</li>
</ul></li>
<li>最不经常使用LFU算法
<ul>
<li>选近期访问次数最少的块替换</li>
<li>每行设置一个计数器，新建的块从0开始计数</li>
<li>每命中一次计数器加1，替换时把计数器最小的块移出</li>
<li>和LRU类似思想但又有不同</li>
</ul></li>
</ul></li>
</ul>
<h3 id="cache写策略">Cache写策略</h3>
<ul>
<li>写策略主要处理Cache和主存数据的一致性问题</li>
<li>当Cache写命中时
<ul>
<li>全写法（写直通法、写直达法、write through）
<ul>
<li>数据同时写入Cache和主存</li>
<li>好处是实现简单，替换块时不需要写回，随时保证主存数据准确</li>
<li>坏处是增加访存次数，降低Cache效率</li>
<li>可以在Cache和主存间加一个写缓冲，数据同时写入Cache和写缓冲器，一定程度解决速度不匹配问题，但也存在缓冲器溢出问题</li>
</ul></li>
<li>写回法（write back）
<ul>
<li>只修改Cache</li>
<li>当块被替换掉时再写回主存</li>
<li>Cache行设置脏位，标记该块是否改过</li>
<li>减少访存次数，但有数据不一致的风险</li>
</ul></li>
</ul></li>
<li>当Cache未命中时
<ul>
<li>写分配法（write-allocate）
<ul>
<li>加载主存的块到Cache中，然后更新这个Cache块</li>
<li>和写回法配合使用，缺点是每次不命中都需要读取主存的块</li>
</ul></li>
<li>非写分配法（not-write-allocate）
<ul>
<li>只更新主存，不调块到Cache</li>
<li>和全写法配合使用，缺点是未考虑程序空间局部性</li>
</ul></li>
<li>现代计算机往往采用多级Cache（通常3级）
<ul>
<li>按离CPU从近到远分为L1 Cache、L2 Cache、L3
Cache等，速度递减，容量递增</li>
<li>比如两级Cache系统中，L1 Cache和L2 Cache采用全写法，因为访问L2
Cache速度比访问主存快，没有缓冲器溢出问题；L2
Cache和主存采用写回法，减少访存的次数。</li>
</ul></li>
</ul></li>
</ul>
<h2 id="虚拟存储器">虚拟存储器</h2>
<h3 id="虚拟存储器的基本概念">虚拟存储器的基本概念</h3>
<ul>
<li>虚拟存储器由主存和辅存共同构成，具有前者的速度和后者的空间</li>
<li>虚地址
<ul>
<li>又叫逻辑地址、程序地址，是编程允许涉及的地址</li>
<li>对应的存储空间为虚拟空间（程序空间）</li>
<li>虚地址=虚存页号+页内字地址</li>
</ul></li>
<li>实地址
<ul>
<li>又叫物理地址，是实际的主存单元地址</li>
<li>对应的存储空间为实地址空间（主存地址空间）</li>
<li>实地址=主存页号+页内字地址</li>
</ul></li>
<li>辅存地址
<ul>
<li>辅存的单元地址</li>
<li>对应的存储空间为辅存空间</li>
<li>辅存地址=磁盘号+盘面号+磁道号+扇区号</li>
</ul></li>
<li>CPU使用虚地址时，先由辅助软硬件找到虚地址和实地址的关系，判断该地址对应存储单元是否装入主存
<ul>
<li>若在主存，则通过地址变换，CPU直接访问主存对应单元</li>
<li>若不在主存，则把该字的一个页或一个段调入主存后再由CPU访问；若主存已满则需要使用替换算法。</li>
</ul></li>
</ul>
<h3 id="页式虚拟存储器">页式虚拟存储器</h3>
<ul>
<li>基本原理
<ul>
<li>页式存储器以页为基本单位，虚拟空间和主存空间划分为同样大小的页，分别叫虚页和实页（也可以叫页框、页帧、块）。外存中也按同样大小划分，叫块</li>
<li>虚拟地址分为虚页号和页内地址，由页表转换为物理地址</li>
</ul></li>
<li>页表
<ul>
<li>随着进程的建立，对应进程页表被建立</li>
<li>长期保存在主存中
<ul>
<li>进程切换运行时，页表被调入主存</li>
<li>页表首地址和长度（用于越界检查）保存在进程控制块中，在进程执行时，存入页表基址寄存器PTR</li>
</ul></li>
<li>每个页表项包含
<ul>
<li>有效位（装入位、状态位）：对应页是否在主存</li>
<li>脏位（修改位）：页面是否被修改过，一般结合回写策略，在页面从主存中被替换时写回磁盘</li>
<li>引用位（访问字段）：配合替换策略进行设置，比如帮助实现FIFO或LRU策略</li>
<li>物理页号或磁盘地址</li>
</ul></li>
</ul></li>
<li>虚拟地址转换到物理地址步骤
<ul>
<li>查页表前先进行越界检查</li>
<li>然后通过虚页号（虚拟地址高位，作为页表的索引）和页表首地址找到页表项</li>
<li>如果有效则取出物理页号，和虚拟地址低位页内地址拼接，成为物理地址</li>
<li>如果无效则缺页，需要操作系统先进行缺页处理</li>
</ul></li>
<li>优点是页长固定，页表简单，调入方便；缺点是程序不一定是页整数倍，最后一页可能有空间浪费，同时页没有逻辑含义，不方便处理、保护、共享</li>
<li>快表TLB
<ul>
<li>专门存放主存中页表的部分表项的缓冲表（类似于Cache）</li>
<li>通常是全相联或组相联</li>
<li>TLB表项包括：页表表项内容、TLB标记</li>
<li>TLB标记表示该TLB表项来自主存页表的哪一个表项
<ul>
<li>全相联方式，TLB标记就是虚页号</li>
<li>组相联方式，TLB标记是虚页号的高位，虚页号的低位是TLB的组号</li>
</ul></li>
<li>如果查表时标记相等且有效位为1则命中，直接用TLB进行地址转换</li>
<li>如果不命中，则TLB缺失，需要访问主存查页表
<ul>
<li>如果TLB未满，则把主存页表中相应表项调入TLB页表</li>
<li>如果TLB已满，则需要替换策略</li>
</ul></li>
</ul></li>
<li>多级页表
<ul>
<li>考虑页表需要在内存中分配连续空间，页表较大时应当采用多级索引的方式</li>
<li>比如IA-32（因特尔32位架构）中采取二级索引，虚页号进一步分成页目录索引、页表索引两个部分。先用页目录物理首地址（存放在用户不可见的控制寄存器CR3中）和页目录索引确定页表物理首地址，再结合页表索引确定物理页号</li>
</ul></li>
<li>具有TLB和Cache的多级存储系统
<ul>
<li>首先进行虚拟地址到物理地址的转换，（涉及快表TLB、多级页表、缺页处理）</li>
<li>然后根据物理地址，在Cache-主存系统中存取相应的数据</li>
<li>可能发生的缺失
<ul>
<li>TLB缺失：硬件或软件（操作系统）处理，需要访问主存</li>
<li>缺页：软件（操作系统)处理，需要访问辅存（磁盘）</li>
<li>Cache缺失：硬件处理，需要访问内存</li>
</ul></li>
</ul></li>
</ul>
<h3 id="段式虚拟存储器">段式虚拟存储器</h3>
<ul>
<li>主存按程序的逻辑分段，以段为主存和辅存的调度单位，各段长不一定</li>
<li>虚拟地址分为段号和段内地址（由用户显式提供，实际设计一般是编译器实现），物理地址分为物理段号和段内地址</li>
<li>页式虚拟地址是一维的（可以分解为页号和页内地址），段式虚拟地址是二维的（段号和段内地址必须分别给出），是因为页大小固定，段大小不固定</li>
<li>段表
<ul>
<li>指出各段在主存中的首地址</li>
<li>包括段号、段长、段起始地址（高位相当于物理段号）、有效位（装入位）、段访问方式和标记等</li>
<li>段表的首地址和长度（用于越界检查）存放在段表寄存器</li>
</ul></li>
<li>虚拟地址转换到物理地址步骤
<ul>
<li>查段表前先进行越界检查</li>
<li>再通过段表基地址和段号找到对应段表项</li>
<li>如果有效且段内偏移量不越界，则把段表项的段起始地址 +
段内地址（偏移量），得到物理地址</li>
</ul></li>
<li>优点是段的分界和程序分界对应，易于编译、管理、修改、保护、共享；缺点是段长度可变，分配空间不便，主存中容易产生段内碎片的浪费</li>
</ul>
<h3 id="段页式虚拟存储器">段页式虚拟存储器</h3>
<h4 id="设计思想">设计思想</h4>
<ul>
<li>程序按逻辑分段，段内划分为固定大小的页，主存空间也划分为大小相等的页</li>
<li>主存和辅存以页为调度单位</li>
<li>每个程序对应一个段表，每段对应一个页表。</li>
<li>段的长度是页长整数倍，段的起点是页的起点</li>
<li>虚地址分为段号、段内页号、页内地址（二维的，段号和段内地址分别给出）</li>
<li>地址转换
<ul>
<li>根据段表寄存器的段表长检查是否越界</li>
<li>根据段号和段表寄存器中的段起始地址找到段表项，取出该段的页表首地址和页表长度</li>
<li>根据页表长度和段内页号判断是否越界</li>
<li>根据页表首地址和段内页号找到对应页表项</li>
<li>从页表项中取出实页号和页内地址拼接为物理地址</li>
</ul></li>
<li>优点是兼备段式和页式存储器的优点，可以按段共享和保护、按页进行存储调度</li>
<li>缺点是需要2次查表，开销较大</li>
</ul>
<h4 id="ia-32设计实例">IA-32设计实例</h4>
<p><em>上一节是教科书中的经典段页式虚拟存储器的设计思路，下面给出英特尔32位架构（IA-32）/linux中的虚拟存储设计实例</em></p>
<ul>
<li>相关概念
<ul>
<li>控制寄存器CR0中
<ul>
<li>PE=1，进入保护模式</li>
<li>PG=1，启动分页</li>
</ul></li>
<li>段寄存器SR
<ul>
<li>段包括：数据段DS，代码段CS，栈堆段SS、附加段ES、FS、GS</li>
<li><strong>实模式</strong>是在32位机器推出后，对16位机器模式的一种说法，16位段寄存器保存的是段起始地址的高位，需要左移4位后加上段内偏移量，算出20位的物理地址。这种模式目前很少使用，只在开机的时候短暂的处于实模式。</li>
<li><strong>保护模式</strong>把寻址空间从20位拓展到32位，段寄存器拓展为96位，但只有16位指令可见。这16位就是下面介绍的<strong>段选择符</strong>。</li>
<li>段寄存器的作用是直接（实模式）或间接（保护模式）的确定一个段的基地址（起始线性地址）</li>
</ul></li>
<li>段描述符：共64位8字节，存放一个段的有关信息，比如起始<strong>线性地址</strong>（如果不分页，则该线性地址就是物理地址）</li>
<li>段选择符：共16位，包括13位段描述符表索引INDEX、1位判断是否为局部描述符表的标记TI、2位的特权级别RPL</li>
<li>全局描述符表GDT
<ul>
<li>一个处理器一个表，各个表项是各个段的段描述符，存放到内存里。</li>
<li>通常会有GDT描述符Cache来加速访问。</li>
</ul></li>
<li>局部描述符表LDT
<ul>
<li>一个任务一个表，存在内存里。</li>
<li>LDT本身是一个段，其段描述符就是GDT的一个项。</li>
</ul></li>
<li>全局描述符表寄存器GDTR：存放全局描述符表的起始<strong>线性地址</strong></li>
<li>局部描述符表寄存器LDTR：存放局部描述符表的<strong>段选择符</strong>，在进程切换时由OS进行更新</li>
</ul></li>
<li>逻辑地址的计算
<ul>
<li>CPU通过指令计算出操作数的有效地址EA（EA的计算参考下一章笔记的寻址方式部分）</li>
<li>有效地址作为32位段内偏移量，对应的段寄存器存放的是16位段选择符，共48位称为逻辑地址</li>
</ul></li>
<li>线性地址的计算（分段机制）
<ul>
<li>当操作数的段寄存器（16位段选择符）的TI=0，使用全局描述符表
<ul>
<li>GDTR（存的是GDT的线性首地址）和
INDEX（16位段选择符的高13位）定位一个段描述符的线性地址（若开启了分页需要进一步转成物理地址）</li>
<li>从段描述符中取出该段在线性存储空间中的首地址</li>
<li>该首地址加上32位段内偏移量得到线性地址</li>
</ul></li>
<li>当操作数的段寄存器（16位段选择符）的TI=1，使用局部描述符表
<ul>
<li>GDTR（存的是GDT的线性首地址）和
LDTR（16位段选择符）的高13位定位LDT的段描述符的线性位置（如果开启了分页，需要转换到物理地址）</li>
<li>从LDT段描述符中取出LDT的线性起始地址，和操作数的段寄存器（16位段选择符）的高13位定位操作数的段描述符的线性地址（如果开启了分页，需要转换到物理地址）</li>
<li>从段描述符中取出操作数的线性起始地址，和操作数的段内偏移量（即有效地址EA）相加，得到操作数的线性地址</li>
</ul></li>
</ul></li>
<li>物理地址的计算（分页机制）
<ul>
<li>线性地址分成10位页目录索引、10位页表索引、12位页内地址</li>
<li>页目录基址寄存器CR3（存放页目录内存首地址），结合页目录索引，定位页目录项（每项32位4字节，共1024项，刚好4KB，即页目录恰好占一页存储空间）</li>
<li>在页目录项中找到页表的物理首地址，结合页表索引，定位页表项（每项32位4字节，共1024项，刚好4KB，即页表恰好占一页存储空间）</li>
<li>在页表项中取出对应页的物理页号，结合页内地址，得到物理地址</li>
</ul></li>
<li>32位linux采用“扁平模式”
<ul>
<li>线性地址的段首地址都设置为0，等于逻辑地址就是线性地址，所有数据都看作在一个段中。</li>
<li>这样做是因为不想使用16位系统中遗留下来的分段机制，但又保持了兼容性</li>
</ul></li>
</ul>
<h3 id="虚拟存储器和cache比较">虚拟存储器和Cache比较</h3>
<ul>
<li>相同之处
<ul>
<li>都为了提高系统性能、具有容量、速度、价格的梯度</li>
<li>数据都划分为小的信息块，作为传递单位，虚存系统的信息块更大</li>
<li>都涉及地址的映射、替换算法、更新策略</li>
<li>都依据程序局部性原理来应用快速缓存的思想，把活跃的数据保存在高速的部件中</li>
</ul></li>
<li>不同之处
<ul>
<li>Cache主要解决CPU和主存存取速度不匹配问题，虚拟存储器是解决主存容量问题</li>
<li>Cache由硬件实现，对所有程序员透明；虚拟存储器由OS和硬件实现，对系统程序员不透明，对应用程序员透明</li>
<li>因为CPU的速度约是Cache
10倍，主存速度约是硬盘100倍，所以虚拟存储器不命中时对性能影响更大</li>
<li>CPU和Cache都和主存有直接访问的通路，辅存和CPU没有直接通路</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第五章-中央处理器</title>
    <url>/2021/10/31/ComputerOrganization-5/</url>
    <content><![CDATA[<h2 id="cpu的功能和基本结构">CPU的功能和基本结构</h2>
<h3 id="功能">功能</h3>
<ul>
<li>指令控制：即程序顺序控制。完成取指令、分析指令、执行指令的操作</li>
<li>操作控制：管理由内存取出的指令，并产生操作信号送往相应部件，控制这些部件动作</li>
<li>时间控制：对操作的时间进行限制，为每条指令按时间顺序提供应有的控制信号</li>
<li>数据加工：对数据进行算术和逻辑运算</li>
<li>中断处理：对计算机运行的异常和特殊请求进行处理</li>
</ul>
<h3 id="基本结构">基本结构</h3>
<ul>
<li>运算器：接受从控制器传来的命令并执行相应的动作，对数据进行加工、处理。组成为
<ul>
<li>算术逻辑单元（ALU）：进行算术逻辑运算</li>
<li>暂存寄存器：暂存主存的数据，对应用程序员透明</li>
<li>累加寄存器（ACC）：暂存ALU结果，也可以作为加法的一个输入</li>
<li>通用寄存器组：比如EAX、EBX等，详见第4章笔记的x86汇编指令入门</li>
<li>程序状态字寄存器（PSW）：即条件码，如OF、SF、ZF、CF</li>
<li>移位器：对操作数或计算结果进行移位运算</li>
<li>计数器：控制乘除操作的步数</li>
</ul></li>
<li>控制器：类型有硬布线控制和微程序控制器。作用是协调和控制计算机各部件执行程序指令序列，包括取指令、分析指令、执行指令，组成为
<ul>
<li>程序计数器（PC）：存放下一条执行指令的地址，取指令时使用，有自增功能</li>
<li>指令寄存器（IR）：保存正在执行的指令</li>
<li>指令译码器：对操作码译码， 给控制器提供特定操作信号</li>
<li>存储地址寄存器（MAR）：存放要访问数据的内存地址</li>
<li>存储数据寄存器（MDR）：存放要访问的数据</li>
<li>时序系统：产生时序信号，由时钟CLOCK分频得到</li>
<li>微操作信号发生器：根据IR、PSW和时序信号，产生控制整个计算机的控制信号，结构有
<ul>
<li>组合逻辑型：对应硬布线控制器</li>
<li>存储逻辑型：对应微程序控制器</li>
</ul></li>
</ul></li>
<li>寄存器
<ul>
<li>可以说CPU由运算器和控制器组成，事实上也可以说由运算器、控制器、寄存器组成</li>
<li>寄存器按用途分类
<ul>
<li>通用寄存器：比如EAX、EBX、ECX、EDX、ESI、EDI、EBP</li>
<li>专用寄存器：比如段寄存器（CS、DS、SS、ES、FS、GS）、EIP、PSW、IR、MAR、MDR</li>
<li>控制寄存器：CR0-CR3</li>
<li>栈顶寄存器ESP可以认为是通用寄存器或专用寄存器</li>
</ul></li>
<li>寄存器按权限分类
<ul>
<li>用户可见寄存器：通用寄存器、PSW、EIP、段寄存器</li>
<li>用户不可见寄存器：MAR、MDR、IR、控制寄存器</li>
</ul></li>
</ul></li>
</ul>
<h2 id="指令执行过程">指令执行过程</h2>
<h3 id="指令周期">指令周期</h3>
<ul>
<li>从主存取出并执行一条指令的时间为指令周期</li>
<li>指令周期分为若干机器周期（CPU周期），不同指令不一定。
<ul>
<li>机器周期可以看作指令执行过程的基准时间</li>
<li>通常以最复杂指令功能的时间，即内存读一个指令字的最短时间作为机器周期（存取周期）</li>
<li>如果指令字长等于存储字长，则取指周期可以看作机器周期</li>
</ul></li>
<li>机器周期分为若干时钟周期（节拍、振荡周期）</li>
<li>每条微操作至少需要一个时钟周期</li>
<li>如果总线不冲突，多个微操作可以在一个周期内并行（后面详见数据通路小节）。</li>
<li>机器速度除了和主频有关，也和机器周期的时钟数、指令周期的机器周期数、是否采用流水线方式等有关</li>
<li>最完整的指令周期包括四个机器周期
<ul>
<li>取指周期：访存取指令、译码、更新PC</li>
<li>间指周期：访存取有效地址</li>
<li>执行周期：访存取操作数、执行操作</li>
<li>中断周期：访存保存程序断点、形成中断服务程序的入口地址、关中断</li>
</ul></li>
<li>各种指令的指令周期
<ul>
<li>非访存指令
<ul>
<li>取指周期</li>
<li>执行周期</li>
</ul></li>
<li>直接访存指令
<ul>
<li>取指周期</li>
<li>执行周期</li>
</ul></li>
<li>间接访存指令
<ul>
<li>取指周期</li>
<li>间指周期</li>
<li>执行周期</li>
</ul></li>
<li>转移指令
<ul>
<li>取指周期</li>
<li>执行周期</li>
</ul></li>
<li>间接转移指令
<ul>
<li>取指周期</li>
<li>间址周期</li>
<li>执行周期</li>
</ul></li>
</ul></li>
<li>4个标志触发器用来区分四个机器周期，为1表示状态有效
<ul>
<li>FE：fetch</li>
<li>IND：indirect</li>
<li>EX：execute</li>
<li>INT：interupt</li>
</ul></li>
</ul>
<h3 id="指令周期的数据流">指令周期的数据流</h3>
<h4 id="取指周期">取指周期</h4>
<ul>
<li>任务是根据PC取指令放到IR中</li>
<li>数据流如下：
<ul>
<li>发送指令地址给主存：PC-&gt;MAR-&gt;地址总线-&gt;主存</li>
<li>发送读信号给主存：CPU控制器-&gt;控制总线-&gt;主存</li>
<li>接收主存的指令数据：主存-&gt;数据总线-&gt;MDR-&gt;IR</li>
<li>更新程序计数器：默认是PC+1</li>
</ul></li>
</ul>
<h4 id="间指周期">间指周期</h4>
<ul>
<li>任务是取操作数的有效地址</li>
<li>数据流如下（以一次间址为例）
<ul>
<li>发送间接地址给主存：IR（地址字段）-&gt;MAR-&gt;地址总线-&gt;主存（若是多次间址，也可以是MDR-&gt;MAR-&gt;地址总线-&gt;主存）</li>
<li>发送读信号给主存：CPU控制器-&gt;控制总线-&gt;主存</li>
<li>接收主存的有效地址：主存-&gt;数据总线-&gt;MDR-&gt;IR</li>
</ul></li>
</ul>
<h4 id="执行周期">执行周期</h4>
<ul>
<li>任务是根据操作码和操作数通过ALU产生执行结果</li>
<li>不同指令执行周期的数据流不一定</li>
</ul>
<h4 id="中断周期">中断周期</h4>
<ul>
<li>任务是处理中断请求，需要保存程序断点</li>
<li>数据流如下
<ul>
<li>控制器发送减1后的ESP给主存：ESP-&gt;MAR-&gt;地址总线-&gt;主存</li>
<li>发送写信号给主存：CPU控制器-&gt;控制总线-&gt;主存</li>
<li>程序断点存入主存：PC-&gt;MDR-&gt;数据总线-&gt;主存</li>
<li>更新PC：CPU控制器（中断程序入口）-&gt;PC</li>
</ul></li>
</ul>
<h3 id="指令执行方案">指令执行方案</h3>
<ul>
<li>单指令周期
<ul>
<li>对所有指令选用相同的执行时间完成，指令周期取决于耗时最长的指令</li>
<li>每个指令需要的时钟周期数固定</li>
<li>前一条指令完成后，下一条指令才能开始，即串行执行</li>
</ul></li>
<li>多指令周期
<ul>
<li>对不同指令用不同执行步骤完成，不要求执行时间相同</li>
<li>不同指令的时钟周期数可不同</li>
<li>前一条指令完成后，下一条指令才能开始，即串行执行</li>
</ul></li>
<li>流水线方案
<ul>
<li>指令之间并行执行，理想情况是每个时钟周期都能有一条指令完成</li>
<li>在每个时钟周期启动一条指令，多个指令同时运行，各自处于不同执行的步骤</li>
</ul></li>
</ul>
<h2 id="数据通路">数据通路</h2>
<h3 id="基本概念">基本概念</h3>
<ul>
<li>数据通路指的是功能部件之间传送数据的路径</li>
<li>功能部件有例如：ALU、通用寄存器、状态寄存器、异常中断处理逻辑等</li>
<li>通路的建立由控制信号控制，控制信号来自控制单元CU的输出端
<ul>
<li>每个时钟周期内控制信号认为是不变的</li>
<li>部件名称加上op后缀，表示<strong>操作选择</strong>控制信号</li>
<li>部件名称加上in或out后缀，表示<strong>允许输入</strong>或<strong>允许输出</strong>控制信号</li>
<li>寄存器的允许输入信号in具体的可以叫写使能信号，<strong>受时钟驱动</strong>，因为寄存器是由触发器组成
<ul>
<li>对应器件有时钟端口</li>
<li>每个时钟周期到来的时候，寄存器的值更新</li>
</ul></li>
<li>允许输出控制信号out所控制的部件称为三态门，不受时钟驱动
<ul>
<li>信号高天平表示单向输出</li>
<li>信号低电平表示阻断</li>
</ul></li>
<li>内存读写的控制信号也受到时钟控制</li>
<li>PC自动更新受到控制信号PC+1的控制</li>
</ul></li>
<li>CPU中有一个多路选择器的一端输入是常数，大小是PC自动更新的字节数</li>
<li>一般用BUS表示数据总线</li>
</ul>
<h3 id="基本结构-1">基本结构</h3>
<ul>
<li>CPU内部单总线方式：CPU中连接各部件的总线只有一条，结构简单但传输容易冲突，需要用到锁存器，是早期的选择</li>
<li>CPU内部多总线方式：CPU中有多条总线，也可以是具体指出二总线、三总线。总线数越多，需要的锁存器（暂存器）越少，需要的周期数越少，成本越高。</li>
<li>专用数据通路方式：不共享总线，根据数据通路情况设置专用的线路，现代计算机主要选择</li>
</ul>
<h3 id="微操作序列">微操作序列</h3>
<ul>
<li>使用微操作序列可以描述具体的取指令、译码、执行指令过程中的数据流向</li>
<li>一般分两列写
<ul>
<li>第一列的每行是每个周期（节拍）进行的微操作（用箭头指出数据流向，详见控制器功能的微操作命令分析）</li>
<li>若没有总线冲突，每行可以有多个微操作。</li>
<li>第二列的每行是微操作对应的控制信号情况</li>
<li>控制信号需要考虑的有in信号、out信号、op信号、PC+1信号、内存读信号R、内存写信号W</li>
</ul></li>
</ul>
<h2 id="控制器的功能和基本原理">控制器的功能和基本原理</h2>
<h3 id="微操作命令分析">微操作命令分析</h3>
<h4 id="取指周期-1">取指周期</h4>
<ul>
<li>PC-&gt;MAR-&gt;DB（PC传给地址寄存器，传给数据总线）</li>
<li>1-&gt;R（读信号传给内存储器）</li>
<li>M(MAR)-&gt;MDR（内存中读指令到数据寄存器）</li>
<li>MDR-&gt;IR（指令放到IR中）</li>
<li>OP(IR)-&gt;CU（指令操作码给CU进行译码）</li>
<li>(PC)+1-&gt;PC（更新PC）</li>
</ul>
<h4 id="间址周期">间址周期</h4>
<ul>
<li>Ad(IR)-&gt;MAR（指令地址码给数据寄存器）</li>
<li>1-&gt;R（读信号传给内存储器）</li>
<li>M(MAR)-&gt;MDR（内存中读有效地址到数据寄存器）</li>
<li>MDR-&gt; Ad(IR)（有效地址传给IR）</li>
</ul>
<h4 id="执行周期-1">执行周期</h4>
<ul>
<li>非访存指令
<ul>
<li>CLA（清空ACC）：<span class="math inline">\(0\rightarrow
ACC\)</span></li>
<li>COM（取反ACC）：<span class="math inline">\(\overline{ACC}\rightarrow ACC\)</span></li>
<li>SHR（算术右移）：
<ul>
<li><span class="math inline">\(L(ACC)\rightarrow R(ACC)\)</span></li>
<li><span class="math inline">\(ACC_0\rightarrow ACC_0\)</span></li>
</ul></li>
<li>CSL（循环左移）：
<ul>
<li><span class="math inline">\(R(ACC)\rightarrow L(ACC)\)</span></li>
<li><span class="math inline">\(ACC_0\rightarrow ACC_n\)</span></li>
</ul></li>
<li>STP（停机指令）：<span class="math inline">\(0\rightarrow
G\)</span></li>
</ul></li>
<li>访存指令
<ul>
<li>ADD X（加法指令）：
<ul>
<li><span class="math inline">\(Ad(IR)\rightarrow MAR\)</span></li>
<li><span class="math inline">\(1\rightarrow R\)</span></li>
<li><span class="math inline">\(M(MAR)\rightarrow MDR\)</span></li>
<li><span class="math inline">\((ACC)+(MDR)\rightarrow ACC\)</span></li>
</ul></li>
<li>STA X（存数指令）：
<ul>
<li><span class="math inline">\(Ad(IR)\rightarrow MAR\)</span></li>
<li><span class="math inline">\(1\rightarrow W\)</span></li>
<li><span class="math inline">\(ACC\rightarrow MDR\)</span></li>
<li><span class="math inline">\(MDR\rightarrow M(MAR)\)</span></li>
</ul></li>
<li>LDA X（取数指令）：
<ul>
<li><span class="math inline">\(Ad(IR)\rightarrow MAR\)</span></li>
<li><span class="math inline">\(1\rightarrow R\)</span></li>
<li><span class="math inline">\(M(MAR)\rightarrow MDR\)</span></li>
<li><span class="math inline">\(MDR\rightarrow ACC\)</span></li>
</ul></li>
</ul></li>
<li>转移指令
<ul>
<li>JMP X（无条件转移）：<span class="math inline">\(Ad(IR)\rightarrow
PC\)</span></li>
<li>BAN X（条件转移之最近的计算结果是负则转）：<span class="math inline">\(A_0\cdot Ad(IR)+\overline{A_0}\cdot(PC)\rightarrow
PC\)</span></li>
</ul></li>
</ul>
<h4 id="中断周期-1">中断周期</h4>
<ul>
<li>保存程序断点
<ul>
<li>程序断点存入<strong>"0"地址</strong>
<ul>
<li>0-&gt;MAR</li>
<li>1-&gt;W</li>
<li>PC-&gt;MDR</li>
<li>MDR-&gt;M(MAR)</li>
</ul></li>
<li>程序断点<strong>进栈</strong>
<ul>
<li>(SP)-1-&gt;MAR</li>
<li>1-&gt;W</li>
<li>PC-&gt;MDR</li>
<li>MDR-&gt;M(MAR)</li>
</ul></li>
</ul></li>
<li>形成中断服务程序的入口地址
<ul>
<li>硬件向量法：向量地址-&gt;PC</li>
<li>软件查询法：中断识别程序入口地址M-&gt;PC</li>
</ul></li>
<li>关中断
<ul>
<li>0-&gt;EINT</li>
</ul></li>
</ul>
<h3 id="控制器结构和功能">控制器结构和功能</h3>
<ul>
<li>不同于CPU内总线，系统总线用于连接计算机硬件系统五大部件，包括控制器、运算器、存储器、输入输出</li>
<li>系统总线分为
<ul>
<li>Data Bus 数据总线</li>
<li>Address Bus 地址总线</li>
<li>Control Bus 控制总线</li>
</ul></li>
<li>五大部件和系统总线的连接结构
<ul>
<li>控制器
<ul>
<li>DB到MDR到IR：从DB接收指令信息</li>
<li>PC到MAR到AB：把指令地址送到AB</li>
<li>CU到CB：控制单元CU通过CB提供控制信号给其他部件</li>
<li>运算器到PC：从运算器接收指令转移地址</li>
</ul></li>
<li>运算器：连向数据总线，以和内存、输入、输出设备传送数据</li>
<li>存储器（指内存）、输入设备、输出设备
<ul>
<li>用DB传送数据</li>
<li>从AB接收地址</li>
<li>从CB接收控制信号</li>
</ul></li>
<li>输入输出设备需要通过接口和总线相连</li>
</ul></li>
<li>控制器的功能
<ul>
<li>取指令（从主存），并指出下一条指令地址</li>
<li>译码，产生相应操作控制信号</li>
<li>执行指令，指挥并控制CPU、主存、IO的数据流向</li>
</ul></li>
<li>控制器的两种分类（PC和IR相同；指令执行步骤的确定方法和控制信号的给出方案不同）
<ul>
<li>硬布线控制器</li>
<li>微程序控制器</li>
</ul></li>
</ul>
<h3 id="控制单元的功能">控制单元的功能</h3>
<ul>
<li>输入
<ul>
<li>IR的操作码在经过译码产生的指令信息</li>
<li>时钟信号。每个时钟脉冲CU发出一个（或一组同时执行的）操作命令</li>
<li>标志，即执行单元的反馈信息。比如条件转移指令的控制。</li>
<li>来自系统总线的控制信号，如中断请求，DMA请求，HRQ总线请求</li>
</ul></li>
<li>输出
<ul>
<li>CPU内部控制信号，如
<ul>
<li><span class="math inline">\(R_i\rightarrow R_j\)</span></li>
<li><span class="math inline">\((PC)+1\rightarrow PC\)</span></li>
<li><span class="math inline">\(ALU\)</span>操作选择信号op，如<span class="math inline">\(+,-,and,or\)</span></li>
</ul></li>
<li>到系统控制总线的控制信号
<ul>
<li>访存控制信号<span class="math inline">\(\overline{MREQ}\)</span></li>
<li>访IO/存储器控制信号<span class="math inline">\(\overline{IO}/M\)</span></li>
<li>读内存命令<span class="math inline">\(\overline{RD}\)</span></li>
<li>写内存命令<span class="math inline">\(\overline{WR}\)</span></li>
<li>中断响应信号<span class="math inline">\(INTA\)</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="控制方式">控制方式</h3>
<ul>
<li>同步控制方式
<ul>
<li>任一微操作由统一基准时标的时序信号控制</li>
<li>以最长的微操作序列、最复杂的微操作作为标准</li>
<li>采取完全统一的、相同时钟周期数、相同时间间隔的机器周期运行不同指令</li>
</ul></li>
<li>异步控制方式
<ul>
<li>无基准时标信号</li>
<li>无固定的周期节拍，无严格的时钟同步</li>
<li>采用应答方式联络</li>
</ul></li>
<li>联合控制方式
<ul>
<li>同步和异步结合</li>
<li>大部分指令的微操作同步控制，少部分指令的微操作异步控制</li>
</ul></li>
<li>人工控制方式
<ul>
<li>Reset</li>
<li>连续或单条指令的执行转换开关</li>
<li>符合条件即停机开关</li>
</ul></li>
</ul>
<h3 id="硬布线控制器">硬布线控制器</h3>
<p><em>又叫组合逻辑控制器</em> #### 单元框图 <img src="/2021/10/31/ComputerOrganization-5/CU.png" class title="this is CU"></p>
<ul>
<li>输出<span class="math inline">\(C_i\)</span>表示控制信号</li>
<li>同时为1的输出信号表示对应操作可以在一个周期内完成</li>
<li>时钟信号控制节拍发生器产生节拍</li>
<li>节拍宽度等于时钟周期，每个节拍内机器完成一个或几个同时执行的操作</li>
<li>如下图的例子，一个机器周期，包括了四个节拍 <img src="/2021/10/31/ComputerOrganization-5/CLK.jpg" class title="this is clk"></li>
</ul>
<h4 id="单元设计步骤">单元设计步骤</h4>
<ul>
<li>列出微操作的操作时间表。表中每一行说明了在各个机器工作周期、节拍下，包含该行微操作命令信号的指令（硬件实现上操作码表示指令）的情况</li>
<li>微操作信号综合。微操作控制信号=该微操作对应的所有行的逻辑表达式的或，每行逻辑表达式=机器周期
and 节拍 and 脉冲 and 操作码 and 机器状态条件</li>
<li>绘制微操作命令逻辑图。即根据上一步的逻辑表达式绘制出每个微信号的逻辑电路图，使用逻辑门电路实现。</li>
</ul>
<h3 id="微程序控制器">微程序控制器</h3>
<p><em>又叫存储逻辑控制器</em></p>
<h4 id="基本概念-1">基本概念</h4>
<ul>
<li>微程序
<ul>
<li>把机器指令编写成微程序
<ul>
<li>每条机器指令对应一个微程序</li>
<li>所有微程序存放在<strong>控制存储器</strong>中，寻址方法同用户程序寻址</li>
<li>各个机器指令的执行周期编写为各自的微程序</li>
<li>取值周期、间址周期和中断周期单独编写为微程序（都是不同机器指令的公共微程序）</li>
<li>公共微程序中的取值微程序是必须的，即n条机器指令至少需要在控制寄存器中存入n+1个微程序</li>
</ul></li>
<li>微程序有若干<strong>微指令</strong></li>
<li>每个微指令有若干<strong>微命令</strong></li>
<li>微程序是计算机设计者事先编址并放在控制存储器中的，对程序员透明</li>
</ul></li>
<li>微命令
<ul>
<li>前面提到过微操作是计算机中最基本的不可分解的操作</li>
<li>微命令和微操作一一对应，指的是微操作的控制信号</li>
<li>微操作是微命令的执行过程</li>
<li>硬布线控制器中也有微命令的概念，不是微程序控制器中独有的概念</li>
</ul></li>
<li>微指令
<ul>
<li>前面提到过，如果每个节拍内的微命令线路不冲突，则可以并行执行（相容微命令）</li>
<li>不可同时产生和完成的微命令是互斥微命令</li>
<li>这些并行的微命令可以合并成一条微指令，一个节拍对应一条微指令</li>
<li>微指令基本格式
<ul>
<li>操作控制字段（微操作码字段）：产生各自微操作控制信号</li>
<li>顺序控制字段（微地址码字段、下地址字段）：产生下一条待执行的微指令的地址</li>
</ul></li>
</ul></li>
<li>控制存储器：相比于CPU外部的，用RAM实现的主存储器，控制存储器CM在CPU内部（控制器的CU里），用ROM实现</li>
</ul>
<h4 id="单元框图">单元框图</h4>
<ul>
<li>下图是微程序控制器的CU框图</li>
<li>包括
<ul>
<li>控制存储器CM：存放微程序，由ROM构成</li>
<li>控制存储器地址寄存器CMAR（也叫微地址寄存器）：存放微指令的地址</li>
<li>控制存储器数据寄存器CMDR（也叫微指令寄存器μIR）：存放控制寄存器中取出的微指令</li>
<li>微地址形成部件：产生初始微地址和后继微地址</li>
<li>顺序逻辑：根据时钟、标志、CMDR，从微地址形成部件中选出正确的地址，传给CMAR</li>
</ul></li>
</ul>
<img src="/2021/10/31/ComputerOrganization-5/CU2.png" class title="this is CU2">
<h4 id="工作过程">工作过程</h4>
<ul>
<li>运行公共微程序，比如取指微程序
<ul>
<li>将取指微程序的入口（一般是CM的0号单元）送到CMAR</li>
<li>从CM中读出微指令送入CMDR</li>
<li>微程序完成后，主存中的机器指令存入了IR中</li>
</ul></li>
<li>微地址形成部件根据机器指令操作码字段产生对应微程序入口地址，送入CMAR</li>
<li>从CM中读出微指令送入CMDR，并执行</li>
<li>执行完一个机器指令对应的微程序，回到第一步，继续进行公共微程序，取指微操作。</li>
</ul>
<h4 id="微指令编码方式">微指令编码方式</h4>
<ul>
<li>又叫微指令控制方式，对应微指令<strong>操作控制字段</strong>的编码方式，以形成控制信号</li>
<li>分类为
<ul>
<li>直接编码方式（直接控制方式）
<ul>
<li>每一位表示一个微命令是否有效，可以直接发出控制信号</li>
<li>简单直观并行性好，但微指令字长过长</li>
</ul></li>
<li>字段直接编码方式
<ul>
<li>把微指令分成各个小字段，每小字段经过译码后才能发出（一个）控制信号</li>
<li>互斥微命令（在一个互斥类中）放到一个小字段中，显式编码（每小字段位数不能太多，否则译码太慢）</li>
<li>相容微命令放到不同的小字段中，各小字段编码单独定义</li>
<li>可以缩减微指令字长，但需要译码才能发出微命令，速度慢</li>
<li>注意，比如某小字段有3位，只能表示8-1=7个互斥的微命令，因为需要留一个状态表示不进行微操作。</li>
</ul></li>
<li>字段间接编码方式（隐式编码方式）
<ul>
<li>一个字段的某些微命令需要由另一个字段某些微命令解释</li>
<li>进一步缩短微指令字长，但是削弱了并行控制能力</li>
</ul></li>
<li>混合编码
<ul>
<li>直接编码间接编码混合使用</li>
<li>字段间接编码一般是字段直接编码的辅助手段</li>
</ul></li>
</ul></li>
</ul>
<h4 id="微指令地址形成方式">微指令地址形成方式</h4>
<ul>
<li>基本方式
<ul>
<li>由微指令的下地址字段指出，称为断定方式</li>
<li>有时下地址字段没有指出，可以根据机器指令的操作码，经过微地址形成部件形成（该机器指令操作微程序的首地址）</li>
</ul></li>
<li>补充方式
<ul>
<li>增量计数器法，即(CMAR)+1-&gt;CMAR，适合后继指令地址连续的情况</li>
<li>分支转移法
<ul>
<li>把顺序控制字段进一步划分为转移方式的标志和转移地址（下地址）</li>
<li>标志为0表示不跳转，执行(CMAR)+1-&gt;CMAR</li>
<li>标志为1表示跳转，根据转移地址确定下一条微指令地址</li>
</ul></li>
<li>测试网络法
<ul>
<li>把下地址字段进一步划分为高位字段和低位字段</li>
<li>低位字段由测试源（状态、条件）经过测试网络进行变换，得到测试地址；高位字段不变，作为非测试地址</li>
<li>非测试地址和测试地址拼接，形成下一条微指令地址</li>
<li>适合微程序小范围的微指令跳转</li>
</ul></li>
<li>由硬件直接产生微程序入口地址
<ul>
<li>电源通电后，第一条微指令地址（取指微程序入口地址）可以由专门硬件电路产生</li>
<li>如果有中断或间址周期，其微程序首地址可以由硬件产生</li>
</ul></li>
</ul></li>
<li>根据微指令地址形成方式，把CU框图的<strong>顺序逻辑</strong>展开，如下图</li>
</ul>
<img src="/2021/10/31/ComputerOrganization-5/CU3.png" class title="this is CU3">
<h4 id="微指令格式">微指令格式</h4>
<ul>
<li>水平型微指令
<ul>
<li>格式为操作控制、顺序控制（包括判断字段、后地址字段）</li>
<li>一次能定义并执行多个并行操作</li>
<li>比如直接编码、字段直接编码、字段间接编码、混合编码</li>
<li>优点是灵活性强、可并行、微程序短、每条微指令执行时间短、不需要译码或需要简单译码</li>
<li>和机器指令差别大</li>
</ul></li>
<li>垂直型微指令
<ul>
<li>类似于机器指令操作码的方式：微操作码、 目的地址、源地址</li>
<li>一次只能定义和执行一个基本操作</li>
<li>优点是格式简单规整、编写微程序方便、微指令短</li>
<li>接近机器指令</li>
</ul></li>
<li>混合微指令
<ul>
<li>以垂直型为基础，增加不复杂的并行操作</li>
<li>便于编程、微程序不长、执行速度有所提高</li>
</ul></li>
</ul>
<h4 id="静态微程序设计和动态微程序设计">静态微程序设计和动态微程序设计</h4>
<ul>
<li>静态：微程序无需改变，采用ROM</li>
<li>动态：通过改变微指令和微程序改变机器指令，利于仿真、采用EPROM</li>
</ul>
<h4 id="毫微程序设计">毫微程序设计</h4>
<ul>
<li>微程序设计：用微程序解释机器指令</li>
<li>毫微程序设计：用毫微程序解释微指令</li>
<li>毫微程序设计本质上是一种二级结构
<ul>
<li>毫微程序放在毫微控制器中</li>
<li>毫微程序由毫微指令组成，由毫微指令来控制硬件</li>
<li>二级结构中毫微指令一般是水平型，微指令一般是垂直型</li>
</ul></li>
<li>毫微程序控控制器的基本组成如下图 <img src="/2021/10/31/ComputerOrganization-5/UCU.png" class title="this is UCU"></li>
</ul>
<h4 id="微程序控制方式">微程序控制方式</h4>
<ul>
<li>串行微程序控制：串行方式</li>
<li>并行微程序控制：流水方式</li>
</ul>
<h4 id="单元设计步骤-1">单元设计步骤</h4>
<ul>
<li>写出对应机器指令的微操作和节拍安排
<ul>
<li>微操作命令需要由CMDR的操作字段分析后发出控制信号</li>
<li>在之前微操作分析的基础上，在每条微操作前增加<strong>把下一条微指令地址送到CMAR</strong>的微操作</li>
<li>比如取指阶段的微操作序列为
<ul>
<li>节拍0：PC-&gt;MAR，1-&gt;R（本节拍微操作的微指令地址可以由硬件生成）</li>
<li>节拍1：Ad(CMDR)-&gt;CMAR（把下一节拍的微指令的地址送到CMAR）</li>
<li>节拍2：M(MAR)-&gt;MDR，(PC)+1-&gt;PC</li>
<li>节拍3：Ad(CMDR)-&gt;CMAR（把下一节拍的微指令的地址送到CMAR）</li>
<li>节拍4：MDR-&gt;IR</li>
<li>节拍5：OP(IR)-&gt;微地址形成部件-&gt;CMAR（把下一机器周期第一个节拍的微指令地址送到CMAR）</li>
</ul></li>
</ul></li>
<li>确定微指令的格式，包括
<ul>
<li>微指令编码方式：根据微操作个数确定编码方式和操作控制字段位数</li>
<li>后继微指令地址形成方式：根据控制存储器的微指令个数确定顺序控制字段位数</li>
<li>微指令字长：操作控制字段和顺序控制字段位数确定微指令字长</li>
</ul></li>
<li>编写每条微指令的码点（每条微指令的具体编码和在控制存储器中的位置）</li>
</ul>
<h3 id="硬布线和微程序控制器对比">硬布线和微程序控制器对比</h3>
<ul>
<li>工作原理
<ul>
<li>硬布线控制器由组合逻辑电路根据当前的指令码、状态、时序，即时产生微操作控制信号</li>
<li>微程序控制器以微程序的方式，通过存储在控制存储器的微指令产生微操作控制信号</li>
</ul></li>
<li>执行速度
<ul>
<li>硬布线控制器快</li>
<li>微程序控制器慢</li>
</ul></li>
<li>规整性
<ul>
<li>硬布线控制器繁琐</li>
<li>微程序控制器规整</li>
</ul></li>
<li>应用场合
<ul>
<li>硬布线控制器应用于RISC CPU</li>
<li>微程序控制器应用于CISC CPU</li>
</ul></li>
<li>易拓展性
<ul>
<li>硬布线控制器难修改</li>
<li>微程序控制器容易扩充、修改</li>
</ul></li>
</ul>
<h2 id="异常和中断机制">异常和中断机制</h2>
<h3 id="基本概念-2">基本概念</h3>
<ul>
<li>程序中断指的是计算机执行程序时，出现某些急需处理的异常或特殊请求，CPU暂时中断现行的程序，对异常情况或特殊请求进行处理，处理完后再返回原程序断点处继续执行。</li>
<li>程序中断的作用有
<ul>
<li>实现CPU和IO的并行</li>
<li>处理硬件故障、软件错误</li>
<li>实现人机交互</li>
<li>实现多道程序的切换、分时操作等</li>
<li>实现实时处理</li>
<li>实现用户态到内核态的切换，即<strong>（广义的）软中断</strong></li>
<li>多处理器系统的处理器信息交流和任务切换</li>
</ul></li>
</ul>
<h3 id="分类">分类</h3>
<ul>
<li>广义上的中断包含<strong>内部中断</strong>和<strong>外部中断</strong></li>
<li>内部中断包括软件中断（狭义的软中断）和异常（内中断一定是不可屏蔽中断），外部中断包括可屏蔽中断和不可屏蔽中断</li>
<li>软件中断指的是CPU内部的指令请求
<ul>
<li>又叫可编程中断，是软件主动发起的中断</li>
<li>软件中断实现从用户态到内核态的系统调用，完成后回到中断指令的下一条继续运行</li>
<li>比如linux的int 0x80系统调用</li>
</ul></li>
<li>异常指的是CPU内部异常产生的意外事件，包括
<ul>
<li>故障Fault
<ul>
<li>程序性事故</li>
<li>比如溢出、非法操作码、除数为0、缺页</li>
<li>故障被动性的导致用户态切换到内核态，故障是有可能修复处理的，比如缺页处理后可以继续执行</li>
<li>修复完成后从出故障的指令处重新运行（而不是运行下一条指令）</li>
</ul></li>
<li>陷阱Trap
<ul>
<li>人为设置的中断，又叫自陷</li>
<li>主要用于断点调试</li>
<li>执行Trap指令主动导致用户态切换到内核态，处理完陷阱后会返回用户态继续执行下一条指令</li>
</ul></li>
<li>终止Abort
<ul>
<li>当指令发送不可修复的故障，程序只能终止</li>
<li>操作系统把程序的进程从进程表去除</li>
</ul></li>
</ul></li>
<li>外部中断简称外中断，是狭义上的中断，指的是CPU外部和指令执行无关的事件引起的中断，包括
<ul>
<li>可屏蔽中断：通过INTR(Interrupt
Require)信号线发出的中断请求，受到中断允许寄存器和中断屏蔽位的控制（后面会介绍两者的功能和区别），比如IO设备中断（键盘输入、打印机缺纸）</li>
<li>不可屏蔽中断：通过NMI（Nonmaskable
Interrupt）信号线发出的中断请求，比如电源掉电、内存读写错误、总线奇偶校验错误、时钟中断</li>
</ul></li>
</ul>
<h3 id="检测和响应">检测和响应</h3>
<h4 id="中断请求">中断请求</h4>
<p><em>中断源如何提出中断请求</em></p>
<ul>
<li>外中断请求的识别一般由<strong>硬件完成</strong>
<ul>
<li>每个中断源设置一个INTR中断请求触发器，1位，表示是否请求中断</li>
<li>INTR可以分散在各个中断源接口电路</li>
<li>INTR也可以集中在CPU内部中断系统中，由多个INTR触发器组成中断请求寄存器</li>
</ul></li>
<li>内中断请求的识别一般由<strong>软件完成</strong>
<ul>
<li>CPU设置一个异常状态寄存器</li>
<li>操作系统使用统一的异常查询程序，按一定优先级查询异常状态寄存器</li>
<li>先查询到的先被处理</li>
</ul></li>
<li>软中断、故障、陷阱等内中断请求也可以不通过专门的查询程序识别，而是在某指令执行时识别，转到内核态进行异常处理</li>
</ul>
<h4 id="中断判优">中断判优</h4>
<p><em>多个中断源同时提出中断请求时如何进行优先级排队</em></p>
<ul>
<li><strong>硬件实现</strong>的排队器，具体有两种做法
<ul>
<li>链式排队器：分散在各个中断源的接口电路中</li>
<li>集中在CPU内</li>
</ul></li>
<li><strong>软件实现</strong>的排队器，用程序查询的方式
<ul>
<li>先查询高优先级的中断源是否有中断请求</li>
<li>是则跳转到对应中断服务程序入口地址，否则继续查询低优先级中断源是否有中断请求</li>
</ul></li>
<li>通常的优先级安排如下：
<ul>
<li>硬件故障优先级最高，其次是软件中断，这些都是不可屏蔽中断</li>
<li>不可屏蔽中断优先级高于可屏蔽中断（可屏蔽中断一定是外中断，但不是所有外中断都可屏蔽）</li>
<li>DMA请求优先级高于IO设备的中断请求，高速设备优先于低速设备、输入设备优先于输出设备、实时设备优先于普通设备</li>
</ul></li>
</ul>
<h4 id="响应条件">响应条件</h4>
<p><em>CPU什么条件下响应（外）中断</em></p>
<ul>
<li>中断源发出中断请求，即存在中断请求触发器INTR为1的中断源（INTR的设置要求中断源的中断屏蔽触发器为0，详见后面多重中断部分）</li>
<li>CPU允许中断（允许中断触发器EINT=1），即开中断（linux中是中断标志IF=1）</li>
<li>一条指令执行完毕时，且没有更紧迫任务（比如内中断）</li>
</ul>
<h4 id="响应操作">响应操作</h4>
<p><em>CPU响应（外）中断具体要进行的操作是什么</em></p>
<ul>
<li>CPU响应中断时完成的操作是<strong>中断隐指令</strong></li>
<li>中断隐指令由硬件实现，并不是真的指令系统的指令</li>
<li>中断隐指令包括的操作有
<ul>
<li>关中断
<ul>
<li>如果有中断请求（INTR不全为0）且允许中断（EINT=1)，则中断标记触发器INT设置为1，表示进入中断周期（在前面指令周期的笔记中提到过INT），此后EINT设置为0</li>
<li>关中断保证不响应更高级别的可屏蔽中断，但不可屏蔽中断依然需要响应</li>
</ul></li>
<li>保存断点：包括PC和PSW的现场信息</li>
<li>转向中断服务程序：取出中断服务程序的入口地址传给PC</li>
</ul></li>
</ul>
<h4 id="中断入口">中断入口</h4>
<p><em>如何确定中断服务程序的入口地址</em></p>
<ul>
<li>中断向量：中断服务程序的入口地址</li>
<li>中断向量地址：中断服务程序入口地址所存放的地址</li>
<li>中断向量表：存储器中集中存放中断向量的区域</li>
<li>硬件向量法
<ul>
<li>把中断优先级排队器输出，输入到向量地址形成部件，得到中断向量地址</li>
<li>根据中断向量地址到中断向量表中确定中断向量，即入口地址</li>
</ul></li>
<li>软件查询法：PC先转到中断识别程序入口地址，由中断识别程序给出中断入口地址，灵活，识别程序相比硬件实现更容易修改</li>
</ul>
<h4 id="处理过程">处理过程</h4>
<p><em>进入中断周期后的处理过程</em></p>
<ul>
<li>硬件（中断隐指令）完成的过程
<ul>
<li>关中断</li>
<li>保存断点</li>
<li>转向中断服务程序</li>
</ul></li>
<li>中断服务程序完成的过程
<ul>
<li>保存现场和屏蔽字
<ul>
<li>现场主要是一些工作寄存器，PUSH到堆栈中</li>
<li>屏蔽字在后面的多重中断的笔记中会介绍</li>
</ul></li>
<li>开中断：允许更高级别的中断响应，实现中断嵌套</li>
<li>执行中断服务程序：中断请求的目的</li>
<li>关中断：保证恢复现场和屏蔽字时不被打断</li>
<li>恢复现场和屏蔽字：从堆栈中POP出</li>
<li>开中断</li>
<li>中断返回：一般是中断服务程序的最后一条指令IRET，用于返回原程序继续执行</li>
</ul></li>
</ul>
<h4 id="多重中断">多重中断</h4>
<p><em>在执行中断服务程序时又出现新的更高级别的中断请求怎么办</em></p>
<ul>
<li>单重中断：不响应新的中断请求<br>
</li>
<li>多重中断：响应新的中断请求，又叫中断嵌套</li>
<li>多重中断使用中断屏蔽技术
<ul>
<li>每个中断源有一个中断屏蔽触发器，表示是否屏蔽该中断源，屏蔽后INTR无法置1</li>
<li>所有中断屏蔽触发器组合构成一个屏蔽字寄存器，不同的中断服务程序运行时，屏蔽字寄存器的内容不同（该内容是根据中断源优先级设置屏蔽字的）</li>
<li>屏蔽字寄存器的内容叫做屏蔽字</li>
</ul></li>
<li>中断允许寄存器和中断屏蔽字寄存器的功能区别
<ul>
<li>前者是总的中断的允许开关，决定CPU在有中断请求时是否进入中断周期</li>
<li>后者是对中断源之间的优先级关系的表示。高优先级中断源的中断服务程序运行时，低优先级的中断源在屏蔽字寄存器中所对应位（即低优先级中断源屏蔽触发器）为1，表示屏蔽掉对应优先级较低的中断请求</li>
</ul></li>
<li>多重中断需要满足的条件
<ul>
<li>中断允许寄存器满足的条件：在中断服务程序中设置开中断</li>
<li>中断屏蔽字寄存器满足的条件：仅较高优先级的中断源有权中断较低优先级的中断源</li>
</ul></li>
<li>中断响应排队优先级和中断源处理优先级的区别
<ul>
<li>中断响应排队优先级不可改变</li>
<li>中断源处理优先级可以通过重设屏蔽字来改变</li>
<li>例如下面两个图，表示ABCD四个中断请求同时到来后的响应情况。排队优先级按ABCD降序，处理优先级第一个图为ABCD降序，第二个图改为ADCB降序
<img src="/2021/10/31/ComputerOrganization-5/MW.png" class title="this is MW"></li>
</ul></li>
</ul>
<h2 id="指令流水线">指令流水线</h2>
<h3 id="基本概念-3">基本概念</h3>
<ul>
<li>一条指令的执行分为若干阶段，每个阶段用到的功能部件不同。将各个阶段看作流水段（对应一个部件），指令的执行过程构成了指令流水线</li>
<li>指令流水线是一种硬件层面的并行处理技术（进程的并行属于软件层面的并行处理技术），能明显提高计算机运行速度</li>
<li>指令流水线不包含生成控制信号的控制部件</li>
</ul>
<h3 id="基本实现">基本实现</h3>
<ul>
<li>比如指令分为取指令、分析指令（译码和间址）、执行指令三个阶段，多条指令在执行时可以是顺序执行方式或流水线执行方式</li>
<li>顺序执行方式指在完成一条指令后，才开启下一条指令。设每阶段时间为t，共n条指令，则总时间为3nt</li>
<li>流水线执行方式指的是一条指令开启第i个阶段时（i=2,3），下一条指令开启第i-1个阶段。设每阶段时间为t，共n条指令，则总时间为2t+nt</li>
<li>k级流水指的是，流水线有k个流水段。前面的例子，有三个执行阶段，即三级流水。</li>
<li>设计时，流水段的个数以最复杂的指令需要的阶段数为准，流水段的长度以最复杂的操作需要时间为准</li>
</ul>
<h3 id="流水线表示方法">流水线表示方法</h3>
<ul>
<li>采用时空图，横坐标为时间，各个流水段时间相等，纵坐标的每行对应一个流水段部件，每条指令形式上为斜线</li>
<li>也可以是横坐标为时间，各个流水段时间相等，纵坐标的每行对应每条指令，每个流水段部件形式上为斜线</li>
</ul>
<h3 id="流水线方式特点">流水线方式特点</h3>
<ul>
<li>把一个指令任务分解为多个子任务阶段，由不同功能部件并行完成</li>
<li>流水线每个功能段部件后有一个缓冲寄存器或锁存器，用来保存本段的执行结果，供下一段使用</li>
<li>流水线各功能段的时间尽量相等，防止堵塞和断流</li>
<li>流水线处理的尽量是连续任务</li>
<li>流水线需要装入和排空时间。前者是第一条任务进入流水线到完成的时间，后者是最后一条任务进入流水线到完成的时间。</li>
</ul>
<h3 id="基本分类">基本分类</h3>
<ul>
<li>按流水线使用级别分类
<ul>
<li>部件功能级：运算操作流水线</li>
<li>处理机级别：指令流水线</li>
<li>处理机间级别：宏流水线，涉及多个处理机</li>
</ul></li>
<li>按功能分类
<ul>
<li>单功能：只能实现固定功能</li>
<li>多功能：通过各个流水段的不同连接方式，可以同时或不同时的实现多个功能</li>
</ul></li>
<li>按连接方式（多功能流水线的分类）
<ul>
<li>静态流水线：各个段同时各自只能实现一个功能，多功能实现需要等任务排空后重连流水线，当连续输入不同运算时，静态流水线等同于顺序执行方式</li>
<li>动态流水线：各个段同时各自实现多个功能，效率高，控制复杂</li>
<li>下图是静态和动态流水时空图 <img src="/2021/10/31/ComputerOrganization-5/D.png" class title="this is D"></li>
</ul></li>
<li>按功能段是否有反馈信号
<ul>
<li>线性流水线:每段只经过一次，没有反馈回路</li>
<li>非线性流水线：有反馈回路，某些段多次经过，适合线性递归的运算</li>
</ul></li>
</ul>
<h3 id="影响流水线的因素">影响流水线的因素</h3>
<ul>
<li>流水线无法正确执行指令引起的阻塞、停顿，称为流水线冲突，或者冒险。</li>
<li>流水线冲突有三种：资源冲突、数据冲突、控制冲突</li>
<li>资源冲突（结构冒险）
<ul>
<li>指的是，不同流水段对硬件资源的竞争冲突</li>
<li>比如取指令和取数据都要访存</li>
<li>解决方法有
<ul>
<li>指令停顿：让后续指令暂停一个时钟周期</li>
<li>存储器分离：单独设置数据存储器和指令存储器</li>
<li>指令预取技术：适合访存周期短的情况，提前把指令取到缓存区</li>
</ul></li>
<li>现代操作系统通过采用数据Cache和指令Cache分离的方式，避免资源冲突</li>
</ul></li>
<li>数据冲突（数据相关、数据冒险）
<ul>
<li>指的是下一条指令用到当前指令计算结果确定</li>
<li>具体分为
<ul>
<li>写后读RAW：可能读到错误的旧值</li>
<li>读后写WAR：可能读到错误的新值</li>
<li>写后写WAW：可能先写新值，再写入旧值</li>
</ul></li>
<li>解决方法有
<ul>
<li>后推法：设置时钟周期的暂停，比如硬件阻塞stall和软件插入NOP指令</li>
<li>数据旁路技术：对于RAW，设置专用通路，直接把ALU计算结果作为输入。</li>
<li>编译器优化相关指令，调整指令顺序。</li>
</ul></li>
</ul></li>
<li>控制冲突（控制相关、控制冒险）
<ul>
<li>指的是，下一条指令的地址由当前指令来确定，从而造成断流</li>
<li>如果不处理，将会存在控制损失，即跳转条件成立后，流水线原先按顺序执行的一些指令都是无效的。</li>
<li>解决方法有
<ul>
<li>对转移指令的分支进行预测，提前生成转移目标地址。静态（简单）预测总是预测条件不满足；动态预测根据历史执行情况，动态预测调整，预测准确率较高</li>
<li>预取转移成功和不成功两个控制流方向的目标指令</li>
<li>加快和提前形成条件码</li>
<li>提高转移方向的猜准率</li>
</ul></li>
</ul></li>
</ul>
<h3 id="性能指标">性能指标</h3>
<ul>
<li>吞吐率TP
<ul>
<li>吞吐率指的是单位时间流水线完成的指令数量/输出结果数量</li>
<li>计算时考虑完成n条指令需要的时间，设<span class="math inline">\(k\)</span>级流水，每段<span class="math inline">\(t\)</span>时间，完成<span class="math inline">\(n\)</span>条任务，需要时间<span class="math inline">\(kt+(n-1)t=(k+n-1)t\)</span></li>
<li>实际吞吐量为<span class="math inline">\(\frac{n}{(k+n-1)t}\)</span>，最大吞吐率（任务很多，n为极限情况）为<span class="math inline">\(\frac{1}{t}\)</span></li>
</ul></li>
<li>加速比SP
<ul>
<li>加速比指的是，同一批任务，不使用流水线的时间比使用流水线的时间</li>
<li>实际加速比是<span class="math inline">\(\frac{kn}{k+n-1}\)</span>，最大加速比（任务很多，n为极限情况）是<span class="math inline">\(k\)</span></li>
</ul></li>
<li>效率E
<ul>
<li>效率指的是流水线硬件设备的利用率</li>
<li>就是时空图中，工作时空区比总的时空区</li>
<li>实际效率为<span class="math inline">\(\frac{knt}{k(k+n-1)t}=\frac{n}{k+n-1}\)</span>，最大效率（任务很多，n为极限情况）是<span class="math inline">\(1\)</span></li>
</ul></li>
</ul>
<h3 id="超标量流水线">超标量流水线</h3>
<ul>
<li>超标量流水线技术
<ul>
<li>每时钟周期并发多条独立的指令</li>
<li>配置多个功能部件，需要多个流水线</li>
<li>不能调整指令执行顺序，需要通过编译优化，把可并行的指令搭配起来</li>
<li>如下图是3个流水线并行工作 <img src="/2021/10/31/ComputerOrganization-5/SS.png" class title="this is SS"></li>
</ul></li>
<li>超流水线技术
<ul>
<li>又叫超流水技术</li>
<li>把一个时钟周期内继续分段；一个时钟周期内，一个部件使用多次</li>
<li>不能调整指令执行顺序，需要通过编译优化</li>
<li>如下图是一个时钟周期分为3段 <img src="/2021/10/31/ComputerOrganization-5/SS2.png" class title="this is SS2"></li>
</ul></li>
<li>超长指令字技术
<ul>
<li>由编译程序挖掘指令间潜在并行性</li>
<li>把多条可并行指令组合成一条具有多个操作码字段的超长指令字（可几百位）</li>
<li>采用多个处理部件，比如下图是三个 <img src="/2021/10/31/ComputerOrganization-5/SS3.png" class title="this is SS3"></li>
</ul></li>
</ul>
<h2 id="多处理器基本概念">多处理器基本概念</h2>
<h3 id="sisdsimdmimd向量处理器概念">SISD、SIMD、MIMD、向量处理器概念</h3>
<p><em>本节介绍计算机体系结构的划分</em></p>
<ul>
<li>单指令单数据流SISD
<ul>
<li>传统串行结构</li>
<li>包含一个处理器、一个存储器</li>
<li>使用指令流水方式，SISD处理器可采用多个功能部件，SISD存储器多采用多模块交叉存储器</li>
</ul></li>
<li>单指令多数据流SIMD
<ul>
<li>一条指令，多个数据流，又叫数据级并行技术</li>
<li>包含一个控制器、多个处理单元，每个处理单元处理的数据不同，但处理的指令都是同一个</li>
<li>适合处理for循环处理数组或向量数据运算</li>
</ul></li>
<li>多指令单数据流MISD：不存在</li>
<li>多指令多数据流MIMD
<ul>
<li>多条指令，多个数据流，线程级（或线程级以上）并行技术</li>
<li>分为
<ul>
<li>多计算机系统（消息传递MIMD）：各系统有各自的存储器、独立的主存空间，通过消息传递进行数据传输</li>
<li>多处理器系统（共享存储MIMD）：全称是共享存储多处理器SMP，共享地址空间，各处理器通过共享变量通信，通过存取指令访问存储器，</li>
</ul></li>
</ul></li>
<li>向量处理器
<ul>
<li>SIMD的变种</li>
<li>实现了可直接操作向量指令集的CPU</li>
<li>理念是把存储器收集的数据按顺序放到向量寄存器中，流水方式依次操作，结果写回寄存器</li>
</ul></li>
</ul>
<h3 id="硬件多线程基本概念">硬件多线程基本概念</h3>
<ul>
<li>传统CPU线程切换开销较大，需要和存储器交换数据</li>
<li>支持硬件多线程的CPU，每个线程有独立的通用寄存器组、PC，线程切换只需要激活选中的寄存器</li>
<li>硬件多线程有3种实现方式
<ul>
<li>细粒度多线程
<ul>
<li>各线程间指令无关</li>
<li>每个时钟周期切换线程</li>
</ul></li>
<li>粗粒度多线程
<ul>
<li>只在遇到阻塞时才切换线程，如Cache缺失</li>
<li>流水线需要清空和重装，切换线程开销高</li>
</ul></li>
<li>同时多线程
<ul>
<li>又叫SMT，例如因特尔处理器的超线程</li>
<li>同一时钟周期，不同线程多条指令同时执行</li>
<li>同时实现指令级并行和线程级并行</li>
</ul></li>
</ul></li>
<li>下图是硬件多线程3种实现的示例图 <img src="/2021/10/31/ComputerOrganization-5/MuL.jpg" class title="this is MuL"></li>
</ul>
<h3 id="多核处理器基本概念">多核处理器基本概念</h3>
<ul>
<li>多个处理单元（核）集中到一个CPU</li>
<li>每个核可以有各自的Cache，也可以共享Cache</li>
<li>各核是对称的，共享主存，可以认为多核处理器是SMP的简化版</li>
<li>多核处理器的多线程是并行的（同一时刻多个线程运行），而单核的多线程是并发的（交错执行，但同一时刻只有一个线程执行）</li>
</ul>
<h3 id="共享内存多处理器smp的基本概念">共享内存多处理器SMP的基本概念</h3>
<ul>
<li>多个处理器共享一个物理地址空间，通过存取指令访问存储器</li>
<li>处理器间的通信通过存储器的共享变量</li>
<li>分类有
<ul>
<li>统一存储访问（UMA）多处理器
<ul>
<li>每个处理器访存时间接近，所有CPU的地位是对称的</li>
<li>根据处理器和共享存储的连接方式，分为基于总线、基于交叉开关网络、基于多级交换网络连接几种多处理器</li>
</ul></li>
<li>非统一存储访问（NUMA）多处理器
<ul>
<li>某些处理器访存请求较快完成</li>
<li>根据处理器是否带一致性高速缓存，分为NC-NUMA和CC-NUMA</li>
</ul></li>
</ul></li>
<li>共享变量可以通过加锁的方式实现互斥访问</li>
</ul>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识总结】 第二章-进程管理</title>
    <url>/2021/11/10/operatingSystem2/</url>
    <content><![CDATA[<h2 id="进程">进程</h2>
<h3 id="进程基本概念">进程基本概念</h3>
<ul>
<li>进程的定义
<ul>
<li>具有独立功能的程序在一个数据集合上的一次执行过程（活动）</li>
<li>资源分配和调度的基本单位</li>
</ul></li>
<li>进程控制块PCB
<ul>
<li>描述进程基本情况和运行状态的数据结构</li>
<li>系统通过PCB感知进程、控制和管理进程</li>
<li>创建进程时创建PCB，撤销进程时撤销PCB，PCB是进程存在的唯一标志</li>
<li>PCB包括进程的描述信息、控制管理信息、资源分配清单、处理机有关信息</li>
<li>状态相同的各进程的PCB可以用索引表统一管理，每个表项指向一个PCB</li>
</ul></li>
<li>进程的特征
<ul>
<li>动态性：有动态的生命周期，比如：创建、活动、暂停、终止</li>
<li>并发性：多个进程实体在同一段时间内，在内存中运行，并发是引入进程的目的</li>
<li>独立性：进程实体能独立运行、获得资源、调度</li>
<li>异步性：各进程按不可预测的速度推进</li>
<li>结构性：每个进程一个PCB，进程实体包括程序段、数据段、PCB</li>
</ul></li>
</ul>
<h3 id="进程状态和转换">进程状态和转换</h3>
<h4 id="状态">状态</h4>
<ul>
<li>运行态：进程正在处理机上运行，单处理机同时刻最多只能支持一个进程运行</li>
<li>就绪态：进程获得了除了处理机外的一切资源，等待处理机资源</li>
<li>阻塞态：进程等待某资源（不是处理机）或输入输出完成</li>
<li>创建态：进程被创建时的状态，创建过程：申请空白PCB、填写控制信息和管理信息、系统给进程分配资源、进程转入就绪态</li>
<li>结束态：进程被结束时的状态，结束过程：把进程设置为结束态、资源释放和回收</li>
</ul>
<h4 id="转换">转换</h4>
<ul>
<li>新建态-&gt;就绪态：创建进程的过程</li>
<li>就绪态-&gt;运行态：就绪的进程获得CPU资源后开始运行</li>
<li>运行态-&gt;就绪态：进程时间片用完后只能让出CPU，进入就绪态，进程被动的中断</li>
<li>运行态-&gt;阻塞态：运行的进程需要申请等待某非CPU资源，或等某事件发生，进程主动的中断（系统调用）</li>
<li>阻塞态-&gt;就绪态：进程等待的时间到来，中断处理程序把进程状态改为就绪</li>
</ul>
<h3 id="进程的组织">进程的组织</h3>
<ul>
<li>进程控制块：详见前面进程基本概念</li>
<li>程序段：由进程调度程序调度到CPU执行的代码，可被多个进程共享</li>
<li>数据段：进程对应程序的原始数据、中间数据或最终结果</li>
</ul>
<h3 id="进程的控制">进程的控制</h3>
<ul>
<li>原语：进程控制的程序段，执行期间不可中断、不可分割的执行单位</li>
<li>进程创建
<ul>
<li>子进程由父进程创建，拥有父进程的资源</li>
<li>父进程撤销前先撤销所有子进程；子进程撤销后归还资源给父进程</li>
<li>创建原语
<ul>
<li>分配进程标识号</li>
<li>申请空白PCB，没PCB则创建失败</li>
<li>分配资源，没资源则创建完进入阻塞态</li>
<li>初始化PCB</li>
<li>插入就绪队列</li>
</ul></li>
</ul></li>
<li>进程阻塞
<ul>
<li>进程因为等待某非CPU资源，主动的从运行态转换到阻塞态</li>
<li>阻塞原语（block）
<ul>
<li>找到正在运行的待阻塞进程的PCB</li>
<li>保护现场，状态设置为阻塞态，停止运行</li>
<li>把PCB插入阻塞等待队列</li>
<li>CPU资源调度给其他就绪进程</li>
</ul></li>
</ul></li>
<li>进程唤醒
<ul>
<li>阻塞的进程等待的事件发生，该进程重新进入就绪态</li>
<li>唤醒原语（wakeup）
<ul>
<li>找到PCB</li>
<li>PCB移出等待队列，状态设置为就绪态</li>
<li>PCB插入就绪队列</li>
</ul></li>
</ul></li>
<li>进程切换
<ul>
<li>根据处理机的调度决策，用就绪队列中的进程替换正在运行的进程的操作</li>
<li>切换过程
<ul>
<li>保存处理机上下文到该进程的内核堆栈中，包括PC和其他寄存器</li>
<li>更新当前运行的进程PCB</li>
<li>把进程PCB移入就绪或阻塞队列</li>
<li>选择另一个进程执行，更新其PCB</li>
<li>更新内存管理的数据结构</li>
<li>从新进程的内核堆栈中恢复处理机上下文</li>
</ul></li>
</ul></li>
<li>进程终止
<ul>
<li>终止的情况
<ul>
<li>正常终止：进程任务完成</li>
<li>异常终止：进程过程异常</li>
<li>外界干预终止：用户请求、父进程请求、父进程终止</li>
</ul></li>
<li>撤销原语
<ul>
<li>检索PCB读进程状态</li>
<li>进程在执行则停止执行并释放CPU</li>
<li>有子进程则终止子进程</li>
<li>释放所有资源</li>
<li>从队列中移除PCB</li>
</ul></li>
</ul></li>
</ul>
<h3 id="进程间通信">进程间通信</h3>
<ul>
<li>共享内存
<ul>
<li>含义
<ul>
<li>进程间存在共享的存储空间</li>
<li>进程对该空间读写来交换信息</li>
<li>操作系统提供同步互斥工具</li>
</ul></li>
<li>分类
<ul>
<li>低级共享：对数据结构共享</li>
<li>高级共享：对存储区共享</li>
</ul></li>
</ul></li>
<li>消息传递
<ul>
<li>含义
<ul>
<li>进程通过操作系统提供的发送消息、接收消息原语进行数据交换</li>
<li>消息是格式化的</li>
</ul></li>
<li>分类
<ul>
<li>直接通信：发送进程把信息放到接收进程的消息缓冲区</li>
<li>间接通信（信箱通信）：发送进程把信息放到中间实体（信箱）</li>
</ul></li>
</ul></li>
<li>管道通信
<ul>
<li>管道是连接读进程和写进程的共享文件</li>
<li>管道通信是共享内存方式的改进
<ul>
<li>管道本质是固定大小的缓冲区</li>
<li>同步、互斥功能由管道本身提供</li>
<li>半双工通信，同一时刻只能单向传输</li>
</ul></li>
<li>当管道为空，读进程阻塞，等待写进程把管道写满</li>
<li>当管道写满，写进程阻塞，等待读进程把管理读空</li>
</ul></li>
</ul>
<h2 id="线程">线程</h2>
<h3 id="线程基本概念">线程基本概念</h3>
<ul>
<li>线程的定义
<ul>
<li>进程中的实体，同进程内可以有多个线程共享进程资源</li>
<li>引入线程后，进程是资源分配的基本单位，线程是处理机调度分配的基本单位</li>
</ul></li>
<li>线程和进程的比较
<ul>
<li>调度
<ul>
<li>同进程内的线程切换的开销较小</li>
<li>不同进程的线程切换引起进程切换</li>
<li>引入线程后，线程是调度基本单位</li>
</ul></li>
<li>资源拥有
<ul>
<li>进程拥有资源，是资源分配的单位</li>
<li>线程不拥有资源，同进程的线程共享进程的资源，这些线程切换开销小</li>
</ul></li>
<li>并发性
<ul>
<li>进程和线程都可以并发，操作系统并发现提高</li>
</ul></li>
<li>系统开销
<ul>
<li>进程创建、切换、撤销开销大</li>
<li>同进程的线程切换开销小（因为不拥有资源）</li>
<li>同进程的线程同步通信容易（因为共享进程的地址空间）</li>
</ul></li>
<li>地址空间
<ul>
<li>不同进程的地址空间独立</li>
<li>同进程的线程的地址空间共享</li>
</ul></li>
<li>通信
<ul>
<li>进程间存在通信，通过系统调用，由操作系统考虑同步、互斥</li>
<li>同进程的各线程不存在通信，直接读写进程数据段即可，但是也需要考虑同步和互斥</li>
</ul></li>
</ul></li>
</ul>
<h3 id="线程状态和转换">线程状态和转换</h3>
<h4 id="状态-1">状态</h4>
<ul>
<li>运行态：在处理机上运行</li>
<li>就绪态：已获得除CPU外所有资源，等待CPU</li>
<li>阻塞态：执行时因为某事件受阻，暂停</li>
</ul>
<h4 id="转换-1">转换</h4>
<p>同进程转换</p>
<h3 id="线程实现">线程实现</h3>
<ul>
<li>内核级线程KLT
<ul>
<li>内核支持的线程</li>
<li>内核进行线程管理，线程表在内核态</li>
<li>一对一模型
<ul>
<li>一个用户级线程通过编程接口对应一个内核级线程</li>
<li>优点：一个线程阻塞后，同进程的其他线程可以运行；多处理器系统中同进程的多个线程可以并行执行</li>
<li>缺点：线程管理在内核空间，开销大</li>
</ul></li>
</ul></li>
<li>用户级线程ULT
<ul>
<li>线程库支持的线程</li>
<li>用户进行线程管理，内核意识不到线程的概念，线程表在用户态</li>
<li>多对一模型
<ul>
<li>多个用户级线程通过由用户支持的线程库对应一个内核级进程</li>
<li>优点：线程管理在用户空间，开销小；调度算法用户自行实现，进程专用</li>
<li>缺点：一个线程阻塞后，整个进程都被阻塞；多处理器系统只分配一个处理器给进程，进程内线程无法并行</li>
</ul></li>
</ul></li>
<li>混合多线程
<ul>
<li>内核与线程库组合支持的线程</li>
<li>用户完成线程创建、同步、调度，线程的切换、撤销需要内核参与</li>
<li>多对多模型
<ul>
<li>m个用户级线程通过由内核支持的线程库对应n个内核级线程（n不大于m）</li>
<li>优缺点是一对一和多对一模型的折中</li>
</ul></li>
</ul></li>
</ul>
<h3 id="线程组织和控制">线程组织和控制</h3>
<ul>
<li>线程控制块TCB包括
<ul>
<li>线程标识符</li>
<li>程序计数器、状态寄存器、通用寄存器</li>
<li>线程状态</li>
<li>优先级</li>
<li>线程切换时保存现场的专用存储区</li>
<li>堆栈指针</li>
</ul></li>
<li>线程创建
<ul>
<li>由<strong>初始化线程</strong>调用<strong>线程创建函数</strong>创建新线程</li>
<li>线程创建函数需要提供参数，比如入口地址、堆栈大小、线程优先级</li>
<li>线程创建函数返回线程标识符</li>
</ul></li>
<li>线程终止
<ul>
<li>由<strong>终止线程</strong>调用线程终止函数**终止线程</li>
<li>线程终止后通常不释放资源</li>
<li>同进程其他线程执行分离函数，被终止线程与资源分离，其他线程才可用释放后资源</li>
</ul></li>
</ul>
<h2 id="处理机调度">处理机调度</h2>
<h3 id="调度基本概念">调度基本概念</h3>
<ul>
<li>调度：资源请求者数多于资源数时，资源请求者竞争资源的排队过程</li>
<li>进程调度：进程数多于处理器数时，进程竞争处理器的排队过程</li>
<li>调度层次
<ul>
<li>作业调度
<ul>
<li>高级调度</li>
<li>后备队列：连向就绪队列（<strong>作业调度</strong>）；资源请求者是外存作业；资源有内存、IO设备等</li>
</ul></li>
<li>内存调度
<ul>
<li>中级调度</li>
<li>挂起操作：进程从内存移到外存</li>
<li>激活操作：进程从外存移到主存</li>
<li>就绪挂起队列：连向就绪队列（<strong>内存调度</strong>、激活操作）；资源请求者是被挂起的就绪进程；资源是内存（在内存紧张时，内存调度把不能运行的进程移到外存，提高内存利用率）</li>
<li>阻塞挂起队列：连向就绪挂起队列；资源请求者是被挂起的阻塞进程；资源是非处理器资源或等待某事件的发生</li>
</ul></li>
<li>进程调度
<ul>
<li>低级调度</li>
<li>就绪队列：连向处理器（<strong>进程调度</strong>）和就绪挂起队列（挂起操作）；资源请求者是就绪进程；资源是处理器</li>
<li>阻塞队列：连向就绪队列和阻塞挂起队列（挂起操作）；资源请求者是阻塞进程；资源是非处理器资源或等待某事件的发生</li>
</ul></li>
</ul></li>
<li>调度从高级到低级频率递增</li>
</ul>
<h3 id="调度的目标">调度的目标</h3>
<ul>
<li>CPU利用率：CPU使用时间比总时间</li>
<li>系统吞吐量：单位时间完成作业数量</li>
<li>周转时间：作业从提交到完成的时间</li>
<li>平均周转时间：多个作业周转时间的均值</li>
<li>带权周转时间：作业周转时间比作业实际运行时间</li>
<li>平均带权周转时间：多个作业带权周转时间的均值</li>
<li>等待时间：作业等待处理机的时间</li>
<li>响应时间：作业提交到首次响应的时间</li>
</ul>
<h3 id="调度的实现">调度的实现</h3>
<h4 id="调度器">调度器</h4>
<ul>
<li>又叫调度程序（scheduler），是操作系统中用于调度CPU的组件</li>
<li>包括
<ul>
<li>排队器：把就绪进程插入就绪队列</li>
<li>分派器：从就绪队列中取出新进程，分配CPU</li>
<li>上下文切换器
<ul>
<li>保存当前进程上下文，装入分派器进程的上下文，分派程序执行</li>
<li>移出分派器进程的上下文，装入新进程的上下文，新进程执行</li>
</ul></li>
</ul></li>
</ul>
<h4 id="调度时机">调度时机</h4>
<ul>
<li>不可调度的情况
<ul>
<li>中断处理时</li>
<li>进程访问内核的临界区时，为了尽快释放临界区资源，需要加锁阻止并行</li>
<li>进行原子操作时，需要屏蔽中断，显然不可调度</li>
</ul></li>
<li>应进行调度的情况
<ul>
<li>满足调度条件，且当前进程无法继续运行</li>
<li>调度采用剥夺方式，且出现更高优先级的进程</li>
<li>中断或自陷处理结束后，中断返回前，发现置上了请求调度标志</li>
</ul></li>
</ul>
<h4 id="调度方式">调度方式</h4>
<ul>
<li>调度方式：根据高优先级进程进入就绪队列后，对当前进程的处理</li>
<li>非抢占式（非剥夺调度方式）：当前进程继续运行直至进入阻塞态，高优先级进程才运行</li>
<li>抢占式（剥夺调度方式）：当前进程停止运行进入就绪态，高优先级进程运行</li>
</ul>
<h4 id="闲逛进程">闲逛进程</h4>
<ul>
<li>定义：当就绪队列为空时，使用CPU的进程</li>
<li>特点：
<ul>
<li>无阻塞态：不需要除了CPU的其他资源</li>
<li>优先级最低：就绪队列不空立刻让出CPU</li>
</ul></li>
</ul>
<h4 id="内核级线程和用户级线程调度">内核级线程和用户级线程调度</h4>
<ul>
<li>详见前面线程实现小节的笔记</li>
</ul>
<h3 id="典型调度算法">典型调度算法</h3>
<h4 id="先来先服务调度">先来先服务调度</h4>
<ul>
<li>简称：FCFS</li>
<li>适用范围：作业调度、进程调度</li>
<li>算法思想：先进入队列的先分配资源</li>
<li>调度方式：非抢占式</li>
<li>特点
<ul>
<li>算法简单</li>
<li>效率低</li>
<li>有利于长作业，不利于短作业</li>
<li>有利于CPU繁忙型作业，不利于IO繁忙型作业</li>
</ul></li>
</ul>
<h4 id="短作业优先调度">短作业优先调度</h4>
<ul>
<li>简称：SJF</li>
<li>适用范围：一般默认是作业调度；进程调度的版本叫短进程优先调度SPF</li>
<li>算法思想：队列中预估运行时间最短的先分配资源</li>
<li>调度方式：一般默认是非抢占式；抢占式的版本叫做最短剩余时间优先调度SRTF</li>
<li>特点
<ul>
<li>有利于短作业，不利于长作业，有饥饿现象</li>
<li>未考虑任务的紧迫性</li>
<li>运行时间的预估不一定准确</li>
<li>平均等待时间和平均周转时间最少</li>
</ul></li>
</ul>
<h4 id="时间片轮转调度">时间片轮转调度</h4>
<ul>
<li>简称：RR</li>
<li>适用范围：进程调度</li>
<li>算法思想：按先来先服务的顺序，每个进程只能运行一个时间片，然后释放处理器给下一个进程</li>
<li>调度方式：抢占式</li>
<li>时间片大小设置应适当
<ul>
<li>时间片很大时，算法退化为先来先服务算法</li>
<li>时间片很小时，频繁切换进程的开销很大</li>
</ul></li>
</ul>
<h4 id="优先级调度">优先级调度</h4>
<ul>
<li>又叫优先权调度</li>
<li>适用范围：作业调度、进程调度</li>
<li>算法思想：选优先级最高的进程执行</li>
<li>调度方式：抢占式、非抢占式</li>
<li>按<strong>优先级是否可变</strong>分类
<ul>
<li>静态优先级：不可变</li>
<li>动态优先级：可变</li>
</ul></li>
<li>优先级设置原则
<ul>
<li>系统进程&gt;用户进程</li>
<li>交互型进程&gt;非交互型进程</li>
<li>IO型进程&gt;计算型进程</li>
</ul></li>
</ul>
<h4 id="高响应比调度">高响应比调度</h4>
<ul>
<li>简称：HRRF</li>
<li>适用范围：主要用于作业调度</li>
<li>算法思想：选择响应比（周转时间比执行时间）最高的作业执行</li>
<li>调度方式：非抢占式</li>
<li>特点：
<ul>
<li>等待时间相同时，执行时间越短，响应比越高</li>
<li>执行时间相同时，等待时间越长，响应比越高</li>
<li>FCFS和SJF的折中，兼顾了等待时间和执行时间，克服了饥饿现象</li>
</ul></li>
</ul>
<h4 id="多级队列调度">多级队列调度</h4>
<ul>
<li>简称：MLQ</li>
<li>适用范围：进程调度</li>
<li>算法思想
<ul>
<li>多个就绪队列，队列间设置优先级</li>
<li>每个队列内有各自的调度算法，</li>
<li>进程执行完后，回到原队列</li>
</ul></li>
<li>调度方式：根据具体的调度算法考虑</li>
</ul>
<h4 id="多级反馈队列调度">多级反馈队列调度</h4>
<ul>
<li>简称：MLFQ</li>
<li>适用范围：进程调度</li>
<li>算法思想
<ul>
<li>多个就绪队列，从第1级到第n级的优先级递增，优先级较高队列为空才考虑调度优先级较低的队列</li>
<li>每个队列设置一个时间片，优先级高的队列时间片短，是相邻的低优先级队列的时间片的一半</li>
<li>最后一级队列，按RR方式，进程时间片用完后，回到最后一级队列（通常因为时间片较大，相当于FCFS）</li>
<li>其他级队列，按FCFS的顺序，进程时间片用完后，进入下一级队列</li>
</ul></li>
<li>调度方式：抢占式（注意当第i级队列处理时，高优先级的队列出现进程，会立刻抢占CPU）</li>
<li>特点
<ul>
<li>短交互作业（终端型作业）：一般在第1级队列可完成</li>
<li>短批处理作业：一般可在前几个队列完成，周转时间短</li>
<li>长批处理作业：在前几个队列部分处理，响应时间短，但是可能有饥饿现象</li>
</ul></li>
</ul>
<h3 id="甘特图">甘特图</h3>
<p>又叫横道图，绘制方法如下 + 横坐标绘制合适的时间间隔 +
纵坐标是程序的名称 + 在各时间位置，画平行于纵坐标的虚线 +
用不同的线表示各资源（CPU、打印机等），在各个程序位置，画平行于横坐标的线
+ 各资源对应线的上方标注资源的名称</p>
<h3 id="上下文和切换机制">上下文和切换机制</h3>
<ul>
<li>详见前面进程的控制小节中，进程切换部分</li>
</ul>
<h2 id="同步与互斥">同步与互斥</h2>
<h3 id="基本概念">基本概念</h3>
<ul>
<li>临界资源：一次只允许一个进程访问的资源，如打印机</li>
<li>临界资源访问步骤
<ul>
<li>进入区
<ul>
<li>检查进程是否可以进入临界区</li>
<li>可进入的进程设置正访问临界区标识，阻止其他进程进入临界区</li>
</ul></li>
<li>临界区（临界段）：进程使用临界资源的代码</li>
<li>退出区：清除正访问临界区标识</li>
<li>剩余区：代码剩余部分</li>
</ul></li>
<li>同步：多个进程为了同一个任务，协调工作次序、等待传递信息的<strong>直接制约关系</strong></li>
<li>互斥：当一个进程进入临界区，其他进程需要等其退出临界区才能访问临界资源的<strong>间接制约关系</strong></li>
<li>同步机制准则
<ul>
<li>空闲让进（必须实现）：临界区空闲允许进程进入</li>
<li>忙则等待（必须实现）：临界区占用则其他进程等待</li>
<li>有限等待（必须实现）：进程等有限时间后可以进临界区</li>
<li>让权等待（建议实现）：进程不能进入临界区时，释放处理器资源</li>
</ul></li>
</ul>
<h3 id="临界区访问方法">临界区访问方法</h3>
<h4 id="软件方法">软件方法</h4>
<p>以两个进程访问临界区为例</p>
<ul>
<li>单标志法
<ul>
<li>算法思想
<ul>
<li>一个标志表示哪个进程可用临界区</li>
<li>进程用完后把标志取反</li>
</ul></li>
<li>缺点
<ul>
<li>一定只能交替进入临界区</li>
<li>违背“空闲让进”</li>
</ul></li>
</ul></li>
<li>双标志法（先检查）
<ul>
<li>算法思想
<ul>
<li>两个标志分别表示两个进程是否可以使用临界区</li>
<li>先检查另一方的标志是否为0，为0则设置自己标志为1</li>
<li>使用结束后把自己的标志设置为0</li>
</ul></li>
<li>缺点
<ul>
<li>双方可能先检查，都认为对方为0，然后都设置自己为1</li>
<li>违背“忙则等待”</li>
</ul></li>
</ul></li>
<li>双标志法（后检查）
<ul>
<li>算法思想
<ul>
<li>两个标志分别表示两个进程是否想使用临界区</li>
<li>先设置自己的标志为1，后检查另一方的标志是否为0，为0则使用临界区</li>
<li>使用结束后把自己的标志设置为0</li>
</ul></li>
<li>缺点
<ul>
<li>双方可能先设置自己的标志为1，都认为对方不为0，都无法使用临界区</li>
<li>违背“有限等待”</li>
</ul></li>
</ul></li>
<li>彼得森算法
<ul>
<li>算法思想
<ul>
<li>两个标志分别表示两个进程是否想使用临界区</li>
<li>再设置一个标志turn表示双方的谦让态度</li>
<li>先设置自己的标志为1（提出想法），再设置turn为另一方（表达谦让）</li>
<li>如果对方标志为1且turn为另一方则等待（即对方有想法就谦让给对方）</li>
<li>最后一次的被谦让方可以访问临界区</li>
<li>使用结束后设置自己的标志为0</li>
</ul></li>
<li>缺点
<ul>
<li>进程等待时未让出CPU资源</li>
<li>违背“让权等待”</li>
</ul></li>
</ul></li>
</ul>
<h4 id="硬件方法">硬件方法</h4>
<p>硬件方法又叫低级方法、元方法，包括</p>
<ul>
<li>中断屏蔽法
<ul>
<li>步骤
<ul>
<li>关中断</li>
<li>访问临界区</li>
<li>开中断</li>
</ul></li>
<li>特点：简单但只适用于内核进程、单处理器（中断是针对一个处理器而言）</li>
</ul></li>
<li>原子硬件指令TestAndSet
<ul>
<li>TS指令功能
<ul>
<li>设置锁变量为1</li>
<li>返回原先的锁变量</li>
</ul></li>
<li>临界区访问步骤
<ul>
<li>当TS为1则等待</li>
<li>访问完临界区把锁变量设置为0</li>
</ul></li>
<li>特点
<ul>
<li>实现简单、多进程</li>
<li>原子操作（一般都是硬件实现），屏蔽中断，只适合多处理器</li>
<li>违背“让权等待”</li>
</ul></li>
</ul></li>
<li>原子硬件指令Swap
<ul>
<li>Swap功能：交换两个变量的值（Ts指令的本质其实就是把1和锁变量旧值进行交换）</li>
<li>临界区访问步骤
<ul>
<li>新建变量old为1</li>
<li>old和锁变量交换</li>
<li>如果old为1则等待</li>
<li>访问完临界区把锁设置为0</li>
</ul></li>
<li>特点
<ul>
<li>实现简单、多进程</li>
<li>原子操作（一般都是硬件实现），屏蔽中断，只适合多处理器</li>
<li>违背“让权等待”</li>
</ul></li>
</ul></li>
</ul>
<h3 id="锁">锁</h3>
<ul>
<li>实现思路
<ul>
<li>临界区可访问标志为available</li>
<li>acquire函数
<ul>
<li>循环检查available，为0则循环检查</li>
<li>当available为1时，则available设置为0</li>
</ul></li>
<li>release函数
<ul>
<li>available设置为1</li>
</ul></li>
</ul></li>
<li>访问临界区步骤
<ul>
<li>初始化available=1</li>
<li>进程调用acquire()获得权限</li>
<li>进程使用临界区</li>
<li>进程调用release()释放权限</li>
</ul></li>
<li>特点
<ul>
<li>违背“让权等待”，有忙等待现象</li>
<li>acquire和release都是原语，硬件实现，屏蔽中断，因此只适合多处理器系统</li>
<li>资源数为1</li>
</ul></li>
</ul>
<h3 id="信号量">信号量</h3>
<h4 id="整型信号量">整型信号量</h4>
<ul>
<li>是锁方法的多资源的修改版本</li>
<li>用整型信号量S表示资源数</li>
<li>wait(S)函数对应acquire函数，简称P操作
<ul>
<li>循环检查整型资源S&gt;0是否满足，不满足则循环检测</li>
<li>当S&gt;0时，S=S-1</li>
</ul></li>
<li>signal(S)函数对应release函数，简称V操作
<ul>
<li>S=S+1</li>
</ul></li>
<li>违背“让权等待”，进程等待时一直占用处理器，不被阻塞</li>
<li>P和V都是原子操作，屏蔽中断，只适合多处理器系统</li>
</ul>
<h4 id="记录型信号量">记录型信号量</h4>
<ul>
<li>对整型信号量的忙等待现象的改进，<strong>一般默认信号量为记录型信号量</strong></li>
<li>信号量S为记录型结构体，包括资源数value和等待的进程队列list</li>
<li>wait(S)函数（简称P操作）
<ul>
<li>value=value-1</li>
<li>如果value&lt;0，则进程加入list并阻塞</li>
</ul></li>
<li>signal(S)函数（简称V操作）
<ul>
<li>value=value+1</li>
<li>如果value&lt;=0，则list中取出一个进程并唤醒</li>
</ul></li>
<li>满足“让权等待”，进程在等待时主动被阻塞（不是外部中断），单处理器系统也可以使用</li>
</ul>
<h4 id="信号量实现同步">信号量实现同步</h4>
<ul>
<li>问题：希望进程A的a操作在进程B的b操作前执行</li>
<li>实现：
<ul>
<li>初始化信号量，资源数设为0</li>
<li>a后面插入V操作：表示a执行完后出现一个资源，可以释放进程队列的B进程</li>
<li>b前面插入P操作：因为资源初始化为0，所以直接把B进程加入队列并阻塞</li>
</ul></li>
</ul>
<h4 id="信号量实现互斥">信号量实现互斥</h4>
<ul>
<li>问题：希望进程A和进程B互斥的访问一个临界区</li>
<li>实现
<ul>
<li>初始化信号量，资源数为1</li>
<li>A和B在访问前加入P操作，访问后加入V操作</li>
<li>注意
<ul>
<li>互斥的操作前后需要用PV<strong>夹紧</strong>，不能有冗余操作，比如其他同步信号量的PV</li>
<li>具体问题具体分析，但一般互斥的P需要夹紧，否则容易死锁；互斥的V不一定夹紧</li>
</ul></li>
</ul></li>
</ul>
<h4 id="信号量实现前驱关系">信号量实现前驱关系</h4>
<ul>
<li>问题：希望多个进程的操作之间满足一定的执行顺序（有向图表示），是同步问题的多进程版本</li>
<li>实现：
<ul>
<li>因为每个有向边为一个同步关系，即对应一个信号量，所以需要初始化多个信号量，资源数都设为0（一开始没有边，即没资源）</li>
<li>每个进程在执行前，对所有入边信号量进行P操作（申请入边资源）</li>
<li>每个进程执行后，对所有出边信号量进行V操作（释放出边资源）</li>
</ul></li>
</ul>
<h4 id="信号量解决问题的思路">信号量解决问题的思路</h4>
<ul>
<li>关系分析
<ul>
<li>分析进程之间的同步、互斥关系</li>
<li>每对关系需要一个信号量，<strong>想清楚该信号量对应什么资源</strong></li>
</ul></li>
<li>PV操作位置
<ul>
<li>每个进程都确定PV操作的顺序安排</li>
<li><strong>想清楚要申请什么资源，能释放什么资源</strong></li>
</ul></li>
<li>信号量设置和初始化
<ul>
<li>设置需要的信号量</li>
<li><strong>根据开始时资源数目情况进行初始化</strong></li>
</ul></li>
</ul>
<h3 id="管程">管程</h3>
<ul>
<li>管程也是一种进程同步互斥的工具</li>
<li>管程的特性保证进程互斥</li>
<li>管程提供的条件变量可灵活实现同步</li>
</ul>
<h4 id="定义">定义</h4>
<ul>
<li>组成
<ul>
<li>管程名称</li>
<li>管程内的共享数据结构，对应系统某共享资源</li>
<li>管程内共享数据结构的初始化函数</li>
<li>管程内共享数据结构的函数过程</li>
</ul></li>
<li>特点
<ul>
<li>管程像一个类，把共享资源数据结构和在该数据结构上的操作封装起来</li>
<li>一次只能一个进程进入管程，使用管程的调用接口，从而一定保证互斥</li>
</ul></li>
<li>举例
<ul>
<li>monitor <em>Name</em> { //管程名称</li>
<li>共享数据结构S; //管程内的共享数据结构</li>
<li>init_S(){S=5;} //初始化函数</li>
<li>take_away(){S=S-1;} //函数过程</li>
<li>give_back(){S=S+1;} //函数过程</li>
<li>}</li>
</ul></li>
</ul>
<h4 id="条件变量">条件变量</h4>
<ul>
<li>定义：条件变量是，进程进入管程后不满足某些条件而被阻塞的原因</li>
<li>功能
<ul>
<li>一个条件变量x包含一个阻塞队列</li>
<li>x对应条件不满足时，可调用x.wait，进程加入x的阻塞队列、阻塞进程、释放管程</li>
<li>x对应的条件满足时，可调用x.signal，从x的阻塞队列中移出一个进程唤醒</li>
</ul></li>
<li>举例
<ul>
<li>monitor <em>Name</em> { // 管程名称</li>
<li>共享数据结构S; // 管程内的共享数据结构</li>
<li>condition x; // 条件变量</li>
<li>init_S(){S=5;} // 初始化函数</li>
<li>take_away(){if(S&lt;=0) x.wait(); S=S-1;} // 函数过程</li>
<li>give_back(){S=S+1;if(有进程在阻塞队列) x.signal();} // 函数过程</li>
<li>}</li>
</ul></li>
</ul>
<h4 id="管程和信号量对比">管程和信号量对比</h4>
<ul>
<li>资源数
<ul>
<li>管程：共享数据结构</li>
<li>信号量：记录型信号量数据结构的一个成员</li>
</ul></li>
<li>资源有关操作
<ul>
<li>管程：在take_away和give_back过程实现</li>
<li>信号量：PV操作内实现</li>
</ul></li>
<li>阻塞队列
<ul>
<li>管程：包含在条件变量中</li>
<li>信号量：记录型信号量数据结构的一个成员</li>
</ul></li>
<li>阻塞队列的进出操作（进程阻塞和唤醒）
<ul>
<li>管程：条件变量的wait和signal</li>
<li>信号量：PV操作内实现</li>
</ul></li>
</ul>
<h3 id="经典同步问题">经典同步问题</h3>
<p>注： + 注意大部分同步问题的操作序列都是while(1)循环中 +
信号量类型是semaphore + 函数前缀可以是Procedure或process，也可以忽略 +
多个函数并行可以使用cobegin、coend框起来</p>
<h4 id="生产者-消费者">生产者-消费者</h4>
<ul>
<li>问题：一个初始为空，大小为n的缓冲区，生产者放产品进入，消费者拿产品出</li>
<li>思路（可参考的前面信号量解决问题的思路小节）
<ul>
<li>关系分析
<ul>
<li>缓冲区访问是互斥的，需要先获取锁资源，信号量mutex，</li>
<li>生产者放入产品的同步条件是，有空盘资源，信号量empty</li>
<li>消费者拿出产品的同步条件是，有非空盘资源，信号量full</li>
</ul></li>
<li>PV操作的位置
<ul>
<li>生产者操作序列：申请空盘、申请锁、放入产品、释放锁、提供非空盘</li>
<li>消费者操作序列：申请非空盘、申请锁、拿走产品、释放锁、提供空盘</li>
</ul></li>
<li>信号量设置和初始化
<ul>
<li>mutex=1，表示锁资源空闲</li>
<li>empty=n，表示n个空盘</li>
<li>full=0，表示0个非空盘</li>
</ul></li>
</ul></li>
</ul>
<h4 id="读者-写者问题">读者-写者问题</h4>
<ul>
<li>问题：一个文件，多个读者，多个写者。多个读者可以同时读；某写者写时不允许其他读者写者访问</li>
<li>思路
<ul>
<li>关系分析
<ul>
<li>写者访问文件需要互斥，先获得锁资源；读者访问文件需要和写者互斥，如果是第一个读者则需要获得锁资源，信号量mutex</li>
<li>需要引入一个记录读者数量的变量count</li>
<li>对count变量的访问需要互斥，锁count_mutex</li>
</ul></li>
<li>PV操作的位置
<ul>
<li>写者操作序列：申请mutex、写文件、释放mutex</li>
<li>读者操作序列：申请count_mutex、若count为0则申请mutex、count+=1、释放count_mutex、读文件、申请count_mutex、count-=1、如果count为0则释放mutex、释放count_mutex</li>
</ul></li>
<li>信号量的设置和初始化
<ul>
<li>mutex=1</li>
<li>count=0</li>
<li>count_mutex=1</li>
</ul></li>
</ul></li>
<li>上面的思路优先处理读，随着读者不断进入，写者可能饥饿。下面改成读写公平算法
<ul>
<li>关系分析
<ul>
<li>在原本的关系基础上，要求所有的读者写者有同步关系，即读者和写者公平的按申请文件的顺序进入文件</li>
<li>这可以理解成读者、写者一个个登记后才处理申请，需要信号量t表示目前有登记表资源<br>
</li>
</ul></li>
<li>PV操作的位置
<ul>
<li>写者修改思路：进入前申请登记表t，走之后才释放t，让其他人登记</li>
<li>写者操作序列：申请t、申请mutex、写文件、释放mutex、释放t</li>
<li>读者修改思路：进入前申请登记表t，再修改count（理解成登记过程），然后释放登记表。</li>
<li>读者操作序列：申请t、申请count_mutex、若count为0则申请mutex、count+=1、释放count_mutex、释放t、读文件、申请count_mutex、count-=1、如果count为0则释放mutex、释放count_mutex</li>
</ul></li>
<li>信号量的设置和初始化
<ul>
<li>mutex=1</li>
<li>count=0</li>
<li>count_mutex=1</li>
<li>t=1</li>
</ul></li>
</ul></li>
</ul>
<h4 id="哲学家进餐问题">哲学家进餐问题</h4>
<ul>
<li>问题：n个哲学家，哲学家之间有一根筷子，共n根筷子，哲学家要拿起左右边两个筷子才能吃饭。哲学家毕生都在思考和吃饭</li>
<li>初步思路
<ul>
<li>关系分析：n个筷子是互斥资源，n个信号量</li>
<li>PV操作的位置
<ul>
<li>申请左边筷子、申请右边筷子、用餐、释放右边筷子、释放左边筷子、思考</li>
</ul></li>
<li>信号量的设置和初始化
<ul>
<li>n个chopstick[n]都设置为1</li>
</ul></li>
</ul></li>
<li>该初步思路可能存在死锁，即每个哲学家拿起一侧的筷子，相互等待出现死锁</li>
<li>三种改进方法
<ul>
<li>最多允许n-1个哲学家一起用餐
<ul>
<li>关系分析：考虑座椅资源，互斥关系，引入额外信号量seat</li>
<li>PV操作位置：申请座椅、申请左边筷子、申请右边筷子、用餐、释放右边筷子、释放左边筷子、释放座椅、思考</li>
<li>信号量设置和初始化：seat=n-1，n个chopstick[n]都设置为1</li>
</ul></li>
<li>同时只允许1个哲学家拿筷子
<ul>
<li>关系分析：考虑拿筷子锁，引入额外信号量mutex</li>
<li>PV操作位置：申请mutex、申请左边筷子、申请右边筷子、释放mutex、用餐、释放右边筷子、释放左边筷子、思考</li>
<li>信号量设置和初始化：mutex=1，n个chopstick[n]都设置为1</li>
</ul></li>
<li>奇数号哲学家先拿左筷子，偶数号哲学家先拿右筷子
<ul>
<li>关系分析：不用引入额外信号量</li>
<li>PV操作位置：申请左（右）边筷子、申请右（左）边筷子、用餐、释放右边筷子、释放左边筷子、思考</li>
<li>信号设置和初始化：n个chopstick[n]都设置为1</li>
</ul></li>
</ul></li>
</ul>
<h4 id="吸烟者问题">吸烟者问题</h4>
<ul>
<li>问题：三个吸烟者，一个供应者，每次吸烟需要三种材料，吸烟者各自有一种材料，供应者可以提供三种材料。供应者提供两种材料，相应吸烟者拿材料吸烟，完成后供应者再提供其他两种材料，循环下去的过程。</li>
<li>思路
<ul>
<li>关系分析
<ul>
<li>三种材料的两两组合，共三种组合，对应三种同步资源，信号量为offer1、offer2、offer3</li>
<li>完成信号finish也是一个同步资源，由吸烟者提供给供应者</li>
<li>需要一个变量num来记录当前需要给哪个吸烟者提供材料，因为只有一个供应者可访问num，因此不需要加锁</li>
</ul></li>
<li>PV操作
<ul>
<li>吸烟者：申请offeri、吸烟、释放finish</li>
<li>供应者：num++、根据num的值释放对应offeri、申请finish</li>
</ul></li>
<li>初始化
<ul>
<li>offeri=0</li>
<li>finish=0</li>
<li>num=0</li>
</ul></li>
</ul></li>
</ul>
<h2 id="死锁">死锁</h2>
<h3 id="基本概念-1">基本概念</h3>
<ul>
<li>定义：死锁是多个进程竞争资源而造成的互相等待的僵局</li>
<li>产生原因
<ul>
<li>对不可剥夺资源的竞争</li>
<li>进程推进顺序非法</li>
<li>死锁四个必要条件
<ul>
<li>互斥：资源同段时间只能被一个进程使用</li>
<li>不可剥夺：资源只能被主动释放，不能被剥夺</li>
<li>请求并保持：请求资源的进程进入阻塞队列等待，但保持现有资源不释放</li>
<li>循环等待：存在一条进程对资源的循环等待链（如果每类资源都只有一个，则本条变为充要条件）</li>
</ul></li>
</ul></li>
<li>处理策略
<ul>
<li>死锁预防
<ul>
<li>定义：设置限制条件，破坏4个必要条件中的一个或几个</li>
<li>特点：限制严格，资源容易闲置，实现简单</li>
</ul></li>
<li>死锁避免
<ul>
<li>定义：在资源动态分配过程中，设置限制条件，让系统保持安全状态（详见后面死锁避免小节）</li>
<li>特点：限制相对较弱，不一定破坏4个必要条件，在运行时判断是否会死锁，实现复杂</li>
</ul></li>
<li>死锁检测和解除
<ul>
<li>定义：允许死锁发生，但能检测出并解除</li>
<li>特点：需要进行资源剥夺</li>
</ul></li>
</ul></li>
</ul>
<h3 id="死锁预防">死锁预防</h3>
<ul>
<li>破坏互斥条件
<ul>
<li>适用于只读的文件、磁盘、时钟</li>
<li>大部分情况不可行，因为有些资源必须互斥</li>
</ul></li>
<li>破坏不剥夺条件
<ul>
<li>适用于内存和处理器资源</li>
<li>方法一：进程申请等待新资源，主动释放已占有资源，之后需要时向系统申请</li>
<li>方法二：资源分配管理程序为进程分配资源，若资源不充足则剥夺其所有资源并阻塞，等资源充足再唤醒分配</li>
</ul></li>
<li>破坏请求并保持条件
<ul>
<li>静态分配法，进程执行前申请所有需要的资源，全部满足后再执行</li>
<li>资源利用率低</li>
</ul></li>
<li>破坏循环等待条件
<ul>
<li>层次分配法：给资源分层次
<ul>
<li>进程获得某资源后，只能申请高层次资源</li>
<li>进程释放某资源前，先释放高层次资源</li>
<li>进程获得某资源后，需要释放该资源才能申请同层次其他资源</li>
</ul></li>
<li>编号法：每个层次一个资源，即给资源编号</li>
</ul></li>
</ul>
<h3 id="死锁避免">死锁避免</h3>
<p><em>进程在动态分配资源前，先计算系统安全性，达到死锁避免的目的</em>
#### 系统安全状态 +
安全序列：进程的完成推进顺序，按该顺序分配资源能满足每个进程的资源需求 +
系统安全状态：存在安全序列 + 系统安全状态和死锁的关系 *
“破坏必要条件”是“安全状态”的真子集，保证系统安全状态不一定破坏必要条件 *
“死锁”是“不安全状态”的真子集，系统不安全状态也不一定死锁（后面补充思考会进一步分析）
* 系统安全可以保证避免死锁</p>
<h4 id="银行家算法">银行家算法</h4>
<ul>
<li>数据结构
<ul>
<li>Available向量：当前的可用资源数</li>
<li>Max矩阵：各行进程对各列资源总需求（预估上界），等于Allocation+Need</li>
<li>Allocation矩阵：各行进程对各列资源已分配量</li>
<li>Need矩阵：各行进程对各列资源的剩余需求（预估上界）</li>
<li>Work向量：系统安全判断时使用，作为Available向量的副本，这样不用修改Available</li>
<li>Request向量：银行家算法的输入，是某进程发出的资源请求</li>
</ul></li>
<li>安全判断算法（当系统安全时，求出<strong>一个</strong>安全序列）
<ul>
<li>已知当前的Need、Allocation、Available</li>
<li>备份Available，记为Work，此后对Work操作（Work=Available）</li>
<li>选择比Work小的Need行，设对应进程k，完成该进程、加入安全序列、释放资源（Work+=Allocation[k]）</li>
<li>重复上一步，直至找不到比Work小的Need行</li>
<li>如果安全序列有所有进程，则系统安全；否则系统不安全</li>
</ul></li>
<li>银行家算法（当进程k发出一个资源请求时，用银行家算法进行处理）
<ul>
<li>已知当前的Request、Need、Allocation、Available</li>
<li>检测请求合法性：Request&lt;Need[k]，不合法则报错</li>
<li>检测资源充足性：Request&lt;Available，不充足则让进程等待</li>
<li>计算资源分配后的数据：Available-=Request，Need[k]-=Request，Allocation[k]+=Request</li>
<li>检查此时系统安全性</li>
<li>如果安全则分配，不安全则让进程等待</li>
</ul></li>
</ul>
<h3 id="死锁检测和解除">死锁检测和解除</h3>
<h4 id="资源分配有向图">资源分配有向图</h4>
<ul>
<li>进程点：圆点表示一个进程</li>
<li>资源点：方形表示一类资源，如果该类资源的总数目为n，则方形内画n个小圆</li>
<li>分配边：从资源点到进程点的边，表示分配一个资源</li>
<li>请求边：进程点到资源点的边表示请求一个资源</li>
<li>分配边<strong>合法性</strong>
<ul>
<li>资源点：分配边数<span class="math inline">\(\leq\)</span>资源总数n</li>
<li>进程点：分配边数<span class="math inline">\(\leq\)</span>请求边数</li>
</ul></li>
</ul>
<h4 id="死锁定理">死锁定理</h4>
<p>利用资源分配图可用检测死锁</p>
<ul>
<li>选择非孤立进程点（孤立进程不需要资源就能执行，不用考虑），且该点的每个申请边都满足
<ul>
<li>要么已有对应资源的分配边</li>
<li>要么对应资源可以<strong>合法的新添</strong>的分配边</li>
</ul></li>
<li>简化：上一步所选的非孤立点进程，执行、完成、释放资源、去掉边，该进程点简化为孤立点</li>
<li>返回第二步重复执行
<ul>
<li>如果全是孤立点，则不存在死锁</li>
<li>如果存在非孤立点，但这些点无法简化，则存在死锁</li>
</ul></li>
</ul>
<h4 id="补充思考">补充思考</h4>
<ul>
<li>问题：系统安全性判断、死锁定理十分相似，但为什么找不到安全序列，不一定死锁；找不到简化序列，一定死锁</li>
<li>回答
<ul>
<li>找不到安全序列
<ul>
<li>指的是所有进程的Need都不比Work小的情况</li>
<li>Need是剩余资源需求，是对接下来资源请求<strong>上界的估计</strong></li>
<li>找不到安全序列不一定死锁，因为实际资源请求不一定到上界</li>
</ul></li>
<li>找不到简化序列
<ul>
<li>指的是所有进程的Request都不比Work小的情况</li>
<li>Request是实际已发出的资源申请</li>
<li>实际的资源请求得不到满足，必然死锁，所有进程都处于阻塞态</li>
</ul></li>
</ul></li>
</ul>
<h4 id="死锁解除">死锁解除</h4>
<ul>
<li>资源剥夺
<ul>
<li>挂起进程、剥夺资源</li>
</ul></li>
<li>撤销进程
<ul>
<li>撤销进程、剥夺资源</li>
</ul></li>
<li>进程回退法
<ul>
<li>回退进程、非剥夺的主动释放资源</li>
<li>要求进程保存历史信息设置还原点</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Knowledge Summary</tag>
      </tags>
  </entry>
</search>
